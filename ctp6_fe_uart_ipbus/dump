
ctp6_fe_uart_ipbus.elf:     file format elf32-microblazeel


Disassembly of section .vectors.reset:

00000000 <_start>:
   0:	b0000000 	imm	0
   4:	b8080050 	brai	80	// 50 <_start1>

Disassembly of section .vectors.sw_exception:

00000008 <_vector_sw_exception>:
   8:	b0000000 	imm	0
   c:	b8080254 	brai	596	// 254 <_exception_handler>

Disassembly of section .vectors.interrupt:

00000010 <_vector_interrupt>:
  10:	b0000000 	imm	0
  14:	b808035c 	brai	860	// 35c <__interrupt_handler>

Disassembly of section .vectors.hw_exception:

00000020 <_vector_hw_exception>:
  20:	b0000000 	imm	0
  24:	b808026c 	brai	620	// 26c <_hw_exception_handler>

Disassembly of section .text:

00000050 <_start1>:
      50:	b0000000 	imm	0
      54:	31a0ea70 	addik	r13, r0, -5520	// ea70 <_SDA_BASE_>
      58:	b0000000 	imm	0
      5c:	3040e350 	addik	r2, r0, -7344	// e350 <_SDA2_BASE_>
      60:	b0000000 	imm	0
      64:	3020f4b0 	addik	r1, r0, -2896
      68:	b0000000 	imm	0
      6c:	b9f40138 	brlid	r15, 312	// 1a4 <_crtinit>
      70:	80000000 	or	r0, r0, r0
      74:	b0000000 	imm	0
      78:	b9f41210 	brlid	r15, 4624	// 1288 <exit>
      7c:	30a30000 	addik	r5, r3, 0

00000080 <_exit>:
      80:	b8000000 	bri	0	// 80 <_exit>

00000084 <__do_global_dtors_aux>:
      84:	b0000000 	imm	0
      88:	e060ea70 	lbui	r3, r0, -5520	// ea70 <_SDA_BASE_>
      8c:	3021ffe0 	addik	r1, r1, -32
      90:	f9e10000 	swi	r15, r1, 0
      94:	be23009c 	bneid	r3, 156		// 130
      98:	fa61001c 	swi	r19, r1, 28
      9c:	b0000000 	imm	0
      a0:	3080d5b0 	addik	r4, r0, -10832	// d5b0 <__CTOR_END__>
      a4:	b0000000 	imm	0
      a8:	30a0d5b4 	addik	r5, r0, -10828	// d5b4 <__DTOR_END__>
      ac:	b0000000 	imm	0
      b0:	e860ea74 	lwi	r3, r0, -5516	// ea74 <dtor_idx.2337>
      b4:	14842800 	rsubk	r4, r4, r5
      b8:	12602000 	addk	r19, r0, r4
      bc:	92640001 	sra	r19, r4
      c0:	92730001 	sra	r19, r19
      c4:	3273ffff 	addik	r19, r19, -1
      c8:	14931803 	cmpu	r4, r19, r3
      cc:	bea4003c 	bgeid	r4, 60		// 108
      d0:	30630001 	addik	r3, r3, 1
      d4:	60830004 	muli	r4, r3, 4
      d8:	b0000000 	imm	0
      dc:	3084d5b0 	addik	r4, r4, -10832
      e0:	e8840000 	lwi	r4, r4, 0
      e4:	b0000000 	imm	0
      e8:	f860ea74 	swi	r3, r0, -5516	// ea74 <dtor_idx.2337>
      ec:	99fc2000 	brald	r15, r4
      f0:	80000000 	or	r0, r0, r0
      f4:	b0000000 	imm	0
      f8:	e860ea74 	lwi	r3, r0, -5516	// ea74 <dtor_idx.2337>
      fc:	14931803 	cmpu	r4, r19, r3
     100:	be44ffd4 	bltid	r4, -44		// d4
     104:	30630001 	addik	r3, r3, 1
     108:	b0000000 	imm	0
     10c:	30600000 	addik	r3, r0, 0
     110:	bc030014 	beqi	r3, 20		// 124
     114:	b0000000 	imm	0
     118:	30a0e9ec 	addik	r5, r0, -5652	// e9ec <__data_end>
     11c:	99fc1800 	brald	r15, r3
     120:	80000000 	or	r0, r0, r0
     124:	30600001 	addik	r3, r0, 1
     128:	b0000000 	imm	0
     12c:	f060ea70 	sbi	r3, r0, -5520	// ea70 <_SDA_BASE_>
     130:	e9e10000 	lwi	r15, r1, 0
     134:	ea61001c 	lwi	r19, r1, 28
     138:	b60f0008 	rtsd	r15, 8
     13c:	30210020 	addik	r1, r1, 32

00000140 <frame_dummy>:
     140:	b0000000 	imm	0
     144:	30600000 	addik	r3, r0, 0
     148:	3021ffe4 	addik	r1, r1, -28
     14c:	be030020 	beqid	r3, 32		// 16c
     150:	f9e10000 	swi	r15, r1, 0
     154:	b0000000 	imm	0
     158:	30a0e9ec 	addik	r5, r0, -5652	// e9ec <__data_end>
     15c:	b0000000 	imm	0
     160:	30c0ea78 	addik	r6, r0, -5512	// ea78 <object.2347>
     164:	99fc1800 	brald	r15, r3
     168:	80000000 	or	r0, r0, r0
     16c:	b0000000 	imm	0
     170:	e860ea68 	lwi	r3, r0, -5528	// ea68 <__JCR_END__>
     174:	be030028 	beqid	r3, 40		// 19c
     178:	e9e10000 	lwi	r15, r1, 0
     17c:	b0000000 	imm	0
     180:	30600000 	addik	r3, r0, 0
     184:	bc030018 	beqi	r3, 24		// 19c
     188:	b0000000 	imm	0
     18c:	30a0ea68 	addik	r5, r0, -5528	// ea68 <__JCR_END__>
     190:	99fc1800 	brald	r15, r3
     194:	80000000 	or	r0, r0, r0
     198:	e9e10000 	lwi	r15, r1, 0
     19c:	b60f0008 	rtsd	r15, 8
     1a0:	3021001c 	addik	r1, r1, 28

000001a4 <_crtinit>:
     1a4:	2021ffec 	addi	r1, r1, -20
     1a8:	f9e10000 	swi	r15, r1, 0
     1ac:	b0000000 	imm	0
     1b0:	20c0ea70 	addi	r6, r0, -5520	// ea70 <_SDA_BASE_>
     1b4:	b0000000 	imm	0
     1b8:	20e0ea70 	addi	r7, r0, -5520	// ea70 <_SDA_BASE_>
     1bc:	06463800 	rsub	r18, r6, r7
     1c0:	bc720014 	blei	r18, 20		// 1d4
     1c4:	f8060000 	swi	r0, r6, 0
     1c8:	20c60004 	addi	r6, r6, 4
     1cc:	06463800 	rsub	r18, r6, r7
     1d0:	bc92fff4 	bgti	r18, -12		// 1c4
     1d4:	b0000000 	imm	0
     1d8:	20c0ea70 	addi	r6, r0, -5520	// ea70 <_SDA_BASE_>
     1dc:	b0000000 	imm	0
     1e0:	20e0ecc0 	addi	r7, r0, -4928	// ecc0 <__bss_end>
     1e4:	06463800 	rsub	r18, r6, r7
     1e8:	bc720014 	blei	r18, 20		// 1fc
     1ec:	f8060000 	swi	r0, r6, 0
     1f0:	20c60004 	addi	r6, r6, 4
     1f4:	06463800 	rsub	r18, r6, r7
     1f8:	bc92fff4 	bgti	r18, -12		// 1ec
     1fc:	b0000000 	imm	0
     200:	b9f40064 	brlid	r15, 100	// 264 <_program_init>
     204:	80000000 	or	r0, r0, r0
     208:	b0000000 	imm	0
     20c:	b9f4d340 	brlid	r15, -11456	// d54c <__init>
     210:	80000000 	or	r0, r0, r0
     214:	20c00000 	addi	r6, r0, 0
     218:	20e00000 	addi	r7, r0, 0
     21c:	b0000000 	imm	0
     220:	b9f4d064 	brlid	r15, -12188	// d284 <main>
     224:	20a00000 	addi	r5, r0, 0
     228:	32630000 	addik	r19, r3, 0
     22c:	b0000000 	imm	0
     230:	b9f4d358 	brlid	r15, -11432	// d588 <__fini>
     234:	80000000 	or	r0, r0, r0
     238:	b0000000 	imm	0
     23c:	b9f40020 	brlid	r15, 32	// 25c <_program_clean>
     240:	80000000 	or	r0, r0, r0
     244:	c9e10000 	lw	r15, r1, r0
     248:	30730000 	addik	r3, r19, 0
     24c:	b60f0008 	rtsd	r15, 8
     250:	20210014 	addi	r1, r1, 20

00000254 <_exception_handler>:
     254:	b6110000 	rtsd	r17, 0
     258:	80000000 	or	r0, r0, r0

0000025c <_program_clean>:
     25c:	b60f0008 	rtsd	r15, 8
     260:	80000000 	or	r0, r0, r0

00000264 <_program_init>:
     264:	b60f0008 	rtsd	r15, 8
     268:	80000000 	or	r0, r0, r0

0000026c <_hw_exception_handler>:
	bri	0;					/* Halt here if stack protection violation */
ex_handler_not_sp_violation:
	lwi	r3, r0, mb_sp_save_r3;			/* Restore temporary register              */
#endif /* defined(XPAR_MICROBLAZE_USE_STACK_PROTECTION) && (XPAR_MICROBLAZE_USE_STACK_PROTECTION == 1) */

        addik   r1, r1, -(EX_HANDLER_STACK_SIZ);        /* Create stack frame */
     26c:	3021ffac 	addik	r1, r1, -84
        PUSH_REG(3);              
     270:	f8610010 	swi	r3, r1, 16
        PUSH_REG(4);              
     274:	f8810014 	swi	r4, r1, 20
        PUSH_REG(5);              
     278:	f8a10018 	swi	r5, r1, 24
        PUSH_REG(6);
     27c:	f8c1001c 	swi	r6, r1, 28
#ifdef MICROBLAZE_CAN_HANDLE_EXCEPTIONS_IN_DELAY_SLOTS
        mfs     r6, resr;
     280:	94c08005 	mfs	r6, resr
        andi    r6, r6, ESR_DS_MASK;
     284:	a4c61000 	andi	r6, r6, 4096
        beqi    r6, ex_handler_no_ds;
     288:	bc060008 	beqi	r6, 8	// 290 <ex_handler_no_ds>
        mfs     r17, rbtr;
     28c:	9620800b 	mfs	r17, rbtr

00000290 <ex_handler_no_ds>:
ex_handler_no_ds:       
#endif
        PUSH_R17;    
     290:	fa210000 	swi	r17, r1, 0
        PUSH_MSR_AND_ENABLE_EXC;                        /* Exceptions enabled here. This will allow nested exceptions */
     294:	94a08001 	mfs	r5, rmsr
     298:	f8a10050 	swi	r5, r1, 80
     29c:	a0a50100 	ori	r5, r5, 256
     2a0:	9405c001 	mts	rmsr, r5
                
        mfs     r3, resr;    
     2a4:	94608005 	mfs	r3, resr
        andi    r5, r3, ESR_EXC_MASK;                   /* Extract ESR[EXC]                     */
     2a8:	a4a3001f 	andi	r5, r3, 31

000002ac <handle_other_ex>:
        xori   r6, r5, 6;                               /* 00110 = FPU exception */
        beqi   r6, handle_fp_ex;                        /* Go and decode the FP exception */
#endif  /* defined (MICROBLAZE_FP_EXCEPTION_ENABLED) && defined (MICROBLAZE_FP_EXCEPTION_DECODE) */

handle_other_ex:                                        /* Handle Other exceptions here         */        
        ori     r6, r0, 20; 
     2ac:	a0c00014 	ori	r6, r0, 20
        cmp     r6, r5, r6;                             /* >= 20 are exceptions we do not handle. */
     2b0:	14c53001 	cmp	r6, r5, r6
        blei    r6, ex_handler_unhandled;
     2b4:	bc6600a4 	blei	r6, 164	// 358 <ex_handler_unhandled>

        ori     r6, r0, 7;
     2b8:	a0c00007 	ori	r6, r0, 7
        cmp     r6, r5, r6;                             /* Convert MMU exception indices into an ordinal of 7 */
     2bc:	14c53001 	cmp	r6, r5, r6
        bgti    r6, handle_other_ex_tail;
     2c0:	bc860008 	bgti	r6, 8	// 2c8 <handle_other_ex_tail>
        ori     r5, r0, 0x7; 
     2c4:	a0a00007 	ori	r5, r0, 7

000002c8 <handle_other_ex_tail>:
                
handle_other_ex_tail:       
        PUSH_REG(7);                                    /* Save other volatiles before we make procedure calls below   */
     2c8:	f8e10020 	swi	r7, r1, 32
        PUSH_REG(8);             
     2cc:	f9010024 	swi	r8, r1, 36
        PUSH_REG(9);              
     2d0:	f9210028 	swi	r9, r1, 40
        PUSH_REG(10);             
     2d4:	f941002c 	swi	r10, r1, 44
        PUSH_REG(11);             
     2d8:	f9610030 	swi	r11, r1, 48
        PUSH_REG(12);
     2dc:	f9810034 	swi	r12, r1, 52
        PUSH_REG(15);
     2e0:	f9e10040 	swi	r15, r1, 64
        PUSH_REG(18);        
     2e4:	fa41004c 	swi	r18, r1, 76
     2e8:	b0000000 	imm	0

        la      r4, r0, MB_ExceptionVectorTable;        /* Load the Exception vector table base address         */
     2ec:	3080e358 	addik	r4, r0, -7336	// e358 <MB_ExceptionVectorTable>
        addk    r7, r5, r5;                             /* Calculate exception vector offset = r5 * 8           */
     2f0:	10e52800 	addk	r7, r5, r5
        addk    r7, r7, r7;         
     2f4:	10e73800 	addk	r7, r7, r7
        addk    r7, r7, r7;
     2f8:	10e73800 	addk	r7, r7, r7
        addk    r7, r7, r4;                             /* Get pointer to exception vector               */
     2fc:	10e72000 	addk	r7, r7, r4
        lwi     r5, r7, 4;                              /* Load argument to exception handler from table */
     300:	e8a70004 	lwi	r5, r7, 4
        lw      r7, r7, r0;                             /* Load vector itself here                       */
     304:	c8e70000 	lw	r7, r7, r0

        brald   r15, r7;                                /* Branch to handler                             */
     308:	99fc3800 	brald	r15, r7
        nop;
     30c:	80000000 	or	r0, r0, r0
        
        POP_REG(7);                                     /* Restore other volatiles */
     310:	e8e10020 	lwi	r7, r1, 32
        POP_REG(8);              
     314:	e9010024 	lwi	r8, r1, 36
        POP_REG(9);               
     318:	e9210028 	lwi	r9, r1, 40
        POP_REG(10);              
     31c:	e941002c 	lwi	r10, r1, 44
        POP_REG(11);              
     320:	e9610030 	lwi	r11, r1, 48
        POP_REG(12);
     324:	e9810034 	lwi	r12, r1, 52
        POP_REG(15);
     328:	e9e10040 	lwi	r15, r1, 64
        POP_REG(18);        
     32c:	ea41004c 	lwi	r18, r1, 76

        bri     ex_handler_done;                        /* Complete exception handling       */        
     330:	b8000004 	bri	4	// 334 <ex_handler_done>

00000334 <ex_handler_done>:
fp_ex_unhandled:    
        bri     0; 
#endif  /* defined (MICROBLAZE_FP_EXCEPTION_ENABLED) && defined (MICROBLAZE_FP_EXCEPTION_DECODE) */
                     
ex_handler_done:
        POP_R17;
     334:	ea210000 	lwi	r17, r1, 0
        POP_MSR;
     338:	e8a10050 	lwi	r5, r1, 80
     33c:	9405c001 	mts	rmsr, r5
        POP_REG(3);               
     340:	e8610010 	lwi	r3, r1, 16
        POP_REG(4);               
     344:	e8810014 	lwi	r4, r1, 20
        POP_REG(5);               
     348:	e8a10018 	lwi	r5, r1, 24
        POP_REG(6); 
     34c:	e8c1001c 	lwi	r6, r1, 28

        rted    r17, 0
     350:	b6910000 	rted	r17, 0
        addik   r1, r1, (EX_HANDLER_STACK_SIZ);         /* Restore stack frame  */        
     354:	30210054 	addik	r1, r1, 84

00000358 <ex_handler_unhandled>:
ex_handler_unhandled:   
        bri 0                                           /* UNHANDLED. TRAP HERE */                                                 
     358:	b8000000 	bri	0	// 358 <ex_handler_unhandled>

0000035c <__interrupt_handler>:
*
* None.
*
******************************************************************************/
void __interrupt_handler(void)
{
     35c:	3021ffac 	addik	r1, r1, -84
     360:	f9e10000 	swi	r15, r1, 0
     364:	f8210020 	swi	r1, r1, 32
     368:	f8610024 	swi	r3, r1, 36
     36c:	f8810028 	swi	r4, r1, 40
     370:	f8a1002c 	swi	r5, r1, 44
     374:	f8c10030 	swi	r6, r1, 48
     378:	f8e10034 	swi	r7, r1, 52
     37c:	f9010038 	swi	r8, r1, 56
     380:	f921003c 	swi	r9, r1, 60
     384:	f9410040 	swi	r10, r1, 64
	/* The compiler saves all volatiles and the MSR */
	MB_InterruptVectorTable.Handler(MB_InterruptVectorTable.CallBackRef);
     388:	b0000000 	imm	0
     38c:	3060e398 	addik	r3, r0, -7272	// e398 <MB_InterruptVectorTable>
*
* None.
*
******************************************************************************/
void __interrupt_handler(void)
{
     390:	f9610044 	swi	r11, r1, 68
     394:	f9810048 	swi	r12, r1, 72
     398:	fa21004c 	swi	r17, r1, 76
     39c:	95608001 	mfs	r11, rmsr
	/* The compiler saves all volatiles and the MSR */
	MB_InterruptVectorTable.Handler(MB_InterruptVectorTable.CallBackRef);
     3a0:	e8830000 	lwi	r4, r3, 0
     3a4:	e8a30004 	lwi	r5, r3, 4
*
* None.
*
******************************************************************************/
void __interrupt_handler(void)
{
     3a8:	fa410050 	swi	r18, r1, 80
     3ac:	f961001c 	swi	r11, r1, 28
	/* The compiler saves all volatiles and the MSR */
	MB_InterruptVectorTable.Handler(MB_InterruptVectorTable.CallBackRef);
     3b0:	99fc2000 	brald	r15, r4
     3b4:	80000000 	or	r0, r0, r0
	/* The compiler restores all volatiles and MSR, and returns from interrupt */
}
     3b8:	e9e10000 	lwi	r15, r1, 0
     3bc:	e961001c 	lwi	r11, r1, 28
     3c0:	e8210020 	lwi	r1, r1, 32
     3c4:	940bc001 	mts	rmsr, r11
     3c8:	e8610024 	lwi	r3, r1, 36
     3cc:	e8810028 	lwi	r4, r1, 40
     3d0:	e8a1002c 	lwi	r5, r1, 44
     3d4:	e8c10030 	lwi	r6, r1, 48
     3d8:	e8e10034 	lwi	r7, r1, 52
     3dc:	e9010038 	lwi	r8, r1, 56
     3e0:	e921003c 	lwi	r9, r1, 60
     3e4:	e9410040 	lwi	r10, r1, 64
     3e8:	e9610044 	lwi	r11, r1, 68
     3ec:	e9810048 	lwi	r12, r1, 72
     3f0:	ea21004c 	lwi	r17, r1, 76
     3f4:	ea410050 	lwi	r18, r1, 80
     3f8:	b62e0000 	rtid	r14, 0
     3fc:	30210054 	addik	r1, r1, 84

00000400 <microblaze_register_handler>:
* None.
*
****************************************************************************/
void microblaze_register_handler(XInterruptHandler Handler, void *DataPtr)
{
   MB_InterruptVectorTable.Handler = Handler;
     400:	b0000000 	imm	0
     404:	3060e398 	addik	r3, r0, -7272	// e398 <MB_InterruptVectorTable>
     408:	f8a30000 	swi	r5, r3, 0
   MB_InterruptVectorTable.CallBackRef = DataPtr;
}
     40c:	b60f0008 	rtsd	r15, 8
     410:	f8c30004 	swi	r6, r3, 4

00000414 <XIntc_DeviceInterruptHandler>:
* for the interrupt controller. XPAR_INTC_MAX_NUM_INTR_INPUTS specifies the
* highest numbered interrupt input signal that is used.
*
******************************************************************************/
void XIntc_DeviceInterruptHandler(void *DeviceId)
{
     414:	3021ffd0 	addik	r1, r1, -48
	int IntrNumber;
	XIntc_Config *CfgPtr;
	u32 Imr;

	/* Get the configuration data using the device ID */
	CfgPtr = &XIntc_ConfigTable[(u32) DeviceId];
     418:	60a50040 	muli	r5, r5, 64
* for the interrupt controller. XPAR_INTC_MAX_NUM_INTR_INPUTS specifies the
* highest numbered interrupt input signal that is used.
*
******************************************************************************/
void XIntc_DeviceInterruptHandler(void *DeviceId)
{
     41c:	fa61001c 	swi	r19, r1, 28
     420:	f9e10000 	swi	r15, r1, 0
     424:	fac10020 	swi	r22, r1, 32
     428:	fae10024 	swi	r23, r1, 36
     42c:	fb010028 	swi	r24, r1, 40
     430:	fb21002c 	swi	r25, r1, 44
	int IntrNumber;
	XIntc_Config *CfgPtr;
	u32 Imr;

	/* Get the configuration data using the device ID */
	CfgPtr = &XIntc_ConfigTable[(u32) DeviceId];
     434:	b0000000 	imm	0
     438:	3265e3a8 	addik	r19, r5, -7256

	/* Get the interrupts that are waiting to be serviced */
	IntrStatus = XIntc_GetIntrStatus(CfgPtr->BaseAddress);
     43c:	e8730004 	lwi	r3, r19, 4

	/* Mask the Fast Interrupts */
	if (CfgPtr->FastIntr == TRUE) {
     440:	e893000c 	lwi	r4, r19, 12

	/* Get the configuration data using the device ID */
	CfgPtr = &XIntc_ConfigTable[(u32) DeviceId];

	/* Get the interrupts that are waiting to be serviced */
	IntrStatus = XIntc_GetIntrStatus(CfgPtr->BaseAddress);
     444:	e8a30000 	lwi	r5, r3, 0
     448:	eac30008 	lwi	r22, r3, 8

	/* Mask the Fast Interrupts */
	if (CfgPtr->FastIntr == TRUE) {
     44c:	a8840001 	xori	r4, r4, 1
     450:	be0400ac 	beqid	r4, 172		// 4fc
     454:	86d62800 	and	r22, r22, r5
* for the interrupt controller. XPAR_INTC_MAX_NUM_INTR_INPUTS specifies the
* highest numbered interrupt input signal that is used.
*
******************************************************************************/
void XIntc_DeviceInterruptHandler(void *DeviceId)
{
     458:	33000005 	addik	r24, r0, 5
     45c:	13200000 	addk	r25, r0, r0
     460:	32e00001 	addik	r23, r0, 1

			/* The interrupt is active and enabled, call the
			 * interrupt handler that was setup with the specified
			 * parameter
			 */
			TablePtr = &(CfgPtr->HandlerTable[IntrNumber]);
     464:	30990003 	addik	r4, r25, 3
     468:	60840008 	muli	r4, r4, 8
	 * bit in the register from LSB to MSB which corresponds to an interrupt
	 * intput signal
	 */
	for (IntrNumber = 0; IntrNumber < XPAR_INTC_MAX_NUM_INTR_INPUTS;
	     IntrNumber++) {
		if (IntrStatus & 1) {
     46c:	a4b60001 	andi	r5, r22, 1

			/* The interrupt is active and enabled, call the
			 * interrupt handler that was setup with the specified
			 * parameter
			 */
			TablePtr = &(CfgPtr->HandlerTable[IntrNumber]);
     470:	10d32000 	addk	r6, r19, r4
			}
		}

		/* Move to the next interrupt to check */
		IntrMask <<= 1;
		IntrStatus >>= 1;
     474:	92d60041 	srl	r22, r22
	 * bit in the register from LSB to MSB which corresponds to an interrupt
	 * intput signal
	 */
	for (IntrNumber = 0; IntrNumber < XPAR_INTC_MAX_NUM_INTR_INPUTS;
	     IntrNumber++) {
		if (IntrStatus & 1) {
     478:	be050054 	beqid	r5, 84		// 4cc
     47c:	3318ffff 	addik	r24, r24, -1
			XIntc_VectorTableEntry *TablePtr;

			/* If the interrupt has been setup to acknowledge it
			 * before servicing the interrupt, then ack it
			 */
			if (CfgPtr->AckBeforeService & IntrMask) {
     480:	e8b30008 	lwi	r5, r19, 8
     484:	84b72800 	and	r5, r23, r5
     488:	bc050008 	beqi	r5, 8		// 490
				XIntc_AckIntr(CfgPtr->BaseAddress, IntrMask);
     48c:	fae3000c 	swi	r23, r3, 12
			/* The interrupt is active and enabled, call the
			 * interrupt handler that was setup with the specified
			 * parameter
			 */
			TablePtr = &(CfgPtr->HandlerTable[IntrNumber]);
			TablePtr->Handler(TablePtr->CallBackRef);
     490:	c8649800 	lw	r3, r4, r19
     494:	99fc1800 	brald	r15, r3
     498:	e8a60004 	lwi	r5, r6, 4

			/* If the interrupt has been setup to acknowledge it
			 * after it has been serviced then ack it
			 */
			if ((CfgPtr->AckBeforeService & IntrMask) == 0) {
     49c:	e8730008 	lwi	r3, r19, 8
     4a0:	84771800 	and	r3, r23, r3
     4a4:	bc23000c 	bnei	r3, 12		// 4b0
				XIntc_AckIntr(CfgPtr->BaseAddress, IntrMask);
     4a8:	e8730004 	lwi	r3, r19, 4
     4ac:	fae3000c 	swi	r23, r3, 12

			/*
			 * Read the ISR again to handle architectures with posted write
			 * bus access issues.
			 */
			 XIntc_GetIntrStatus(CfgPtr->BaseAddress);
     4b0:	e8730004 	lwi	r3, r19, 4
			/*
			 * If only the highest priority interrupt is to be
			 * serviced, exit loop and return after servicing
			 * the interrupt
			 */
			if (CfgPtr->Options == XIN_SVC_SGL_ISR_OPTION) {
     4b4:	e8930014 	lwi	r4, r19, 20

			/*
			 * Read the ISR again to handle architectures with posted write
			 * bus access issues.
			 */
			 XIntc_GetIntrStatus(CfgPtr->BaseAddress);
     4b8:	e8a30000 	lwi	r5, r3, 0
     4bc:	e8a30008 	lwi	r5, r3, 8
			/*
			 * If only the highest priority interrupt is to be
			 * serviced, exit loop and return after servicing
			 * the interrupt
			 */
			if (CfgPtr->Options == XIN_SVC_SGL_ISR_OPTION) {
     4c0:	a8840001 	xori	r4, r4, 1
     4c4:	be04001c 	beqid	r4, 28		// 4e0
     4c8:	e9e10000 	lwi	r15, r1, 0
		IntrStatus >>= 1;

		/* If there are no other bits set indicating that all interrupts
		 * have been serviced, then exit the loop
		 */
		if (IntrStatus == 0) {
     4cc:	be160010 	beqid	r22, 16		// 4dc
     4d0:	12f7b800 	addk	r23, r23, r23
	}
	/* Service each interrupt that is active and enabled by checking each
	 * bit in the register from LSB to MSB which corresponds to an interrupt
	 * intput signal
	 */
	for (IntrNumber = 0; IntrNumber < XPAR_INTC_MAX_NUM_INTR_INPUTS;
     4d4:	be38ff90 	bneid	r24, -112		// 464
     4d8:	33390001 	addik	r25, r25, 1
		 */
		if (IntrStatus == 0) {
			break;
		}
	}
}
     4dc:	e9e10000 	lwi	r15, r1, 0
     4e0:	ea61001c 	lwi	r19, r1, 28
     4e4:	eac10020 	lwi	r22, r1, 32
     4e8:	eae10024 	lwi	r23, r1, 36
     4ec:	eb010028 	lwi	r24, r1, 40
     4f0:	eb21002c 	lwi	r25, r1, 44
     4f4:	b60f0008 	rtsd	r15, 8
     4f8:	30210030 	addik	r1, r1, 48
	/* Get the interrupts that are waiting to be serviced */
	IntrStatus = XIntc_GetIntrStatus(CfgPtr->BaseAddress);

	/* Mask the Fast Interrupts */
	if (CfgPtr->FastIntr == TRUE) {
		Imr = XIntc_In32(CfgPtr->BaseAddress + XIN_IMR_OFFSET);
     4fc:	e8830020 	lwi	r4, r3, 32
		IntrStatus &=  ~Imr;
     500:	a884ffff 	xori	r4, r4, -1
     504:	b810ff54 	brid	-172		// 458
     508:	86d62000 	and	r22, r22, r4

0000050c <XIntc_LowLevelInterruptHandler>:
* to be included in the driver compilation.
*
******************************************************************************/
#ifdef XPAR_INTC_SINGLE_DEVICE_ID
void XIntc_LowLevelInterruptHandler(void)
{
     50c:	3021ffe4 	addik	r1, r1, -28
     510:	f9e10000 	swi	r15, r1, 0
	 * A level of indirection here because the interrupt handler used with
	 * the driver interface given in this file needs to remain void - no
	 * arguments.  So we need the globally defined device ID of THE
	 * interrupt controller.
	 */
	XIntc_DeviceInterruptHandler((void *) XPAR_INTC_SINGLE_DEVICE_ID);
     514:	b9f4ff00 	brlid	r15, -256	// 414 <XIntc_DeviceInterruptHandler>
     518:	10a00000 	addk	r5, r0, r0
}
     51c:	e9e10000 	lwi	r15, r1, 0
     520:	b60f0008 	rtsd	r15, 8
     524:	3021001c 	addik	r1, r1, 28

00000528 <XIntc_SetIntrSvcOption>:
{
	XIntc_Config *CfgPtr = NULL;
	int Index;

	for (Index = 0; Index < XPAR_XINTC_NUM_INSTANCES; Index++) {
		if (XIntc_ConfigTable[Index].BaseAddress == BaseAddress) {
     528:	b0000000 	imm	0
     52c:	e860e3ac 	lwi	r3, r0, -7252
     530:	88a51800 	xor	r5, r5, r3
     534:	bc05000c 	beqi	r5, 12		// 540
     538:	b60f0008 	rtsd	r15, 8
     53c:	80000000 	or	r0, r0, r0
{
	XIntc_Config *CfgPtr;

	CfgPtr = LookupConfigByBaseAddress(BaseAddress);
	if (CfgPtr != NULL) {
		CfgPtr->Options = Option;
     540:	b0000000 	imm	0
     544:	3060e3ac 	addik	r3, r0, -7252
     548:	b60f0008 	rtsd	r15, 8
     54c:	f8c30010 	swi	r6, r3, 16

00000550 <XIntc_RegisterHandler>:
{
	XIntc_Config *CfgPtr = NULL;
	int Index;

	for (Index = 0; Index < XPAR_XINTC_NUM_INSTANCES; Index++) {
		if (XIntc_ConfigTable[Index].BaseAddress == BaseAddress) {
     550:	b0000000 	imm	0
     554:	e860e3ac 	lwi	r3, r0, -7252
     558:	88a51800 	xor	r5, r5, r3
     55c:	bc05000c 	beqi	r5, 12		// 568
     560:	b60f0008 	rtsd	r15, 8
     564:	80000000 	or	r0, r0, r0
{
	XIntc_Config *CfgPtr;

	CfgPtr = LookupConfigByBaseAddress(BaseAddress);
	if (CfgPtr != NULL) {
		CfgPtr->HandlerTable[InterruptId].Handler = Handler;
     568:	60660008 	muli	r3, r6, 8
     56c:	b0000000 	imm	0
     570:	f8e3e3c0 	swi	r7, r3, -7232
		CfgPtr->HandlerTable[InterruptId].CallBackRef = CallBackRef;
     574:	b0000000 	imm	0
     578:	f903e3c4 	swi	r8, r3, -7228
     57c:	b60f0008 	rtsd	r15, 8
     580:	80000000 	or	r0, r0, r0

00000584 <XIntc_RegisterFastHandler>:
	u32 Imr;

	CurrentIER = XIntc_In32(BaseAddress + XIN_IER_OFFSET);

	/* Convert from integer id to bit mask */
	Mask = XIntc_BitPosMask[Id];
     584:	60c60004 	muli	r6, r6, 4
     588:	b0000000 	imm	0
     58c:	3066ec40 	addik	r3, r6, -5056
{
	u32 CurrentIER;
	u32 Mask;
	u32 Imr;

	CurrentIER = XIntc_In32(BaseAddress + XIN_IER_OFFSET);
     590:	e8850008 	lwi	r4, r5, 8

	/* Convert from integer id to bit mask */
	Mask = XIntc_BitPosMask[Id];
     594:	e8630000 	lwi	r3, r3, 0

	if (CurrentIER & Mask) {
     598:	84832000 	and	r4, r3, r4
     59c:	be040048 	beqid	r4, 72		// 5e4
     5a0:	30850100 	addik	r4, r5, 256
		/* Disable Interrupt if it was enabled */
		CurrentIER = XIntc_In32(BaseAddress + XIN_IER_OFFSET);
     5a4:	e8850008 	lwi	r4, r5, 8
		XIntc_Out32(BaseAddress + XIN_IER_OFFSET,(CurrentIER & ~Mask));
     5a8:	a923ffff 	xori	r9, r3, -1
	}

	XIntc_Out32(BaseAddress + XIN_IVAR_OFFSET + (Id * 4),
     5ac:	31050100 	addik	r8, r5, 256
	Mask = XIntc_BitPosMask[Id];

	if (CurrentIER & Mask) {
		/* Disable Interrupt if it was enabled */
		CurrentIER = XIntc_In32(BaseAddress + XIN_IER_OFFSET);
		XIntc_Out32(BaseAddress + XIN_IER_OFFSET,(CurrentIER & ~Mask));
     5b0:	85292000 	and	r9, r9, r4
     5b4:	f9250008 	swi	r9, r5, 8
	}

	XIntc_Out32(BaseAddress + XIN_IVAR_OFFSET + (Id * 4),
     5b8:	d8e64000 	sw	r7, r6, r8
				    	(u32) FastHandler);

	Imr = XIntc_In32(BaseAddress + XIN_IMR_OFFSET);
     5bc:	e8c50020 	lwi	r6, r5, 32
	XIntc_Out32(BaseAddress + XIN_IMR_OFFSET, Imr | Mask);


	/* Enable Interrupt if it was enabled before calling this function */
	if (CurrentIER & Mask) {
     5c0:	84841800 	and	r4, r4, r3

	XIntc_Out32(BaseAddress + XIN_IVAR_OFFSET + (Id * 4),
				    	(u32) FastHandler);

	Imr = XIntc_In32(BaseAddress + XIN_IMR_OFFSET);
	XIntc_Out32(BaseAddress + XIN_IMR_OFFSET, Imr | Mask);
     5c4:	80c61800 	or	r6, r6, r3
     5c8:	f8c50020 	swi	r6, r5, 32


	/* Enable Interrupt if it was enabled before calling this function */
	if (CurrentIER & Mask) {
     5cc:	bc040028 	beqi	r4, 40		// 5f4
		CurrentIER = XIntc_In32(BaseAddress + XIN_IER_OFFSET);
     5d0:	e8850008 	lwi	r4, r5, 8
		XIntc_Out32(BaseAddress + XIN_IER_OFFSET,(CurrentIER | Mask));
     5d4:	80641800 	or	r3, r4, r3
     5d8:	f8650008 	swi	r3, r5, 8
     5dc:	b60f0008 	rtsd	r15, 8
     5e0:	80000000 	or	r0, r0, r0
		/* Disable Interrupt if it was enabled */
		CurrentIER = XIntc_In32(BaseAddress + XIN_IER_OFFSET);
		XIntc_Out32(BaseAddress + XIN_IER_OFFSET,(CurrentIER & ~Mask));
	}

	XIntc_Out32(BaseAddress + XIN_IVAR_OFFSET + (Id * 4),
     5e4:	d8e62000 	sw	r7, r6, r4
				    	(u32) FastHandler);

	Imr = XIntc_In32(BaseAddress + XIN_IMR_OFFSET);
     5e8:	e8850020 	lwi	r4, r5, 32
	XIntc_Out32(BaseAddress + XIN_IMR_OFFSET, Imr | Mask);
     5ec:	80641800 	or	r3, r4, r3
     5f0:	f8650020 	swi	r3, r5, 32
     5f4:	b60f0008 	rtsd	r15, 8
     5f8:	80000000 	or	r0, r0, r0

000005fc <StubHandler>:
*
* @note		None.
*
******************************************************************************/
static void StubHandler(void *CallBackRef)
{
     5fc:	3021ffe4 	addik	r1, r1, -28
	/*
	 * Verify that the inputs are valid
	 */
	Xil_AssertVoid(CallBackRef != NULL);
     600:	be050028 	beqid	r5, 40		// 628
     604:	f9e10000 	swi	r15, r1, 0

	/*
	 * Indicate another unhandled interrupt for stats
	 */
	((XIntc *) CallBackRef)->UnhandledInterrupts++;
     608:	e865000c 	lwi	r3, r5, 12
static void StubHandler(void *CallBackRef)
{
	/*
	 * Verify that the inputs are valid
	 */
	Xil_AssertVoid(CallBackRef != NULL);
     60c:	b0000000 	imm	0
     610:	f800ec58 	swi	r0, r0, -5032	// ec58 <Xil_AssertStatus>

	/*
	 * Indicate another unhandled interrupt for stats
	 */
	((XIntc *) CallBackRef)->UnhandledInterrupts++;
     614:	30630001 	addik	r3, r3, 1
     618:	f865000c 	swi	r3, r5, 12
}
     61c:	e9e10000 	lwi	r15, r1, 0
     620:	b60f0008 	rtsd	r15, 8
     624:	3021001c 	addik	r1, r1, 28
static void StubHandler(void *CallBackRef)
{
	/*
	 * Verify that the inputs are valid
	 */
	Xil_AssertVoid(CallBackRef != NULL);
     628:	b0000000 	imm	0
     62c:	30a0d5b8 	addik	r5, r0, -10824	// d5b8 <__rodata_start>
     630:	b0000000 	imm	0
     634:	b9f40c0c 	brlid	r15, 3084	// 1240 <Xil_Assert>
     638:	30c0023f 	addik	r6, r0, 575

	/*
	 * Indicate another unhandled interrupt for stats
	 */
	((XIntc *) CallBackRef)->UnhandledInterrupts++;
}
     63c:	e9e10000 	lwi	r15, r1, 0
static void StubHandler(void *CallBackRef)
{
	/*
	 * Verify that the inputs are valid
	 */
	Xil_AssertVoid(CallBackRef != NULL);
     640:	30600001 	addik	r3, r0, 1
     644:	b0000000 	imm	0
     648:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>

	/*
	 * Indicate another unhandled interrupt for stats
	 */
	((XIntc *) CallBackRef)->UnhandledInterrupts++;
}
     64c:	b60f0008 	rtsd	r15, 8
     650:	3021001c 	addik	r1, r1, 28

00000654 <XIntc_Initialize>:
*
* @note		None.
*
******************************************************************************/
int XIntc_Initialize(XIntc * InstancePtr, u16 DeviceId)
{
     654:	3021ffe0 	addik	r1, r1, -32
     658:	fa61001c 	swi	r19, r1, 28
     65c:	f9e10000 	swi	r15, r1, 0
	u8 Id;
	XIntc_Config *CfgPtr;
	u32 NextBitMask = 1;

	Xil_AssertNonvoid(InstancePtr != NULL);
     660:	be050054 	beqid	r5, 84		// 6b4
     664:	12650000 	addk	r19, r5, r0
	/*
	 * If the device is started, disallow the initialize and return a status
	 * indicating it is started.  This allows the user to stop the device
	 * and reinitialize, but prevents a user from inadvertently initializing
	 */
	if (InstancePtr->IsStarted == XIL_COMPONENT_IS_STARTED) {
     668:	e8850008 	lwi	r4, r5, 8
{
	u8 Id;
	XIntc_Config *CfgPtr;
	u32 NextBitMask = 1;

	Xil_AssertNonvoid(InstancePtr != NULL);
     66c:	b0000000 	imm	0
     670:	f800ec58 	swi	r0, r0, -5032	// ec58 <Xil_AssertStatus>
	/*
	 * If the device is started, disallow the initialize and return a status
	 * indicating it is started.  This allows the user to stop the device
	 * and reinitialize, but prevents a user from inadvertently initializing
	 */
	if (InstancePtr->IsStarted == XIL_COMPONENT_IS_STARTED) {
     674:	b0002222 	imm	8738
     678:	a8842222 	xori	r4, r4, 8738
     67c:	be040028 	beqid	r4, 40		// 6a4
     680:	30600005 	addik	r3, r0, 5
{
	XIntc_Config *CfgPtr = NULL;
	int Index;

	for (Index = 0; Index < XPAR_XINTC_NUM_INSTANCES; Index++) {
		if (XIntc_ConfigTable[Index].DeviceId == DeviceId) {
     684:	b0000000 	imm	0
     688:	e480e3a8 	lhui	r4, r0, -7256	// e3a8 <XIntc_ConfigTable>
     68c:	b0000000 	imm	0
     690:	30a0e3a8 	addik	r5, r0, -7256	// e3a8 <XIntc_ConfigTable>
     694:	88c43000 	xor	r6, r4, r6
     698:	be060044 	beqid	r6, 68		// 6dc
     69c:	30800001 	addik	r4, r0, 1
	 * Lookup the device configuration in the CROM table. Use this
	 * configuration info down below when initializing this component.
	 */
	CfgPtr = XIntc_LookupConfig(DeviceId);
	if (CfgPtr == NULL) {
		return XST_DEVICE_NOT_FOUND;
     6a0:	30600002 	addik	r3, r0, 2
	 * Indicate the instance is now ready to use, successfully initialized
	 */
	InstancePtr->IsReady = XIL_COMPONENT_IS_READY;

	return XST_SUCCESS;
}
     6a4:	e9e10000 	lwi	r15, r1, 0
     6a8:	ea61001c 	lwi	r19, r1, 28
     6ac:	b60f0008 	rtsd	r15, 8
     6b0:	30210020 	addik	r1, r1, 32
{
	u8 Id;
	XIntc_Config *CfgPtr;
	u32 NextBitMask = 1;

	Xil_AssertNonvoid(InstancePtr != NULL);
     6b4:	b0000000 	imm	0
     6b8:	30a0d5b8 	addik	r5, r0, -10824	// d5b8 <__rodata_start>
     6bc:	b0000000 	imm	0
     6c0:	b9f40b80 	brlid	r15, 2944	// 1240 <Xil_Assert>
     6c4:	30c0008b 	addik	r6, r0, 139
     6c8:	30600001 	addik	r3, r0, 1
     6cc:	b0000000 	imm	0
     6d0:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
     6d4:	b810ffd0 	brid	-48		// 6a4
     6d8:	10730000 	addk	r3, r19, r0
	}

	/*
	 * Set some default values
	 */
	InstancePtr->IsReady = 0;
     6dc:	f8d30004 	swi	r6, r19, 4
	InstancePtr->IsStarted = 0;	/* not started */
     6e0:	f8d30008 	swi	r6, r19, 8
	InstancePtr->CfgPtr = CfgPtr;
     6e4:	f8b30010 	swi	r5, r19, 16

	InstancePtr->CfgPtr->Options = XIN_SVC_SGL_ISR_OPTION;
     6e8:	f8850014 	swi	r4, r5, 20
	 * interrupt can be accessed
	 */
#if (XPAR_XINTC_USE_DCR_BRIDGE != 0)
	InstancePtr->BaseAddress = ((CfgPtr->BaseAddress >> 2)) & 0xFFF;
#else
	InstancePtr->BaseAddress = CfgPtr->BaseAddress;
     6ec:	b0000000 	imm	0
     6f0:	e8a0e3ac 	lwi	r5, r0, -7252
		 * initialize it if the handler is 0 or XNullHandler, which
		 * means it was not initialized statically by the tools/user.
		 * Set the callback reference to this instance so that unhandled
		 * interrupts can be tracked.
		 */
		if ((InstancePtr->CfgPtr->HandlerTable[Id].Handler == 0) ||
     6f4:	b0000000 	imm	0
     6f8:	31601238 	addik	r11, r0, 4664	// 1238 <XNullHandler>
	 * interrupt can be accessed
	 */
#if (XPAR_XINTC_USE_DCR_BRIDGE != 0)
	InstancePtr->BaseAddress = ((CfgPtr->BaseAddress >> 2)) & 0xFFF;
#else
	InstancePtr->BaseAddress = CfgPtr->BaseAddress;
     6fc:	f8b30000 	swi	r5, r19, 0
		 * initialize it if the handler is 0 or XNullHandler, which
		 * means it was not initialized statically by the tools/user.
		 * Set the callback reference to this instance so that unhandled
		 * interrupts can be tracked.
		 */
		if ((InstancePtr->CfgPtr->HandlerTable[Id].Handler == 0) ||
     700:	30e60003 	addik	r7, r6, 3
     704:	60a70008 	muli	r5, r7, 8
     708:	b0000000 	imm	0
     70c:	30a5e3a8 	addik	r5, r5, -7256
     710:	e8a50000 	lwi	r5, r5, 0

	/*
	 * Initialize all the data needed to perform interrupt processing for
	 * each interrupt ID up to the maximum used
	 */
	for (Id = 0; Id < XPAR_INTC_MAX_NUM_INTR_INPUTS; Id++) {
     714:	3063ffff 	addik	r3, r3, -1
		    (InstancePtr->CfgPtr->HandlerTable[Id].Handler ==
		     XNullHandler)) {
			InstancePtr->CfgPtr->HandlerTable[Id].Handler =
				StubHandler;
		}
		InstancePtr->CfgPtr->HandlerTable[Id].CallBackRef = InstancePtr;
     718:	61060008 	muli	r8, r6, 8
		 * Initialize the bit position mask table such that bit
		 * positions are lookups only for each interrupt id, with 0
		 * being a special case
		 * (XIntc_BitPosMask[] = { 1, 2, 4, 8, ... })
		 */
		XIntc_BitPosMask[Id] = NextBitMask;
     71c:	61260004 	muli	r9, r6, 4

	/*
	 * Initialize all the data needed to perform interrupt processing for
	 * each interrupt ID up to the maximum used
	 */
	for (Id = 0; Id < XPAR_INTC_MAX_NUM_INTR_INPUTS; Id++) {
     720:	a46300ff 	andi	r3, r3, 255
     724:	30c60001 	addik	r6, r6, 1
		 * initialize it if the handler is 0 or XNullHandler, which
		 * means it was not initialized statically by the tools/user.
		 * Set the callback reference to this instance so that unhandled
		 * interrupts can be tracked.
		 */
		if ((InstancePtr->CfgPtr->HandlerTable[Id].Handler == 0) ||
     728:	be050074 	beqid	r5, 116		// 79c
     72c:	89455800 	xor	r10, r5, r11
     730:	bc0a006c 	beqi	r10, 108		// 79c
		 * Initialize the bit position mask table such that bit
		 * positions are lookups only for each interrupt id, with 0
		 * being a special case
		 * (XIntc_BitPosMask[] = { 1, 2, 4, 8, ... })
		 */
		XIntc_BitPosMask[Id] = NextBitMask;
     734:	b0000000 	imm	0
     738:	f889ec40 	swi	r4, r9, -5056
		    (InstancePtr->CfgPtr->HandlerTable[Id].Handler ==
		     XNullHandler)) {
			InstancePtr->CfgPtr->HandlerTable[Id].Handler =
				StubHandler;
		}
		InstancePtr->CfgPtr->HandlerTable[Id].CallBackRef = InstancePtr;
     73c:	b0000000 	imm	0
     740:	fa68e3c4 	swi	r19, r8, -7228
		 * positions are lookups only for each interrupt id, with 0
		 * being a special case
		 * (XIntc_BitPosMask[] = { 1, 2, 4, 8, ... })
		 */
		XIntc_BitPosMask[Id] = NextBitMask;
		NextBitMask *= 2;
     744:	10842000 	addk	r4, r4, r4

	/*
	 * Initialize all the data needed to perform interrupt processing for
	 * each interrupt ID up to the maximum used
	 */
	for (Id = 0; Id < XPAR_INTC_MAX_NUM_INTR_INPUTS; Id++) {
     748:	be23ffb8 	bneid	r3, -72		// 700
     74c:	a4c600ff 	andi	r6, r6, 255
	/*
	 * Disable IRQ output signal
	 * Disable all interrupt sources
	 * Acknowledge all sources
	 */
	XIntc_Out32(InstancePtr->BaseAddress + XIN_MER_OFFSET, 0);
     750:	e8930000 	lwi	r4, r19, 0
	XIntc_Out32(InstancePtr->BaseAddress + XIN_IER_OFFSET, 0);
	XIntc_Out32(InstancePtr->BaseAddress + XIN_IAR_OFFSET, 0xFFFFFFFF);
     754:	30c0ffff 	addik	r6, r0, -1
	/*
	 * Disable IRQ output signal
	 * Disable all interrupt sources
	 * Acknowledge all sources
	 */
	XIntc_Out32(InstancePtr->BaseAddress + XIN_MER_OFFSET, 0);
     758:	f864001c 	swi	r3, r4, 28
	XIntc_Out32(InstancePtr->BaseAddress + XIN_IER_OFFSET, 0);
     75c:	e8b30000 	lwi	r5, r19, 0

	/*
	 * If the fast Interrupt mode is enabled then set all the
	 * interrupts as normal mode.
	 */
	if(InstancePtr->CfgPtr->FastIntr == TRUE) {
     760:	b0000000 	imm	0
     764:	e880e3b4 	lwi	r4, r0, -7244
	 * Disable IRQ output signal
	 * Disable all interrupt sources
	 * Acknowledge all sources
	 */
	XIntc_Out32(InstancePtr->BaseAddress + XIN_MER_OFFSET, 0);
	XIntc_Out32(InstancePtr->BaseAddress + XIN_IER_OFFSET, 0);
     768:	f8650008 	swi	r3, r5, 8
	XIntc_Out32(InstancePtr->BaseAddress + XIN_IAR_OFFSET, 0xFFFFFFFF);
     76c:	e8b30000 	lwi	r5, r19, 0

	/*
	 * If the fast Interrupt mode is enabled then set all the
	 * interrupts as normal mode.
	 */
	if(InstancePtr->CfgPtr->FastIntr == TRUE) {
     770:	a8840001 	xori	r4, r4, 1
	 * Disable all interrupt sources
	 * Acknowledge all sources
	 */
	XIntc_Out32(InstancePtr->BaseAddress + XIN_MER_OFFSET, 0);
	XIntc_Out32(InstancePtr->BaseAddress + XIN_IER_OFFSET, 0);
	XIntc_Out32(InstancePtr->BaseAddress + XIN_IAR_OFFSET, 0xFFFFFFFF);
     774:	f8c5000c 	swi	r6, r5, 12

	/*
	 * If the fast Interrupt mode is enabled then set all the
	 * interrupts as normal mode.
	 */
	if(InstancePtr->CfgPtr->FastIntr == TRUE) {
     778:	bc04003c 	beqi	r4, 60		// 7b4


	/*
	 * Indicate the instance is now ready to use, successfully initialized
	 */
	InstancePtr->IsReady = XIL_COMPONENT_IS_READY;
     77c:	b0001111 	imm	4369
     780:	30601111 	addik	r3, r0, 4369
     784:	f8730004 	swi	r3, r19, 4

	return XST_SUCCESS;
}
     788:	e9e10000 	lwi	r15, r1, 0
     78c:	ea61001c 	lwi	r19, r1, 28
	/*
	 * Indicate the instance is now ready to use, successfully initialized
	 */
	InstancePtr->IsReady = XIL_COMPONENT_IS_READY;

	return XST_SUCCESS;
     790:	10600000 	addk	r3, r0, r0
}
     794:	b60f0008 	rtsd	r15, 8
     798:	30210020 	addik	r1, r1, 32
		 * interrupts can be tracked.
		 */
		if ((InstancePtr->CfgPtr->HandlerTable[Id].Handler == 0) ||
		    (InstancePtr->CfgPtr->HandlerTable[Id].Handler ==
		     XNullHandler)) {
			InstancePtr->CfgPtr->HandlerTable[Id].Handler =
     79c:	b0000000 	imm	0
     7a0:	30a005fc 	addik	r5, r0, 1532	// 5fc <StubHandler>
     7a4:	60e70008 	muli	r7, r7, 8
     7a8:	b0000000 	imm	0
     7ac:	f8a7e3a8 	swi	r5, r7, -7256
     7b0:	b800ff84 	bri	-124		// 734
	/*
	 * If the fast Interrupt mode is enabled then set all the
	 * interrupts as normal mode.
	 */
	if(InstancePtr->CfgPtr->FastIntr == TRUE) {
		XIntc_Out32(InstancePtr->BaseAddress + XIN_IMR_OFFSET, 0);
     7b4:	e8930000 	lwi	r4, r19, 0
     7b8:	f8640020 	swi	r3, r4, 32
     7bc:	b800ffc0 	bri	-64		// 77c

000007c0 <XIntc_Start>:
*
* @note 	Must be called after XIntc initialization is completed.
*
******************************************************************************/
int XIntc_Start(XIntc * InstancePtr, u8 Mode)
{
     7c0:	3021ffe0 	addik	r1, r1, -32
     7c4:	f9e10000 	swi	r15, r1, 0
	u32 MasterEnable = XIN_INT_MASTER_ENABLE_MASK;

	/*
	 * Assert the arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
     7c8:	be0500c0 	beqid	r5, 192		// 888
     7cc:	fa61001c 	swi	r19, r1, 28
	Xil_AssertNonvoid((Mode == XIN_SIMULATION_MODE) ||
     7d0:	32600001 	addik	r19, r0, 1
	u32 MasterEnable = XIN_INT_MASTER_ENABLE_MASK;

	/*
	 * Assert the arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
     7d4:	b0000000 	imm	0
     7d8:	f800ec58 	swi	r0, r0, -5032	// ec58 <Xil_AssertStatus>
	Xil_AssertNonvoid((Mode == XIN_SIMULATION_MODE) ||
     7dc:	14669803 	cmpu	r3, r6, r19
     7e0:	bc430078 	blti	r3, 120		// 858
			(Mode == XIN_REAL_MODE))
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
     7e4:	e8650004 	lwi	r3, r5, 4
     7e8:	b0001111 	imm	4369
     7ec:	a8631111 	xori	r3, r3, 4369
     7f0:	bc230038 	bnei	r3, 56		// 828

	/*
	 * Check for simulation mode
	 */
	if (Mode == XIN_SIMULATION_MODE) {
     7f4:	be26000c 	bneid	r6, 12		// 800
     7f8:	30600003 	addik	r3, r0, 3
* @note 	Must be called after XIntc initialization is completed.
*
******************************************************************************/
int XIntc_Start(XIntc * InstancePtr, u8 Mode)
{
	u32 MasterEnable = XIN_INT_MASTER_ENABLE_MASK;
     7fc:	10730000 	addk	r3, r19, r0

	/*
	 * Indicate the instance is ready to be used and is started before we
	 * enable the device.
	 */
	InstancePtr->IsStarted = XIL_COMPONENT_IS_STARTED;
     800:	b0002222 	imm	8738
     804:	30c02222 	addik	r6, r0, 8738

	XIntc_Out32(InstancePtr->BaseAddress + XIN_MER_OFFSET, MasterEnable);
     808:	e8850000 	lwi	r4, r5, 0

	/*
	 * Indicate the instance is ready to be used and is started before we
	 * enable the device.
	 */
	InstancePtr->IsStarted = XIL_COMPONENT_IS_STARTED;
     80c:	f8c50008 	swi	r6, r5, 8

	XIntc_Out32(InstancePtr->BaseAddress + XIN_MER_OFFSET, MasterEnable);
     810:	f864001c 	swi	r3, r4, 28

	return XST_SUCCESS;
}
     814:	e9e10000 	lwi	r15, r1, 0
     818:	ea61001c 	lwi	r19, r1, 28
     81c:	10600000 	addk	r3, r0, r0
     820:	b60f0008 	rtsd	r15, 8
     824:	30210020 	addik	r1, r1, 32
	 * Assert the arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
	Xil_AssertNonvoid((Mode == XIN_SIMULATION_MODE) ||
			(Mode == XIN_REAL_MODE))
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
     828:	b0000000 	imm	0
     82c:	30a0d5b8 	addik	r5, r0, -10824	// d5b8 <__rodata_start>
     830:	b0000000 	imm	0
     834:	b9f40a0c 	brlid	r15, 2572	// 1240 <Xil_Assert>
     838:	30c00112 	addik	r6, r0, 274
     83c:	b0000000 	imm	0
     840:	fa60ec58 	swi	r19, r0, -5032	// ec58 <Xil_AssertStatus>
	InstancePtr->IsStarted = XIL_COMPONENT_IS_STARTED;

	XIntc_Out32(InstancePtr->BaseAddress + XIN_MER_OFFSET, MasterEnable);

	return XST_SUCCESS;
}
     844:	e9e10000 	lwi	r15, r1, 0
     848:	ea61001c 	lwi	r19, r1, 28
     84c:	10600000 	addk	r3, r0, r0
     850:	b60f0008 	rtsd	r15, 8
     854:	30210020 	addik	r1, r1, 32

	/*
	 * Assert the arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
	Xil_AssertNonvoid((Mode == XIN_SIMULATION_MODE) ||
     858:	b0000000 	imm	0
     85c:	30a0d5b8 	addik	r5, r0, -10824	// d5b8 <__rodata_start>
     860:	b0000000 	imm	0
     864:	b9f409dc 	brlid	r15, 2524	// 1240 <Xil_Assert>
     868:	30c00111 	addik	r6, r0, 273
	InstancePtr->IsStarted = XIL_COMPONENT_IS_STARTED;

	XIntc_Out32(InstancePtr->BaseAddress + XIN_MER_OFFSET, MasterEnable);

	return XST_SUCCESS;
}
     86c:	e9e10000 	lwi	r15, r1, 0

	/*
	 * Assert the arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
	Xil_AssertNonvoid((Mode == XIN_SIMULATION_MODE) ||
     870:	b0000000 	imm	0
     874:	fa60ec58 	swi	r19, r0, -5032	// ec58 <Xil_AssertStatus>
	InstancePtr->IsStarted = XIL_COMPONENT_IS_STARTED;

	XIntc_Out32(InstancePtr->BaseAddress + XIN_MER_OFFSET, MasterEnable);

	return XST_SUCCESS;
}
     878:	ea61001c 	lwi	r19, r1, 28
     87c:	10600000 	addk	r3, r0, r0
     880:	b60f0008 	rtsd	r15, 8
     884:	30210020 	addik	r1, r1, 32
	u32 MasterEnable = XIN_INT_MASTER_ENABLE_MASK;

	/*
	 * Assert the arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
     888:	b0000000 	imm	0
     88c:	30a0d5b8 	addik	r5, r0, -10824	// d5b8 <__rodata_start>
     890:	b0000000 	imm	0
     894:	b9f409ac 	brlid	r15, 2476	// 1240 <Xil_Assert>
     898:	30c0010f 	addik	r6, r0, 271
     89c:	30600001 	addik	r3, r0, 1
     8a0:	b0000000 	imm	0
     8a4:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
     8a8:	b810ffa0 	brid	-96		// 848
     8ac:	e9e10000 	lwi	r15, r1, 0

000008b0 <XIntc_Stop>:
*
* @note		None.
*
******************************************************************************/
void XIntc_Stop(XIntc * InstancePtr)
{
     8b0:	3021ffe4 	addik	r1, r1, -28
	/*
	 * Assert the arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
     8b4:	be050064 	beqid	r5, 100		// 918
     8b8:	f9e10000 	swi	r15, r1, 0
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
     8bc:	e8650004 	lwi	r3, r5, 4
void XIntc_Stop(XIntc * InstancePtr)
{
	/*
	 * Assert the arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
     8c0:	b0000000 	imm	0
     8c4:	f800ec58 	swi	r0, r0, -5032	// ec58 <Xil_AssertStatus>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
     8c8:	b0001111 	imm	4369
     8cc:	a8631111 	xori	r3, r3, 4369
     8d0:	bc030030 	beqi	r3, 48		// 900
     8d4:	b0000000 	imm	0
     8d8:	30a0d5b8 	addik	r5, r0, -10824	// d5b8 <__rodata_start>
     8dc:	b0000000 	imm	0
     8e0:	b9f40960 	brlid	r15, 2400	// 1240 <Xil_Assert>
     8e4:	30c0013e 	addik	r6, r0, 318
     8e8:	30600001 	addik	r3, r0, 1
     8ec:	b0000000 	imm	0
     8f0:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
	 * disabling all interrupts in the MER register
	 */
	XIntc_Out32(InstancePtr->BaseAddress + XIN_MER_OFFSET, 0);

	InstancePtr->IsStarted = 0;
}
     8f4:	e9e10000 	lwi	r15, r1, 0
     8f8:	b60f0008 	rtsd	r15, 8
     8fc:	3021001c 	addik	r1, r1, 28

	/*
	 * Stop all interrupts from occurring thru the interrupt controller by
	 * disabling all interrupts in the MER register
	 */
	XIntc_Out32(InstancePtr->BaseAddress + XIN_MER_OFFSET, 0);
     900:	e8850000 	lwi	r4, r5, 0
     904:	f864001c 	swi	r3, r4, 28

	InstancePtr->IsStarted = 0;
     908:	f8650008 	swi	r3, r5, 8
}
     90c:	e9e10000 	lwi	r15, r1, 0
     910:	b60f0008 	rtsd	r15, 8
     914:	3021001c 	addik	r1, r1, 28
void XIntc_Stop(XIntc * InstancePtr)
{
	/*
	 * Assert the arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
     918:	b0000000 	imm	0
     91c:	30a0d5b8 	addik	r5, r0, -10824	// d5b8 <__rodata_start>
     920:	b0000000 	imm	0
     924:	b9f4091c 	brlid	r15, 2332	// 1240 <Xil_Assert>
     928:	30c0013d 	addik	r6, r0, 317
     92c:	30600001 	addik	r3, r0, 1
     930:	b0000000 	imm	0
     934:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
     938:	b810ffc0 	brid	-64		// 8f8
     93c:	e9e10000 	lwi	r15, r1, 0

00000940 <XIntc_Connect>:
* that was previously connected.
*
****************************************************************************/
int XIntc_Connect(XIntc * InstancePtr, u8 Id,
		  XInterruptHandler Handler, void *CallBackRef)
{
     940:	3021ffe4 	addik	r1, r1, -28
	/*
	 * Assert the arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
     944:	be0500bc 	beqid	r5, 188		// a00
     948:	f9e10000 	swi	r15, r1, 0
	Xil_AssertNonvoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
     94c:	30600004 	addik	r3, r0, 4
		  XInterruptHandler Handler, void *CallBackRef)
{
	/*
	 * Assert the arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
     950:	b0000000 	imm	0
     954:	f800ec58 	swi	r0, r0, -5032	// ec58 <Xil_AssertStatus>
	Xil_AssertNonvoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
     958:	14661803 	cmpu	r3, r6, r3
     95c:	bc430074 	blti	r3, 116		// 9d0
	Xil_AssertNonvoid(Handler != NULL);
     960:	bc0700c8 	beqi	r7, 200		// a28
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
     964:	e8650004 	lwi	r3, r5, 4
     968:	b0001111 	imm	4369
     96c:	a8631111 	xori	r3, r3, 4369
     970:	be030038 	beqid	r3, 56		// 9a8
     974:	30860003 	addik	r4, r6, 3
     978:	b0000000 	imm	0
     97c:	30a0d5b8 	addik	r5, r0, -10824	// d5b8 <__rodata_start>
     980:	b0000000 	imm	0
     984:	b9f408bc 	brlid	r15, 2236	// 1240 <Xil_Assert>
     988:	30c0016c 	addik	r6, r0, 364
     98c:	30600001 	addik	r3, r0, 1
     990:	b0000000 	imm	0
     994:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
	 */
	InstancePtr->CfgPtr->HandlerTable[Id].Handler = Handler;
	InstancePtr->CfgPtr->HandlerTable[Id].CallBackRef = CallBackRef;

	return XST_SUCCESS;
}
     998:	e9e10000 	lwi	r15, r1, 0
     99c:	10600000 	addk	r3, r0, r0
     9a0:	b60f0008 	rtsd	r15, 8
     9a4:	3021001c 	addik	r1, r1, 28

	/*
	 * The Id is used as an index into the table to select the proper
	 * handler
	 */
	InstancePtr->CfgPtr->HandlerTable[Id].Handler = Handler;
     9a8:	e8650010 	lwi	r3, r5, 16
	InstancePtr->CfgPtr->HandlerTable[Id].CallBackRef = CallBackRef;
     9ac:	60c60008 	muli	r6, r6, 8
     9b0:	10c33000 	addk	r6, r3, r6

	/*
	 * The Id is used as an index into the table to select the proper
	 * handler
	 */
	InstancePtr->CfgPtr->HandlerTable[Id].Handler = Handler;
     9b4:	60840008 	muli	r4, r4, 8
     9b8:	d8e41800 	sw	r7, r4, r3
	InstancePtr->CfgPtr->HandlerTable[Id].CallBackRef = CallBackRef;
     9bc:	f906001c 	swi	r8, r6, 28

	return XST_SUCCESS;
}
     9c0:	e9e10000 	lwi	r15, r1, 0
     9c4:	10600000 	addk	r3, r0, r0
     9c8:	b60f0008 	rtsd	r15, 8
     9cc:	3021001c 	addik	r1, r1, 28
{
	/*
	 * Assert the arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
	Xil_AssertNonvoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
     9d0:	b0000000 	imm	0
     9d4:	30a0d5b8 	addik	r5, r0, -10824	// d5b8 <__rodata_start>
     9d8:	b0000000 	imm	0
     9dc:	b9f40864 	brlid	r15, 2148	// 1240 <Xil_Assert>
     9e0:	30c0016a 	addik	r6, r0, 362
	 */
	InstancePtr->CfgPtr->HandlerTable[Id].Handler = Handler;
	InstancePtr->CfgPtr->HandlerTable[Id].CallBackRef = CallBackRef;

	return XST_SUCCESS;
}
     9e4:	e9e10000 	lwi	r15, r1, 0
{
	/*
	 * Assert the arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
	Xil_AssertNonvoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
     9e8:	30600001 	addik	r3, r0, 1
     9ec:	b0000000 	imm	0
     9f0:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
	 */
	InstancePtr->CfgPtr->HandlerTable[Id].Handler = Handler;
	InstancePtr->CfgPtr->HandlerTable[Id].CallBackRef = CallBackRef;

	return XST_SUCCESS;
}
     9f4:	10600000 	addk	r3, r0, r0
     9f8:	b60f0008 	rtsd	r15, 8
     9fc:	3021001c 	addik	r1, r1, 28
		  XInterruptHandler Handler, void *CallBackRef)
{
	/*
	 * Assert the arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
     a00:	b0000000 	imm	0
     a04:	30a0d5b8 	addik	r5, r0, -10824	// d5b8 <__rodata_start>
     a08:	b0000000 	imm	0
     a0c:	b9f40834 	brlid	r15, 2100	// 1240 <Xil_Assert>
     a10:	30c00169 	addik	r6, r0, 361
     a14:	30600001 	addik	r3, r0, 1
     a18:	b0000000 	imm	0
     a1c:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
     a20:	b810ff7c 	brid	-132		// 99c
     a24:	e9e10000 	lwi	r15, r1, 0
	Xil_AssertNonvoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
	Xil_AssertNonvoid(Handler != NULL);
     a28:	b0000000 	imm	0
     a2c:	30a0d5b8 	addik	r5, r0, -10824	// d5b8 <__rodata_start>
     a30:	b0000000 	imm	0
     a34:	b9f4080c 	brlid	r15, 2060	// 1240 <Xil_Assert>
     a38:	30c0016b 	addik	r6, r0, 363
     a3c:	30600001 	addik	r3, r0, 1
     a40:	b0000000 	imm	0
     a44:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
     a48:	b810ff54 	brid	-172		// 99c
     a4c:	e9e10000 	lwi	r15, r1, 0

00000a50 <XIntc_Disconnect>:
*
* @note		None.
*
****************************************************************************/
void XIntc_Disconnect(XIntc * InstancePtr, u8 Id)
{
     a50:	3021ffe4 	addik	r1, r1, -28
	u32 Mask;

	/*
	 * Assert the arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
     a54:	be0500d8 	beqid	r5, 216		// b2c
     a58:	f9e10000 	swi	r15, r1, 0
	Xil_AssertVoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
     a5c:	30600004 	addik	r3, r0, 4
	u32 Mask;

	/*
	 * Assert the arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
     a60:	b0000000 	imm	0
     a64:	f800ec58 	swi	r0, r0, -5032	// ec58 <Xil_AssertStatus>
	Xil_AssertVoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
     a68:	14661803 	cmpu	r3, r6, r3
     a6c:	bc430094 	blti	r3, 148		// b00
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
     a70:	e8650004 	lwi	r3, r5, 4
     a74:	b0001111 	imm	4369
     a78:	a8631111 	xori	r3, r3, 4369
     a7c:	be030034 	beqid	r3, 52		// ab0
     a80:	60660004 	muli	r3, r6, 4
     a84:	b0000000 	imm	0
     a88:	30a0d5b8 	addik	r5, r0, -10824	// d5b8 <__rodata_start>
     a8c:	b0000000 	imm	0
     a90:	b9f407b0 	brlid	r15, 1968	// 1240 <Xil_Assert>
     a94:	30c00193 	addik	r6, r0, 403
     a98:	30600001 	addik	r3, r0, 1
     a9c:	b0000000 	imm	0
     aa0:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
	 * must be set to this instance to allow unhandled interrupts to be
	 * tracked
	 */
	InstancePtr->CfgPtr->HandlerTable[Id].Handler = StubHandler;
	InstancePtr->CfgPtr->HandlerTable[Id].CallBackRef = InstancePtr;
}
     aa4:	e9e10000 	lwi	r15, r1, 0
     aa8:	b60f0008 	rtsd	r15, 8
     aac:	3021001c 	addik	r1, r1, 28
	/*
	 * Disable the interrupt such that it won't occur while disconnecting
	 * the handler, only disable the specified interrupt id without
	 * modifying the other interrupt ids
	 */
	CurrentIER = XIntc_In32(InstancePtr->BaseAddress + XIN_IER_OFFSET);
     ab0:	e8e50000 	lwi	r7, r5, 0

	Mask = XIntc_BitPosMask[Id];/* convert from integer id to bit mask */
     ab4:	b0000000 	imm	0
     ab8:	3063ec40 	addik	r3, r3, -5056

	XIntc_Out32(InstancePtr->BaseAddress + XIN_IER_OFFSET,
     abc:	e9030000 	lwi	r8, r3, 0
	/*
	 * Disable the interrupt such that it won't occur while disconnecting
	 * the handler, only disable the specified interrupt id without
	 * modifying the other interrupt ids
	 */
	CurrentIER = XIntc_In32(InstancePtr->BaseAddress + XIN_IER_OFFSET);
     ac0:	e8670008 	lwi	r3, r7, 8
	/*
	 * Disconnect the handler and connect a stub, the callback reference
	 * must be set to this instance to allow unhandled interrupts to be
	 * tracked
	 */
	InstancePtr->CfgPtr->HandlerTable[Id].Handler = StubHandler;
     ac4:	e8850010 	lwi	r4, r5, 16
	 */
	CurrentIER = XIntc_In32(InstancePtr->BaseAddress + XIN_IER_OFFSET);

	Mask = XIntc_BitPosMask[Id];/* convert from integer id to bit mask */

	XIntc_Out32(InstancePtr->BaseAddress + XIN_IER_OFFSET,
     ac8:	a908ffff 	xori	r8, r8, -1
     acc:	85081800 	and	r8, r8, r3
     ad0:	f9070008 	swi	r8, r7, 8
	/*
	 * Disconnect the handler and connect a stub, the callback reference
	 * must be set to this instance to allow unhandled interrupts to be
	 * tracked
	 */
	InstancePtr->CfgPtr->HandlerTable[Id].Handler = StubHandler;
     ad4:	b0000000 	imm	0
     ad8:	30e005fc 	addik	r7, r0, 1532	// 5fc <StubHandler>
     adc:	30660003 	addik	r3, r6, 3
	InstancePtr->CfgPtr->HandlerTable[Id].CallBackRef = InstancePtr;
     ae0:	60c60008 	muli	r6, r6, 8
	/*
	 * Disconnect the handler and connect a stub, the callback reference
	 * must be set to this instance to allow unhandled interrupts to be
	 * tracked
	 */
	InstancePtr->CfgPtr->HandlerTable[Id].Handler = StubHandler;
     ae4:	60630008 	muli	r3, r3, 8
	InstancePtr->CfgPtr->HandlerTable[Id].CallBackRef = InstancePtr;
     ae8:	10c43000 	addk	r6, r4, r6
	/*
	 * Disconnect the handler and connect a stub, the callback reference
	 * must be set to this instance to allow unhandled interrupts to be
	 * tracked
	 */
	InstancePtr->CfgPtr->HandlerTable[Id].Handler = StubHandler;
     aec:	d8e32000 	sw	r7, r3, r4
	InstancePtr->CfgPtr->HandlerTable[Id].CallBackRef = InstancePtr;
     af0:	f8a6001c 	swi	r5, r6, 28
}
     af4:	e9e10000 	lwi	r15, r1, 0
     af8:	b60f0008 	rtsd	r15, 8
     afc:	3021001c 	addik	r1, r1, 28

	/*
	 * Assert the arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
	Xil_AssertVoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
     b00:	b0000000 	imm	0
     b04:	30a0d5b8 	addik	r5, r0, -10824	// d5b8 <__rodata_start>
     b08:	b0000000 	imm	0
     b0c:	b9f40734 	brlid	r15, 1844	// 1240 <Xil_Assert>
     b10:	30c00192 	addik	r6, r0, 402
	 * must be set to this instance to allow unhandled interrupts to be
	 * tracked
	 */
	InstancePtr->CfgPtr->HandlerTable[Id].Handler = StubHandler;
	InstancePtr->CfgPtr->HandlerTable[Id].CallBackRef = InstancePtr;
}
     b14:	e9e10000 	lwi	r15, r1, 0

	/*
	 * Assert the arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
	Xil_AssertVoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
     b18:	30e00001 	addik	r7, r0, 1
     b1c:	b0000000 	imm	0
     b20:	f8e0ec58 	swi	r7, r0, -5032	// ec58 <Xil_AssertStatus>
	 * must be set to this instance to allow unhandled interrupts to be
	 * tracked
	 */
	InstancePtr->CfgPtr->HandlerTable[Id].Handler = StubHandler;
	InstancePtr->CfgPtr->HandlerTable[Id].CallBackRef = InstancePtr;
}
     b24:	b60f0008 	rtsd	r15, 8
     b28:	3021001c 	addik	r1, r1, 28
	u32 Mask;

	/*
	 * Assert the arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
     b2c:	b0000000 	imm	0
     b30:	30a0d5b8 	addik	r5, r0, -10824	// d5b8 <__rodata_start>
     b34:	b0000000 	imm	0
     b38:	b9f40708 	brlid	r15, 1800	// 1240 <Xil_Assert>
     b3c:	30c00191 	addik	r6, r0, 401
     b40:	30600001 	addik	r3, r0, 1
     b44:	b0000000 	imm	0
     b48:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
     b4c:	b810ff5c 	brid	-164		// aa8
     b50:	e9e10000 	lwi	r15, r1, 0

00000b54 <XIntc_Enable>:
*
* @note		None.
*
****************************************************************************/
void XIntc_Enable(XIntc * InstancePtr, u8 Id)
{
     b54:	3021ffe4 	addik	r1, r1, -28
	u32 Mask;

	/*
	 * Assert the arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
     b58:	be0500b0 	beqid	r5, 176		// c08
     b5c:	f9e10000 	swi	r15, r1, 0
	Xil_AssertVoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
     b60:	30600004 	addik	r3, r0, 4
	u32 Mask;

	/*
	 * Assert the arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
     b64:	b0000000 	imm	0
     b68:	f800ec58 	swi	r0, r0, -5032	// ec58 <Xil_AssertStatus>
	Xil_AssertVoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
     b6c:	14661803 	cmpu	r3, r6, r3
     b70:	bc43006c 	blti	r3, 108		// bdc
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
     b74:	e8650004 	lwi	r3, r5, 4
     b78:	b0001111 	imm	4369
     b7c:	a8631111 	xori	r3, r3, 4369
     b80:	be030034 	beqid	r3, 52		// bb4
     b84:	60c60004 	muli	r6, r6, 4
     b88:	b0000000 	imm	0
     b8c:	30a0d5b8 	addik	r5, r0, -10824	// d5b8 <__rodata_start>
     b90:	b0000000 	imm	0
     b94:	b9f406ac 	brlid	r15, 1708	// 1240 <Xil_Assert>
     b98:	30c001c5 	addik	r6, r0, 453
     b9c:	30600001 	addik	r3, r0, 1
     ba0:	b0000000 	imm	0
     ba4:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
	 * register and then modifying only the specified interrupt id enable
	 */
	CurrentIER = XIntc_In32(InstancePtr->BaseAddress + XIN_IER_OFFSET);
	XIntc_Out32(InstancePtr->BaseAddress + XIN_IER_OFFSET,
		    (CurrentIER | Mask));
}
     ba8:	e9e10000 	lwi	r15, r1, 0
     bac:	b60f0008 	rtsd	r15, 8
     bb0:	3021001c 	addik	r1, r1, 28

	/*
	 * Enable the selected interrupt source by reading the interrupt enable
	 * register and then modifying only the specified interrupt id enable
	 */
	CurrentIER = XIntc_In32(InstancePtr->BaseAddress + XIN_IER_OFFSET);
     bb4:	e8650000 	lwi	r3, r5, 0

	/*
	 * The Id is used to create the appropriate mask for the
	 * desired bit position. Id currently limited to 0 - 31
	 */
	Mask = XIntc_BitPosMask[Id];
     bb8:	b0000000 	imm	0
     bbc:	30c6ec40 	addik	r6, r6, -5056

	/*
	 * Enable the selected interrupt source by reading the interrupt enable
	 * register and then modifying only the specified interrupt id enable
	 */
	CurrentIER = XIntc_In32(InstancePtr->BaseAddress + XIN_IER_OFFSET);
     bc0:	e8a30008 	lwi	r5, r3, 8
	XIntc_Out32(InstancePtr->BaseAddress + XIN_IER_OFFSET,
     bc4:	e8860000 	lwi	r4, r6, 0
     bc8:	80852000 	or	r4, r5, r4
     bcc:	f8830008 	swi	r4, r3, 8
		    (CurrentIER | Mask));
}
     bd0:	e9e10000 	lwi	r15, r1, 0
     bd4:	b60f0008 	rtsd	r15, 8
     bd8:	3021001c 	addik	r1, r1, 28

	/*
	 * Assert the arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
	Xil_AssertVoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
     bdc:	b0000000 	imm	0
     be0:	30a0d5b8 	addik	r5, r0, -10824	// d5b8 <__rodata_start>
     be4:	b0000000 	imm	0
     be8:	b9f40658 	brlid	r15, 1624	// 1240 <Xil_Assert>
     bec:	30c001c4 	addik	r6, r0, 452
	 * register and then modifying only the specified interrupt id enable
	 */
	CurrentIER = XIntc_In32(InstancePtr->BaseAddress + XIN_IER_OFFSET);
	XIntc_Out32(InstancePtr->BaseAddress + XIN_IER_OFFSET,
		    (CurrentIER | Mask));
}
     bf0:	e9e10000 	lwi	r15, r1, 0

	/*
	 * Assert the arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
	Xil_AssertVoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
     bf4:	30600001 	addik	r3, r0, 1
     bf8:	b0000000 	imm	0
     bfc:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
	 * register and then modifying only the specified interrupt id enable
	 */
	CurrentIER = XIntc_In32(InstancePtr->BaseAddress + XIN_IER_OFFSET);
	XIntc_Out32(InstancePtr->BaseAddress + XIN_IER_OFFSET,
		    (CurrentIER | Mask));
}
     c00:	b60f0008 	rtsd	r15, 8
     c04:	3021001c 	addik	r1, r1, 28
	u32 Mask;

	/*
	 * Assert the arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
     c08:	b0000000 	imm	0
     c0c:	30a0d5b8 	addik	r5, r0, -10824	// d5b8 <__rodata_start>
     c10:	b0000000 	imm	0
     c14:	b9f4062c 	brlid	r15, 1580	// 1240 <Xil_Assert>
     c18:	30c001c3 	addik	r6, r0, 451
     c1c:	30600001 	addik	r3, r0, 1
     c20:	b0000000 	imm	0
     c24:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
	 * register and then modifying only the specified interrupt id enable
	 */
	CurrentIER = XIntc_In32(InstancePtr->BaseAddress + XIN_IER_OFFSET);
	XIntc_Out32(InstancePtr->BaseAddress + XIN_IER_OFFSET,
		    (CurrentIER | Mask));
}
     c28:	b810ff84 	brid	-124		// bac
     c2c:	e9e10000 	lwi	r15, r1, 0

00000c30 <XIntc_Disable>:
*
* @note		None.
*
****************************************************************************/
void XIntc_Disable(XIntc * InstancePtr, u8 Id)
{
     c30:	3021ffe4 	addik	r1, r1, -28
	u32 Mask;

	/*
	 * Assert the arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
     c34:	be0500b4 	beqid	r5, 180		// ce8
     c38:	f9e10000 	swi	r15, r1, 0
	Xil_AssertVoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
     c3c:	30600004 	addik	r3, r0, 4
	u32 Mask;

	/*
	 * Assert the arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
     c40:	b0000000 	imm	0
     c44:	f800ec58 	swi	r0, r0, -5032	// ec58 <Xil_AssertStatus>
	Xil_AssertVoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
     c48:	14661803 	cmpu	r3, r6, r3
     c4c:	bc430070 	blti	r3, 112		// cbc
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
     c50:	e8650004 	lwi	r3, r5, 4
     c54:	b0001111 	imm	4369
     c58:	a8631111 	xori	r3, r3, 4369
     c5c:	be030034 	beqid	r3, 52		// c90
     c60:	60c60004 	muli	r6, r6, 4
     c64:	b0000000 	imm	0
     c68:	30a0d5b8 	addik	r5, r0, -10824	// d5b8 <__rodata_start>
     c6c:	b0000000 	imm	0
     c70:	b9f405d0 	brlid	r15, 1488	// 1240 <Xil_Assert>
     c74:	30c001f2 	addik	r6, r0, 498
     c78:	30600001 	addik	r3, r0, 1
     c7c:	b0000000 	imm	0
     c80:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
	 * register and then modifying only the specified interrupt id
	 */
	CurrentIER = XIntc_In32(InstancePtr->BaseAddress + XIN_IER_OFFSET);
	XIntc_Out32(InstancePtr->BaseAddress + XIN_IER_OFFSET,
		    (CurrentIER & ~Mask));
}
     c84:	e9e10000 	lwi	r15, r1, 0
     c88:	b60f0008 	rtsd	r15, 8
     c8c:	3021001c 	addik	r1, r1, 28

	/*
	 * Disable the selected interrupt source by reading the interrupt enable
	 * register and then modifying only the specified interrupt id
	 */
	CurrentIER = XIntc_In32(InstancePtr->BaseAddress + XIN_IER_OFFSET);
     c90:	e8650000 	lwi	r3, r5, 0

	/*
	 * The Id is used to create the appropriate mask for the
	 * desired bit position. Id currently limited to 0 - 31
	 */
	Mask = XIntc_BitPosMask[Id];
     c94:	b0000000 	imm	0
     c98:	30c6ec40 	addik	r6, r6, -5056
	/*
	 * Disable the selected interrupt source by reading the interrupt enable
	 * register and then modifying only the specified interrupt id
	 */
	CurrentIER = XIntc_In32(InstancePtr->BaseAddress + XIN_IER_OFFSET);
	XIntc_Out32(InstancePtr->BaseAddress + XIN_IER_OFFSET,
     c9c:	e8860000 	lwi	r4, r6, 0

	/*
	 * Disable the selected interrupt source by reading the interrupt enable
	 * register and then modifying only the specified interrupt id
	 */
	CurrentIER = XIntc_In32(InstancePtr->BaseAddress + XIN_IER_OFFSET);
     ca0:	e8a30008 	lwi	r5, r3, 8
	XIntc_Out32(InstancePtr->BaseAddress + XIN_IER_OFFSET,
     ca4:	a884ffff 	xori	r4, r4, -1
     ca8:	84842800 	and	r4, r4, r5
     cac:	f8830008 	swi	r4, r3, 8
		    (CurrentIER & ~Mask));
}
     cb0:	e9e10000 	lwi	r15, r1, 0
     cb4:	b60f0008 	rtsd	r15, 8
     cb8:	3021001c 	addik	r1, r1, 28

	/*
	 * Assert the arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
	Xil_AssertVoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
     cbc:	b0000000 	imm	0
     cc0:	30a0d5b8 	addik	r5, r0, -10824	// d5b8 <__rodata_start>
     cc4:	b0000000 	imm	0
     cc8:	b9f40578 	brlid	r15, 1400	// 1240 <Xil_Assert>
     ccc:	30c001f1 	addik	r6, r0, 497
	 * register and then modifying only the specified interrupt id
	 */
	CurrentIER = XIntc_In32(InstancePtr->BaseAddress + XIN_IER_OFFSET);
	XIntc_Out32(InstancePtr->BaseAddress + XIN_IER_OFFSET,
		    (CurrentIER & ~Mask));
}
     cd0:	e9e10000 	lwi	r15, r1, 0

	/*
	 * Assert the arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
	Xil_AssertVoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
     cd4:	30600001 	addik	r3, r0, 1
     cd8:	b0000000 	imm	0
     cdc:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
	 * register and then modifying only the specified interrupt id
	 */
	CurrentIER = XIntc_In32(InstancePtr->BaseAddress + XIN_IER_OFFSET);
	XIntc_Out32(InstancePtr->BaseAddress + XIN_IER_OFFSET,
		    (CurrentIER & ~Mask));
}
     ce0:	b60f0008 	rtsd	r15, 8
     ce4:	3021001c 	addik	r1, r1, 28
	u32 Mask;

	/*
	 * Assert the arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
     ce8:	b0000000 	imm	0
     cec:	30a0d5b8 	addik	r5, r0, -10824	// d5b8 <__rodata_start>
     cf0:	b0000000 	imm	0
     cf4:	b9f4054c 	brlid	r15, 1356	// 1240 <Xil_Assert>
     cf8:	30c001f0 	addik	r6, r0, 496
     cfc:	30600001 	addik	r3, r0, 1
     d00:	b0000000 	imm	0
     d04:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
	 * register and then modifying only the specified interrupt id
	 */
	CurrentIER = XIntc_In32(InstancePtr->BaseAddress + XIN_IER_OFFSET);
	XIntc_Out32(InstancePtr->BaseAddress + XIN_IER_OFFSET,
		    (CurrentIER & ~Mask));
}
     d08:	b810ff80 	brid	-128		// c88
     d0c:	e9e10000 	lwi	r15, r1, 0

00000d10 <XIntc_Acknowledge>:
*
* @note		None.
*
****************************************************************************/
void XIntc_Acknowledge(XIntc * InstancePtr, u8 Id)
{
     d10:	3021ffe4 	addik	r1, r1, -28
	u32 Mask;

	/*
	 * Assert the arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
     d14:	be0500a8 	beqid	r5, 168		// dbc
     d18:	f9e10000 	swi	r15, r1, 0
	Xil_AssertVoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
     d1c:	30600004 	addik	r3, r0, 4
	u32 Mask;

	/*
	 * Assert the arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
     d20:	b0000000 	imm	0
     d24:	f800ec58 	swi	r0, r0, -5032	// ec58 <Xil_AssertStatus>
	Xil_AssertVoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
     d28:	14661803 	cmpu	r3, r6, r3
     d2c:	bc430064 	blti	r3, 100		// d90
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
     d30:	e8650004 	lwi	r3, r5, 4
     d34:	b0001111 	imm	4369
     d38:	a8631111 	xori	r3, r3, 4369
     d3c:	be030034 	beqid	r3, 52		// d70
     d40:	60c60004 	muli	r6, r6, 4
     d44:	b0000000 	imm	0
     d48:	30a0d5b8 	addik	r5, r0, -10824	// d5b8 <__rodata_start>
     d4c:	b0000000 	imm	0
     d50:	b9f404f0 	brlid	r15, 1264	// 1240 <Xil_Assert>
     d54:	30c0021d 	addik	r6, r0, 541
     d58:	30600001 	addik	r3, r0, 1
     d5c:	b0000000 	imm	0
     d60:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
	 * Acknowledge the selected interrupt source, no read of the acknowledge
	 * register is necessary since only the bits set in the mask will be
	 * affected by the write
	 */
	XIntc_Out32(InstancePtr->BaseAddress + XIN_IAR_OFFSET, Mask);
}
     d64:	e9e10000 	lwi	r15, r1, 0
     d68:	b60f0008 	rtsd	r15, 8
     d6c:	3021001c 	addik	r1, r1, 28

	/*
	 * The Id is used to create the appropriate mask for the
	 * desired bit position. Id currently limited to 0 - 31
	 */
	Mask = XIntc_BitPosMask[Id];
     d70:	b0000000 	imm	0
     d74:	30c6ec40 	addik	r6, r6, -5056
     d78:	e8860000 	lwi	r4, r6, 0
	/*
	 * Acknowledge the selected interrupt source, no read of the acknowledge
	 * register is necessary since only the bits set in the mask will be
	 * affected by the write
	 */
	XIntc_Out32(InstancePtr->BaseAddress + XIN_IAR_OFFSET, Mask);
     d7c:	e8650000 	lwi	r3, r5, 0
     d80:	f883000c 	swi	r4, r3, 12
}
     d84:	e9e10000 	lwi	r15, r1, 0
     d88:	b60f0008 	rtsd	r15, 8
     d8c:	3021001c 	addik	r1, r1, 28

	/*
	 * Assert the arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
	Xil_AssertVoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
     d90:	b0000000 	imm	0
     d94:	30a0d5b8 	addik	r5, r0, -10824	// d5b8 <__rodata_start>
     d98:	b0000000 	imm	0
     d9c:	b9f404a4 	brlid	r15, 1188	// 1240 <Xil_Assert>
     da0:	30c0021c 	addik	r6, r0, 540
	 * Acknowledge the selected interrupt source, no read of the acknowledge
	 * register is necessary since only the bits set in the mask will be
	 * affected by the write
	 */
	XIntc_Out32(InstancePtr->BaseAddress + XIN_IAR_OFFSET, Mask);
}
     da4:	e9e10000 	lwi	r15, r1, 0

	/*
	 * Assert the arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
	Xil_AssertVoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
     da8:	30600001 	addik	r3, r0, 1
     dac:	b0000000 	imm	0
     db0:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
	 * Acknowledge the selected interrupt source, no read of the acknowledge
	 * register is necessary since only the bits set in the mask will be
	 * affected by the write
	 */
	XIntc_Out32(InstancePtr->BaseAddress + XIN_IAR_OFFSET, Mask);
}
     db4:	b60f0008 	rtsd	r15, 8
     db8:	3021001c 	addik	r1, r1, 28
	u32 Mask;

	/*
	 * Assert the arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
     dbc:	b0000000 	imm	0
     dc0:	30a0d5b8 	addik	r5, r0, -10824	// d5b8 <__rodata_start>
     dc4:	b0000000 	imm	0
     dc8:	b9f40478 	brlid	r15, 1144	// 1240 <Xil_Assert>
     dcc:	30c0021b 	addik	r6, r0, 539
     dd0:	30600001 	addik	r3, r0, 1
     dd4:	b0000000 	imm	0
     dd8:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
     ddc:	b810ff8c 	brid	-116		// d68
     de0:	e9e10000 	lwi	r15, r1, 0

00000de4 <XIntc_LookupConfig>:
{
	XIntc_Config *CfgPtr = NULL;
	int Index;

	for (Index = 0; Index < XPAR_XINTC_NUM_INSTANCES; Index++) {
		if (XIntc_ConfigTable[Index].DeviceId == DeviceId) {
     de4:	b0000000 	imm	0
     de8:	e480e3a8 	lhui	r4, r0, -7256	// e3a8 <XIntc_ConfigTable>
     dec:	88a42800 	xor	r5, r4, r5
     df0:	be250010 	bneid	r5, 16		// e00
     df4:	10600000 	addk	r3, r0, r0
			CfgPtr = &XIntc_ConfigTable[Index];
     df8:	b0000000 	imm	0
     dfc:	3060e3a8 	addik	r3, r0, -7256	// e3a8 <XIntc_ConfigTable>
			break;
		}
	}

	return CfgPtr;
}
     e00:	b60f0008 	rtsd	r15, 8
     e04:	80000000 	or	r0, r0, r0

00000e08 <XIntc_ConnectFastHandler>:
* that was previously connected.
*
****************************************************************************/
int XIntc_ConnectFastHandler(XIntc *InstancePtr, u8 Id,
				XFastInterruptHandler Handler)
{
     e08:	3021ffd0 	addik	r1, r1, -48
     e0c:	fa610020 	swi	r19, r1, 32
     e10:	fac10024 	swi	r22, r1, 36
     e14:	f9e10000 	swi	r15, r1, 0
     e18:	fae10028 	swi	r23, r1, 40
     e1c:	fb01002c 	swi	r24, r1, 44
     e20:	12650000 	addk	r19, r5, r0
	u32 Mask;

	/*
	 * Assert the arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
     e24:	be050198 	beqid	r5, 408		// fbc
     e28:	12c60000 	addk	r22, r6, r0
	Xil_AssertNonvoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
     e2c:	30600004 	addik	r3, r0, 4
	u32 Mask;

	/*
	 * Assert the arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
     e30:	b0000000 	imm	0
     e34:	f800ec58 	swi	r0, r0, -5032	// ec58 <Xil_AssertStatus>
	Xil_AssertNonvoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
     e38:	14661803 	cmpu	r3, r6, r3
     e3c:	bc430100 	blti	r3, 256		// f3c
	Xil_AssertNonvoid(Handler != NULL);
     e40:	bc0701a4 	beqi	r7, 420		// fe4
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
     e44:	e8650004 	lwi	r3, r5, 4
     e48:	b0001111 	imm	4369
     e4c:	a8631111 	xori	r3, r3, 4369
     e50:	bc23006c 	bnei	r3, 108		// ebc
	Xil_AssertNonvoid(InstancePtr->CfgPtr->FastIntr == TRUE);
     e54:	e8650010 	lwi	r3, r5, 16
     e58:	e863000c 	lwi	r3, r3, 12
     e5c:	a8630001 	xori	r3, r3, 1
     e60:	be23011c 	bneid	r3, 284		// f7c
     e64:	63060004 	muli	r24, r6, 4


	/* Get the Enabled Interrupts */
	CurrentIER = XIntc_In32(InstancePtr->BaseAddress + XIN_IER_OFFSET);
     e68:	e8650000 	lwi	r3, r5, 0
	Mask = XIntc_BitPosMask[Id];/* Convert from integer id to bit mask */
     e6c:	b0000000 	imm	0
     e70:	3118ec40 	addik	r8, r24, -5056
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
	Xil_AssertNonvoid(InstancePtr->CfgPtr->FastIntr == TRUE);


	/* Get the Enabled Interrupts */
	CurrentIER = XIntc_In32(InstancePtr->BaseAddress + XIN_IER_OFFSET);
     e74:	e8830008 	lwi	r4, r3, 8
	Mask = XIntc_BitPosMask[Id];/* Convert from integer id to bit mask */
     e78:	eae80000 	lwi	r23, r8, 0


	/* Disable the Interrupt if it was enabled before calling this function */
	if (CurrentIER & Mask) {
     e7c:	84972000 	and	r4, r23, r4
     e80:	be24007c 	bneid	r4, 124		// efc
     e84:	30630100 	addik	r3, r3, 256
		XIntc_Disable(InstancePtr, Id);
	}

	XIntc_Out32(InstancePtr->BaseAddress + XIN_IVAR_OFFSET + (Id * 4),
     e88:	d8f81800 	sw	r7, r24, r3
		    	(u32) Handler);

	Imr = XIntc_In32(InstancePtr->BaseAddress + XIN_IMR_OFFSET);
     e8c:	e8650000 	lwi	r3, r5, 0
     e90:	e8830020 	lwi	r4, r3, 32
	XIntc_Out32(InstancePtr->BaseAddress + XIN_IMR_OFFSET,
     e94:	82f72000 	or	r23, r23, r4
     e98:	fae30020 	swi	r23, r3, 32
	if (CurrentIER & Mask) {
		XIntc_Enable(InstancePtr, Id);
	}
	return XST_SUCCESS;

}
     e9c:	e9e10000 	lwi	r15, r1, 0
     ea0:	ea610020 	lwi	r19, r1, 32
     ea4:	eac10024 	lwi	r22, r1, 36
     ea8:	eae10028 	lwi	r23, r1, 40
     eac:	eb01002c 	lwi	r24, r1, 44
     eb0:	10600000 	addk	r3, r0, r0
     eb4:	b60f0008 	rtsd	r15, 8
     eb8:	30210030 	addik	r1, r1, 48
	 * Assert the arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
	Xil_AssertNonvoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
	Xil_AssertNonvoid(Handler != NULL);
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
     ebc:	b0000000 	imm	0
     ec0:	30a0d5b8 	addik	r5, r0, -10824	// d5b8 <__rodata_start>
     ec4:	b0000000 	imm	0
     ec8:	b9f40378 	brlid	r15, 888	// 1240 <Xil_Assert>
     ecc:	30c00289 	addik	r6, r0, 649
     ed0:	30600001 	addik	r3, r0, 1
     ed4:	b0000000 	imm	0
     ed8:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
	if (CurrentIER & Mask) {
		XIntc_Enable(InstancePtr, Id);
	}
	return XST_SUCCESS;

}
     edc:	e9e10000 	lwi	r15, r1, 0
     ee0:	ea610020 	lwi	r19, r1, 32
     ee4:	eac10024 	lwi	r22, r1, 36
     ee8:	eae10028 	lwi	r23, r1, 40
     eec:	eb01002c 	lwi	r24, r1, 44
     ef0:	10600000 	addk	r3, r0, r0
     ef4:	b60f0008 	rtsd	r15, 8
     ef8:	30210030 	addik	r1, r1, 48
	Mask = XIntc_BitPosMask[Id];/* Convert from integer id to bit mask */


	/* Disable the Interrupt if it was enabled before calling this function */
	if (CurrentIER & Mask) {
		XIntc_Disable(InstancePtr, Id);
     efc:	b9f4fd34 	brlid	r15, -716	// c30 <XIntc_Disable>
     f00:	f8e1001c 	swi	r7, r1, 28
	}

	XIntc_Out32(InstancePtr->BaseAddress + XIN_IVAR_OFFSET + (Id * 4),
     f04:	e8730000 	lwi	r3, r19, 0
     f08:	e8e1001c 	lwi	r7, r1, 28
		    Imr | Mask);


	/* Enable the Interrupt if it was enabled before calling this function */
	if (CurrentIER & Mask) {
		XIntc_Enable(InstancePtr, Id);
     f0c:	10b30000 	addk	r5, r19, r0
	/* Disable the Interrupt if it was enabled before calling this function */
	if (CurrentIER & Mask) {
		XIntc_Disable(InstancePtr, Id);
	}

	XIntc_Out32(InstancePtr->BaseAddress + XIN_IVAR_OFFSET + (Id * 4),
     f10:	30630100 	addik	r3, r3, 256
     f14:	d8f81800 	sw	r7, r24, r3
		    	(u32) Handler);

	Imr = XIntc_In32(InstancePtr->BaseAddress + XIN_IMR_OFFSET);
     f18:	e8730000 	lwi	r3, r19, 0
		    Imr | Mask);


	/* Enable the Interrupt if it was enabled before calling this function */
	if (CurrentIER & Mask) {
		XIntc_Enable(InstancePtr, Id);
     f1c:	10d60000 	addk	r6, r22, r0
	}

	XIntc_Out32(InstancePtr->BaseAddress + XIN_IVAR_OFFSET + (Id * 4),
		    	(u32) Handler);

	Imr = XIntc_In32(InstancePtr->BaseAddress + XIN_IMR_OFFSET);
     f20:	e8830020 	lwi	r4, r3, 32
	XIntc_Out32(InstancePtr->BaseAddress + XIN_IMR_OFFSET,
     f24:	82f72000 	or	r23, r23, r4
     f28:	fae30020 	swi	r23, r3, 32
		    Imr | Mask);


	/* Enable the Interrupt if it was enabled before calling this function */
	if (CurrentIER & Mask) {
		XIntc_Enable(InstancePtr, Id);
     f2c:	b9f4fc28 	brlid	r15, -984	// b54 <XIntc_Enable>
     f30:	80000000 	or	r0, r0, r0
	}
	return XST_SUCCESS;

}
     f34:	b810ffac 	brid	-84		// ee0
     f38:	e9e10000 	lwi	r15, r1, 0

	/*
	 * Assert the arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
	Xil_AssertNonvoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
     f3c:	b0000000 	imm	0
     f40:	30a0d5b8 	addik	r5, r0, -10824	// d5b8 <__rodata_start>
     f44:	b0000000 	imm	0
     f48:	b9f402f8 	brlid	r15, 760	// 1240 <Xil_Assert>
     f4c:	30c00287 	addik	r6, r0, 647
	if (CurrentIER & Mask) {
		XIntc_Enable(InstancePtr, Id);
	}
	return XST_SUCCESS;

}
     f50:	e9e10000 	lwi	r15, r1, 0
     f54:	ea610020 	lwi	r19, r1, 32
     f58:	eac10024 	lwi	r22, r1, 36
     f5c:	eae10028 	lwi	r23, r1, 40
     f60:	eb01002c 	lwi	r24, r1, 44

	/*
	 * Assert the arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
	Xil_AssertNonvoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
     f64:	30600001 	addik	r3, r0, 1
     f68:	b0000000 	imm	0
     f6c:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
	if (CurrentIER & Mask) {
		XIntc_Enable(InstancePtr, Id);
	}
	return XST_SUCCESS;

}
     f70:	10600000 	addk	r3, r0, r0
     f74:	b60f0008 	rtsd	r15, 8
     f78:	30210030 	addik	r1, r1, 48
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
	Xil_AssertNonvoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
	Xil_AssertNonvoid(Handler != NULL);
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
	Xil_AssertNonvoid(InstancePtr->CfgPtr->FastIntr == TRUE);
     f7c:	b0000000 	imm	0
     f80:	30a0d5b8 	addik	r5, r0, -10824	// d5b8 <__rodata_start>
     f84:	b0000000 	imm	0
     f88:	b9f402b8 	brlid	r15, 696	// 1240 <Xil_Assert>
     f8c:	30c0028a 	addik	r6, r0, 650
	if (CurrentIER & Mask) {
		XIntc_Enable(InstancePtr, Id);
	}
	return XST_SUCCESS;

}
     f90:	e9e10000 	lwi	r15, r1, 0
     f94:	ea610020 	lwi	r19, r1, 32
     f98:	eac10024 	lwi	r22, r1, 36
     f9c:	eae10028 	lwi	r23, r1, 40
     fa0:	eb01002c 	lwi	r24, r1, 44
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
	Xil_AssertNonvoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
	Xil_AssertNonvoid(Handler != NULL);
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
	Xil_AssertNonvoid(InstancePtr->CfgPtr->FastIntr == TRUE);
     fa4:	30600001 	addik	r3, r0, 1
     fa8:	b0000000 	imm	0
     fac:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
	if (CurrentIER & Mask) {
		XIntc_Enable(InstancePtr, Id);
	}
	return XST_SUCCESS;

}
     fb0:	10600000 	addk	r3, r0, r0
     fb4:	b60f0008 	rtsd	r15, 8
     fb8:	30210030 	addik	r1, r1, 48
	u32 Mask;

	/*
	 * Assert the arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
     fbc:	b0000000 	imm	0
     fc0:	30a0d5b8 	addik	r5, r0, -10824	// d5b8 <__rodata_start>
     fc4:	b0000000 	imm	0
     fc8:	b9f40278 	brlid	r15, 632	// 1240 <Xil_Assert>
     fcc:	30c00286 	addik	r6, r0, 646
     fd0:	30600001 	addik	r3, r0, 1
     fd4:	b0000000 	imm	0
     fd8:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
     fdc:	b810ff04 	brid	-252		// ee0
     fe0:	e9e10000 	lwi	r15, r1, 0
	Xil_AssertNonvoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
	Xil_AssertNonvoid(Handler != NULL);
     fe4:	b0000000 	imm	0
     fe8:	30a0d5b8 	addik	r5, r0, -10824	// d5b8 <__rodata_start>
     fec:	b0000000 	imm	0
     ff0:	b9f40250 	brlid	r15, 592	// 1240 <Xil_Assert>
     ff4:	30c00288 	addik	r6, r0, 648
     ff8:	30600001 	addik	r3, r0, 1
     ffc:	b0000000 	imm	0
    1000:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
    1004:	b810fedc 	brid	-292		// ee0
    1008:	e9e10000 	lwi	r15, r1, 0

0000100c <XIntc_SetNormalIntrMode>:
*
* @note		None.
*
****************************************************************************/
void XIntc_SetNormalIntrMode(XIntc *InstancePtr, u8 Id)
{
    100c:	3021ffd0 	addik	r1, r1, -48
    1010:	fa61001c 	swi	r19, r1, 28
    1014:	fac10020 	swi	r22, r1, 32
    1018:	f9e10000 	swi	r15, r1, 0
    101c:	fae10024 	swi	r23, r1, 36
    1020:	fb010028 	swi	r24, r1, 40
    1024:	fb21002c 	swi	r25, r1, 44
    1028:	12650000 	addk	r19, r5, r0
	u32 Mask;

	/*
	 * Assert the arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
    102c:	be05019c 	beqid	r5, 412		// 11c8
    1030:	12c60000 	addk	r22, r6, r0
	Xil_AssertVoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
    1034:	30600004 	addik	r3, r0, 4
	u32 Mask;

	/*
	 * Assert the arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
    1038:	b0000000 	imm	0
    103c:	f800ec58 	swi	r0, r0, -5032	// ec58 <Xil_AssertStatus>
	Xil_AssertVoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
    1040:	14661803 	cmpu	r3, r6, r3
    1044:	bc430104 	blti	r3, 260		// 1148
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    1048:	e8650004 	lwi	r3, r5, 4
    104c:	b0001111 	imm	4369
    1050:	a8631111 	xori	r3, r3, 4369
    1054:	bc230090 	bnei	r3, 144		// 10e4
	Xil_AssertVoid(InstancePtr->CfgPtr->FastIntr == TRUE);
    1058:	e8650010 	lwi	r3, r5, 16
    105c:	e883000c 	lwi	r4, r3, 12
    1060:	a8840001 	xori	r4, r4, 1
    1064:	be240124 	bneid	r4, 292		// 1188
    1068:	62e60004 	muli	r23, r6, 4


	/* Get the Enabled Interrupts */
	CurrentIER = XIntc_In32(InstancePtr->BaseAddress + XIN_IER_OFFSET);
    106c:	e8850000 	lwi	r4, r5, 0
	Mask = XIntc_BitPosMask[Id];/* Convert from integer id to bit mask */
    1070:	b0000000 	imm	0
    1074:	30f7ec40 	addik	r7, r23, -5056
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
	Xil_AssertVoid(InstancePtr->CfgPtr->FastIntr == TRUE);


	/* Get the Enabled Interrupts */
	CurrentIER = XIntc_In32(InstancePtr->BaseAddress + XIN_IER_OFFSET);
    1078:	eb040008 	lwi	r24, r4, 8
	Mask = XIntc_BitPosMask[Id];/* Convert from integer id to bit mask */
    107c:	eb270000 	lwi	r25, r7, 0


	/* Disable the Interrupt if it was enabled before calling this function */
	if (CurrentIER & Mask) {
    1080:	8719c000 	and	r24, r25, r24
    1084:	bc3800b0 	bnei	r24, 176		// 1134
	/*
	 * Disable the selected interrupt as Fast Interrupt by reading the
	 * interrupt mode register and then modifying only the
	 * specified interrupt id
	 */
	Imr = XIntc_In32(InstancePtr->BaseAddress + XIN_IMR_OFFSET);
    1088:	e8a40020 	lwi	r5, r4, 32
	XIntc_Out32(InstancePtr->BaseAddress + XIN_IMR_OFFSET,
    108c:	ab39ffff 	xori	r25, r25, -1
    1090:	8725c800 	and	r25, r5, r25
    1094:	fb240020 	swi	r25, r4, 32
		    Imr & ~Mask);

	if (InstancePtr->CfgPtr->IntVectorAddr == 0x0) {
    1098:	e8630010 	lwi	r3, r3, 16
    109c:	be230088 	bneid	r3, 136		// 1124
    10a0:	30800010 	addik	r4, r0, 16	// 10 <_vector_interrupt>
		XIntc_Out32(InstancePtr->BaseAddress + XIN_IVAR_OFFSET + (Id * 4),
    10a4:	e8730000 	lwi	r3, r19, 0
    10a8:	30630100 	addik	r3, r3, 256
    10ac:	d8971800 	sw	r4, r23, r3
		XIntc_Out32(InstancePtr->BaseAddress + XIN_IVAR_OFFSET + (Id * 4),
		    	InstancePtr->CfgPtr->IntVectorAddr);
	}

	/* Enable the Interrupt if it was enabled before calling this function */
	if (CurrentIER & Mask) {
    10b0:	be180058 	beqid	r24, 88		// 1108
    10b4:	e9e10000 	lwi	r15, r1, 0
		XIntc_Enable(InstancePtr, Id);
    10b8:	10b30000 	addk	r5, r19, r0
    10bc:	b9f4fa98 	brlid	r15, -1384	// b54 <XIntc_Enable>
    10c0:	10d60000 	addk	r6, r22, r0
	}
}
    10c4:	e9e10000 	lwi	r15, r1, 0
    10c8:	ea61001c 	lwi	r19, r1, 28
    10cc:	eac10020 	lwi	r22, r1, 32
    10d0:	eae10024 	lwi	r23, r1, 36
    10d4:	eb010028 	lwi	r24, r1, 40
    10d8:	eb21002c 	lwi	r25, r1, 44
    10dc:	b60f0008 	rtsd	r15, 8
    10e0:	30210030 	addik	r1, r1, 48
	/*
	 * Assert the arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
	Xil_AssertVoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    10e4:	b0000000 	imm	0
    10e8:	30a0d5b8 	addik	r5, r0, -10824	// d5b8 <__rodata_start>
    10ec:	b0000000 	imm	0
    10f0:	b9f40150 	brlid	r15, 336	// 1240 <Xil_Assert>
    10f4:	30c002c5 	addik	r6, r0, 709
    10f8:	30600001 	addik	r3, r0, 1
    10fc:	b0000000 	imm	0
    1100:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>

	/* Enable the Interrupt if it was enabled before calling this function */
	if (CurrentIER & Mask) {
		XIntc_Enable(InstancePtr, Id);
	}
}
    1104:	e9e10000 	lwi	r15, r1, 0
    1108:	ea61001c 	lwi	r19, r1, 28
    110c:	eac10020 	lwi	r22, r1, 32
    1110:	eae10024 	lwi	r23, r1, 36
    1114:	eb010028 	lwi	r24, r1, 40
    1118:	eb21002c 	lwi	r25, r1, 44
    111c:	b60f0008 	rtsd	r15, 8
    1120:	30210030 	addik	r1, r1, 48
	if (InstancePtr->CfgPtr->IntVectorAddr == 0x0) {
		XIntc_Out32(InstancePtr->BaseAddress + XIN_IVAR_OFFSET + (Id * 4),
		    			0x10);
	} else {

		XIntc_Out32(InstancePtr->BaseAddress + XIN_IVAR_OFFSET + (Id * 4),
    1124:	e8930000 	lwi	r4, r19, 0
    1128:	30840100 	addik	r4, r4, 256
    112c:	d8772000 	sw	r3, r23, r4
    1130:	b800ff80 	bri	-128		// 10b0
	Mask = XIntc_BitPosMask[Id];/* Convert from integer id to bit mask */


	/* Disable the Interrupt if it was enabled before calling this function */
	if (CurrentIER & Mask) {
		XIntc_Disable(InstancePtr, Id);
    1134:	b9f4fafc 	brlid	r15, -1284	// c30 <XIntc_Disable>
    1138:	80000000 	or	r0, r0, r0
    113c:	e8930000 	lwi	r4, r19, 0
    1140:	b810ff48 	brid	-184		// 1088
    1144:	e8730010 	lwi	r3, r19, 16

	/*
	 * Assert the arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
	Xil_AssertVoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
    1148:	b0000000 	imm	0
    114c:	30a0d5b8 	addik	r5, r0, -10824	// d5b8 <__rodata_start>
    1150:	b0000000 	imm	0
    1154:	b9f400ec 	brlid	r15, 236	// 1240 <Xil_Assert>
    1158:	30c002c4 	addik	r6, r0, 708

	/* Enable the Interrupt if it was enabled before calling this function */
	if (CurrentIER & Mask) {
		XIntc_Enable(InstancePtr, Id);
	}
}
    115c:	e9e10000 	lwi	r15, r1, 0
    1160:	ea61001c 	lwi	r19, r1, 28
    1164:	eac10020 	lwi	r22, r1, 32
    1168:	eae10024 	lwi	r23, r1, 36
    116c:	eb010028 	lwi	r24, r1, 40
    1170:	eb21002c 	lwi	r25, r1, 44

	/*
	 * Assert the arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
	Xil_AssertVoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
    1174:	30800001 	addik	r4, r0, 1
    1178:	b0000000 	imm	0
    117c:	f880ec58 	swi	r4, r0, -5032	// ec58 <Xil_AssertStatus>

	/* Enable the Interrupt if it was enabled before calling this function */
	if (CurrentIER & Mask) {
		XIntc_Enable(InstancePtr, Id);
	}
}
    1180:	b60f0008 	rtsd	r15, 8
    1184:	30210030 	addik	r1, r1, 48
	 * Assert the arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
	Xil_AssertVoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
	Xil_AssertVoid(InstancePtr->CfgPtr->FastIntr == TRUE);
    1188:	b0000000 	imm	0
    118c:	30a0d5b8 	addik	r5, r0, -10824	// d5b8 <__rodata_start>
    1190:	b0000000 	imm	0
    1194:	b9f400ac 	brlid	r15, 172	// 1240 <Xil_Assert>
    1198:	30c002c6 	addik	r6, r0, 710

	/* Enable the Interrupt if it was enabled before calling this function */
	if (CurrentIER & Mask) {
		XIntc_Enable(InstancePtr, Id);
	}
}
    119c:	e9e10000 	lwi	r15, r1, 0
    11a0:	ea61001c 	lwi	r19, r1, 28
    11a4:	eac10020 	lwi	r22, r1, 32
    11a8:	eae10024 	lwi	r23, r1, 36
    11ac:	eb010028 	lwi	r24, r1, 40
    11b0:	eb21002c 	lwi	r25, r1, 44
	 * Assert the arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
	Xil_AssertVoid(Id < XPAR_INTC_MAX_NUM_INTR_INPUTS);
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
	Xil_AssertVoid(InstancePtr->CfgPtr->FastIntr == TRUE);
    11b4:	30800001 	addik	r4, r0, 1
    11b8:	b0000000 	imm	0
    11bc:	f880ec58 	swi	r4, r0, -5032	// ec58 <Xil_AssertStatus>

	/* Enable the Interrupt if it was enabled before calling this function */
	if (CurrentIER & Mask) {
		XIntc_Enable(InstancePtr, Id);
	}
}
    11c0:	b60f0008 	rtsd	r15, 8
    11c4:	30210030 	addik	r1, r1, 48
	u32 Mask;

	/*
	 * Assert the arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
    11c8:	b0000000 	imm	0
    11cc:	30a0d5b8 	addik	r5, r0, -10824	// d5b8 <__rodata_start>
    11d0:	b0000000 	imm	0
    11d4:	b9f4006c 	brlid	r15, 108	// 1240 <Xil_Assert>
    11d8:	30c002c3 	addik	r6, r0, 707
    11dc:	30600001 	addik	r3, r0, 1
    11e0:	b0000000 	imm	0
    11e4:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
    11e8:	b810ff20 	brid	-224		// 1108
    11ec:	e9e10000 	lwi	r15, r1, 0

000011f0 <XAssert>:
*
******************************************************************************/
void XAssert(char *File, int Line)
{
	/* if the callback has been set then invoke it */
	if (XAssertCallbackRoutine != NULL) {
    11f0:	b0000000 	imm	0
    11f4:	e860ea90 	lwi	r3, r0, -5488	// ea90 <XAssertCallbackRoutine>
*
* @note     None.
*
******************************************************************************/
void XAssert(char *File, int Line)
{
    11f8:	3021ffe4 	addik	r1, r1, -28
	/* if the callback has been set then invoke it */
	if (XAssertCallbackRoutine != NULL) {
    11fc:	be030010 	beqid	r3, 16		// 120c
    1200:	f9e10000 	swi	r15, r1, 0
		(*XAssertCallbackRoutine) (File, Line);
    1204:	99fc1800 	brald	r15, r3
    1208:	80000000 	or	r0, r0, r0
	}

	/* if specified, wait indefinitely such that the assert will show up
	 * in testing
	 */
	while (XWaitInAssert) {
    120c:	b0000000 	imm	0
    1210:	e860e3a0 	lwi	r3, r0, -7264	// e3a0 <XWaitInAssert>
    1214:	be230010 	bneid	r3, 16		// 1224
    1218:	e9e10000 	lwi	r15, r1, 0
	}
}
    121c:	b60f0008 	rtsd	r15, 8
    1220:	3021001c 	addik	r1, r1, 28
    1224:	b8000000 	bri	0		// 1224

00001228 <XAssertSetCallback>:
* @note     This function has no effect if NDEBUG is set
*
******************************************************************************/
void XAssertSetCallback(XAssertCallback Routine)
{
	XAssertCallbackRoutine = Routine;
    1228:	b0000000 	imm	0
    122c:	f8a0ea90 	swi	r5, r0, -5488	// ea90 <XAssertCallbackRoutine>
}
    1230:	b60f0008 	rtsd	r15, 8
    1234:	80000000 	or	r0, r0, r0

00001238 <XNullHandler>:
*
******************************************************************************/
void XNullHandler(void *NullParameter)
{
 (void) NullParameter;
}
    1238:	b60f0008 	rtsd	r15, 8
    123c:	80000000 	or	r0, r0, r0

00001240 <Xil_Assert>:
*
******************************************************************************/
void Xil_Assert(const char *File, int Line)
{
	/* if the callback has been set then invoke it */
	if (Xil_AssertCallbackRoutine != 0) {
    1240:	b0000000 	imm	0
    1244:	e860ea94 	lwi	r3, r0, -5484	// ea94 <Xil_AssertCallbackRoutine>
*
* @note     None.
*
******************************************************************************/
void Xil_Assert(const char *File, int Line)
{
    1248:	3021ffe4 	addik	r1, r1, -28
	/* if the callback has been set then invoke it */
	if (Xil_AssertCallbackRoutine != 0) {
    124c:	be030010 	beqid	r3, 16		// 125c
    1250:	f9e10000 	swi	r15, r1, 0
		(*Xil_AssertCallbackRoutine)(File, Line);
    1254:	99fc1800 	brald	r15, r3
    1258:	80000000 	or	r0, r0, r0
	}

	/* if specified, wait indefinitely such that the assert will show up
	 * in testing
	 */
	while (Xil_AssertWait) {
    125c:	b0000000 	imm	0
    1260:	e860e3a4 	lwi	r3, r0, -7260	// e3a4 <Xil_AssertWait>
    1264:	be230010 	bneid	r3, 16		// 1274
    1268:	e9e10000 	lwi	r15, r1, 0
	}
}
    126c:	b60f0008 	rtsd	r15, 8
    1270:	3021001c 	addik	r1, r1, 28
    1274:	b8000000 	bri	0		// 1274

00001278 <Xil_AssertSetCallback>:
* @note     This function has no effect if NDEBUG is set
*
******************************************************************************/
void Xil_AssertSetCallback(Xil_AssertCallback Routine)
{
	Xil_AssertCallbackRoutine = Routine;
    1278:	b0000000 	imm	0
    127c:	f8a0ea94 	swi	r5, r0, -5484	// ea94 <Xil_AssertCallbackRoutine>
}
    1280:	b60f0008 	rtsd	r15, 8
    1284:	80000000 	or	r0, r0, r0

00001288 <exit>:
    1288:	3021ffe0 	addik	r1, r1, -32
    128c:	10c00000 	addk	r6, r0, r0
    1290:	fa61001c 	swi	r19, r1, 28
    1294:	f9e10000 	swi	r15, r1, 0
    1298:	b0000000 	imm	0
    129c:	b9f4002c 	brlid	r15, 44	// 12c8 <__call_exitprocs>
    12a0:	12650000 	addk	r19, r5, r0
    12a4:	b0000000 	imm	0
    12a8:	e880d5c0 	lwi	r4, r0, -10816	// d5c0 <_global_impure_ptr>
    12ac:	e8640028 	lwi	r3, r4, 40
    12b0:	bc03000c 	beqi	r3, 12		// 12bc
    12b4:	99fc1800 	brald	r15, r3
    12b8:	10a40000 	addk	r5, r4, r0
    12bc:	b000ffff 	imm	-1
    12c0:	b9f4edc0 	brlid	r15, -4672	// 80 <_exit>
    12c4:	10b30000 	addk	r5, r19, r0

000012c8 <__call_exitprocs>:
    12c8:	3021ffb8 	addik	r1, r1, -72
    12cc:	fb810038 	swi	r28, r1, 56
    12d0:	b0000000 	imm	0
    12d4:	eb80d5c0 	lwi	r28, r0, -10816	// d5c0 <_global_impure_ptr>
    12d8:	fb21002c 	swi	r25, r1, 44
    12dc:	fbc10040 	swi	r30, r1, 64
    12e0:	fbe10044 	swi	r31, r1, 68
    12e4:	13c50000 	addk	r30, r5, r0
    12e8:	13260000 	addk	r25, r6, r0
    12ec:	b0000000 	imm	0
    12f0:	33e04f64 	addik	r31, r0, 20324	// 4f64 <free>
    12f4:	fb610034 	swi	r27, r1, 52
    12f8:	fba1003c 	swi	r29, r1, 60
    12fc:	f9e10000 	swi	r15, r1, 0
    1300:	fa61001c 	swi	r19, r1, 28
    1304:	fac10020 	swi	r22, r1, 32
    1308:	fae10024 	swi	r23, r1, 36
    130c:	fb010028 	swi	r24, r1, 40
    1310:	fb410030 	swi	r26, r1, 48
    1314:	33bc0048 	addik	r29, r28, 72
    1318:	33600001 	addik	r27, r0, 1
    131c:	eadc0048 	lwi	r22, r28, 72
    1320:	be1600cc 	beqid	r22, 204		// 13ec
    1324:	135d0000 	addk	r26, r29, r0
    1328:	e8760004 	lwi	r3, r22, 4
    132c:	3263ffff 	addik	r19, r3, -1
    1330:	be5300b8 	bltid	r19, 184		// 13e8
    1334:	eaf60088 	lwi	r23, r22, 136
    1338:	bc19011c 	beqi	r25, 284		// 1454
    133c:	bc370010 	bnei	r23, 16		// 134c
    1340:	b80000a8 	bri	168		// 13e8
    1344:	3273ffff 	addik	r19, r19, -1
    1348:	bc5300a0 	blti	r19, 160		// 13e8
    134c:	30730020 	addik	r3, r19, 32
    1350:	60630004 	muli	r3, r3, 4
    1354:	c863b800 	lw	r3, r3, r23
    1358:	8863c800 	xor	r3, r3, r25
    135c:	be23ffe8 	bneid	r3, -24		// 1344
    1360:	30f30002 	addik	r7, r19, 2
    1364:	eb160004 	lwi	r24, r22, 4
    1368:	60e70004 	muli	r7, r7, 4
    136c:	30d8ffff 	addik	r6, r24, -1
    1370:	89069800 	xor	r8, r6, r19
    1374:	be0800c0 	beqid	r8, 192		// 1434
    1378:	c887b000 	lw	r4, r7, r22
    137c:	d867b000 	sw	r3, r7, r22
    1380:	bc04ffc4 	beqi	r4, -60		// 1344
    1384:	e8d70100 	lwi	r6, r23, 256
    1388:	a653001f 	andi	r18, r19, 31
    138c:	1060d800 	addk	r3, r0, r27
    1390:	be120014 	beqid	r18, 20		// 13a4
    1394:	10630000 	addk	r3, r3, r0
    1398:	3252ffff 	addik	r18, r18, -1
    139c:	be32fffc 	bneid	r18, -4		// 1398
    13a0:	10631800 	addk	r3, r3, r3
    13a4:	84c33000 	and	r6, r3, r6
    13a8:	bc06007c 	beqi	r6, 124		// 1424
    13ac:	e8b70104 	lwi	r5, r23, 260
    13b0:	84632800 	and	r3, r3, r5
    13b4:	be03008c 	beqid	r3, 140		// 1440
    13b8:	60730004 	muli	r3, r19, 4
    13bc:	99fc2000 	brald	r15, r4
    13c0:	c8a3b800 	lw	r5, r3, r23
    13c4:	e8760004 	lwi	r3, r22, 4
    13c8:	8b03c000 	xor	r24, r3, r24
    13cc:	bc38ff50 	bnei	r24, -176		// 131c
    13d0:	e87a0000 	lwi	r3, r26, 0
    13d4:	8863b000 	xor	r3, r3, r22
    13d8:	be23ff44 	bneid	r3, -188		// 131c
    13dc:	3273ffff 	addik	r19, r19, -1
    13e0:	beb3ff70 	bgeid	r19, -144		// 1350
    13e4:	30730020 	addik	r3, r19, 32
    13e8:	bc3f01a0 	bnei	r31, 416		// 1588
    13ec:	e9e10000 	lwi	r15, r1, 0
    13f0:	ea61001c 	lwi	r19, r1, 28
    13f4:	eac10020 	lwi	r22, r1, 32
    13f8:	eae10024 	lwi	r23, r1, 36
    13fc:	eb010028 	lwi	r24, r1, 40
    1400:	eb21002c 	lwi	r25, r1, 44
    1404:	eb410030 	lwi	r26, r1, 48
    1408:	eb610034 	lwi	r27, r1, 52
    140c:	eb810038 	lwi	r28, r1, 56
    1410:	eba1003c 	lwi	r29, r1, 60
    1414:	ebc10040 	lwi	r30, r1, 64
    1418:	ebe10044 	lwi	r31, r1, 68
    141c:	b60f0008 	rtsd	r15, 8
    1420:	30210048 	addik	r1, r1, 72
    1424:	99fc2000 	brald	r15, r4
    1428:	80000000 	or	r0, r0, r0
    142c:	b810ff9c 	brid	-100		// 13c8
    1430:	e8760004 	lwi	r3, r22, 4
    1434:	f8d60004 	swi	r6, r22, 4
    1438:	b810ff48 	brid	-184		// 1380
    143c:	13060000 	addk	r24, r6, r0
    1440:	10be0000 	addk	r5, r30, r0
    1444:	99fc2000 	brald	r15, r4
    1448:	c8c3b800 	lw	r6, r3, r23
    144c:	b810ff7c 	brid	-132		// 13c8
    1450:	e8760004 	lwi	r3, r22, 4
    1454:	be1700f0 	beqid	r23, 240		// 1544
    1458:	13030000 	addk	r24, r3, r0
    145c:	30d30002 	addik	r6, r19, 2
    1460:	3063ffff 	addik	r3, r3, -1
    1464:	60c60004 	muli	r6, r6, 4
    1468:	88e39800 	xor	r7, r3, r19
    146c:	be070094 	beqid	r7, 148		// 1500
    1470:	c886b000 	lw	r4, r6, r22
    1474:	d806b000 	sw	r0, r6, r22
    1478:	bc040060 	beqi	r4, 96		// 14d8
    147c:	e8b70100 	lwi	r5, r23, 256
    1480:	a653001f 	andi	r18, r19, 31
    1484:	1060d800 	addk	r3, r0, r27
    1488:	be120014 	beqid	r18, 20		// 149c
    148c:	10630000 	addk	r3, r3, r0
    1490:	3252ffff 	addik	r18, r18, -1
    1494:	be32fffc 	bneid	r18, -4		// 1490
    1498:	10631800 	addk	r3, r3, r3
    149c:	84a32800 	and	r5, r3, r5
    14a0:	bc0500c8 	beqi	r5, 200		// 1568
    14a4:	e8b70104 	lwi	r5, r23, 260
    14a8:	84632800 	and	r3, r3, r5
    14ac:	be2300cc 	bneid	r3, 204		// 1578
    14b0:	60730004 	muli	r3, r19, 4
    14b4:	10be0000 	addk	r5, r30, r0
    14b8:	99fc2000 	brald	r15, r4
    14bc:	c8c3b800 	lw	r6, r3, r23
    14c0:	e8760004 	lwi	r3, r22, 4
    14c4:	8863c000 	xor	r3, r3, r24
    14c8:	bc23fe54 	bnei	r3, -428		// 131c
    14cc:	e87a0000 	lwi	r3, r26, 0
    14d0:	8863b000 	xor	r3, r3, r22
    14d4:	bc23fe48 	bnei	r3, -440		// 131c
    14d8:	3273ffff 	addik	r19, r19, -1
    14dc:	be53ff0c 	bltid	r19, -244		// 13e8
    14e0:	30d30002 	addik	r6, r19, 2
    14e4:	e8760004 	lwi	r3, r22, 4
    14e8:	60c60004 	muli	r6, r6, 4
    14ec:	13030000 	addk	r24, r3, r0
    14f0:	3063ffff 	addik	r3, r3, -1
    14f4:	88e39800 	xor	r7, r3, r19
    14f8:	be27ff7c 	bneid	r7, -132		// 1474
    14fc:	c886b000 	lw	r4, r6, r22
    1500:	f8760004 	swi	r3, r22, 4
    1504:	b810ff74 	brid	-140		// 1478
    1508:	13030000 	addk	r24, r3, r0
    150c:	13030000 	addk	r24, r3, r0
    1510:	f8760004 	swi	r3, r22, 4
    1514:	bc060024 	beqi	r6, 36		// 1538
    1518:	99fc3000 	brald	r15, r6
    151c:	80000000 	or	r0, r0, r0
    1520:	e8760004 	lwi	r3, r22, 4
    1524:	8863c000 	xor	r3, r3, r24
    1528:	bc23fdf4 	bnei	r3, -524		// 131c
    152c:	e87a0000 	lwi	r3, r26, 0
    1530:	8863b000 	xor	r3, r3, r22
    1534:	bc23fde8 	bnei	r3, -536		// 131c
    1538:	3273ffff 	addik	r19, r19, -1
    153c:	bc53feac 	blti	r19, -340		// 13e8
    1540:	e8760004 	lwi	r3, r22, 4
    1544:	13030000 	addk	r24, r3, r0
    1548:	30930002 	addik	r4, r19, 2
    154c:	3063ffff 	addik	r3, r3, -1
    1550:	60840004 	muli	r4, r4, 4
    1554:	88a39800 	xor	r5, r3, r19
    1558:	be05ffb4 	beqid	r5, -76		// 150c
    155c:	c8c4b000 	lw	r6, r4, r22
    1560:	b810ffb4 	brid	-76		// 1514
    1564:	d804b000 	sw	r0, r4, r22
    1568:	99fc2000 	brald	r15, r4
    156c:	80000000 	or	r0, r0, r0
    1570:	b810ff54 	brid	-172		// 14c4
    1574:	e8760004 	lwi	r3, r22, 4
    1578:	99fc2000 	brald	r15, r4
    157c:	c8a3b800 	lw	r5, r3, r23
    1580:	b810ff44 	brid	-188		// 14c4
    1584:	e8760004 	lwi	r3, r22, 4
    1588:	e8760004 	lwi	r3, r22, 4
    158c:	bc230040 	bnei	r3, 64		// 15cc
    1590:	e8760000 	lwi	r3, r22, 0
    1594:	bc03003c 	beqi	r3, 60		// 15d0
    1598:	be170014 	beqid	r23, 20		// 15ac
    159c:	f87a0000 	swi	r3, r26, 0
    15a0:	b0000000 	imm	0
    15a4:	b9f439c0 	brlid	r15, 14784	// 4f64 <free>
    15a8:	10b70000 	addk	r5, r23, r0
    15ac:	b0000000 	imm	0
    15b0:	b9f439b4 	brlid	r15, 14772	// 4f64 <free>
    15b4:	10b60000 	addk	r5, r22, r0
    15b8:	eada0000 	lwi	r22, r26, 0
    15bc:	be36fd6c 	bneid	r22, -660		// 1328
    15c0:	e9e10000 	lwi	r15, r1, 0
    15c4:	b810fe30 	brid	-464		// 13f4
    15c8:	ea61001c 	lwi	r19, r1, 28
    15cc:	e8760000 	lwi	r3, r22, 0
    15d0:	13560000 	addk	r26, r22, r0
    15d4:	b810ffe8 	brid	-24		// 15bc
    15d8:	12c30000 	addk	r22, r3, r0

000015dc <enable_caches>:

#define UART_BAUD 9600

void
enable_caches()
{
    15dc:	3021ffe4 	addik	r1, r1, -28
    15e0:	f9e10000 	swi	r15, r1, 0
#ifdef __PPC__
    Xil_ICacheEnableRegion(CACHEABLE_REGION_MASK);
    Xil_DCacheEnableRegion(CACHEABLE_REGION_MASK);
#elif __MICROBLAZE__
#ifdef XPAR_MICROBLAZE_USE_ICACHE
    Xil_ICacheEnable();
    15e4:	b0000000 	imm	0
    15e8:	b9f427ac 	brlid	r15, 10156	// 3d94 <microblaze_enable_icache>
    15ec:	80000000 	or	r0, r0, r0
#endif
#ifdef XPAR_MICROBLAZE_USE_DCACHE
    Xil_DCacheEnable();
    15f0:	b0000000 	imm	0
    15f4:	b9f42788 	brlid	r15, 10120	// 3d7c <microblaze_enable_dcache>
    15f8:	80000000 	or	r0, r0, r0
#endif
#endif
}
    15fc:	e9e10000 	lwi	r15, r1, 0
    1600:	b60f0008 	rtsd	r15, 8
    1604:	3021001c 	addik	r1, r1, 28

00001608 <disable_caches>:

void
disable_caches()
{
    1608:	3021ffe4 	addik	r1, r1, -28
    160c:	f9e10000 	swi	r15, r1, 0
    Xil_DCacheDisable();
    1610:	b0000000 	imm	0
    1614:	b9f427c4 	brlid	r15, 10180	// 3dd8 <Xil_DCacheDisable>
    1618:	80000000 	or	r0, r0, r0
    Xil_ICacheDisable();
    161c:	b0000000 	imm	0
    1620:	b9f427f0 	brlid	r15, 10224	// 3e10 <Xil_ICacheDisable>
    1624:	80000000 	or	r0, r0, r0
}
    1628:	e9e10000 	lwi	r15, r1, 0
    162c:	b60f0008 	rtsd	r15, 8
    1630:	3021001c 	addik	r1, r1, 28

00001634 <init_uart>:
{
#ifdef STDOUT_IS_16550
    XUartNs550_SetBaud(STDOUT_BASEADDR, XPAR_XUARTNS550_CLOCK_HZ, UART_BAUD);
    XUartNs550_SetLineControlReg(STDOUT_BASEADDR, XUN_LCR_8_DATA_BITS);
#endif
}
    1634:	b60f0008 	rtsd	r15, 8
    1638:	80000000 	or	r0, r0, r0

0000163c <init_platform>:

void
init_platform()
{
    163c:	3021ffe4 	addik	r1, r1, -28
    1640:	f9e10000 	swi	r15, r1, 0
     * uncomment the following line and also #include "ps7_init.h" at the top.
     * Make sure that the ps7_init.c and ps7_init.h files are included
     * along with this example source files for compilation.
     */
    /* ps7_init();*/
    enable_caches();
    1644:	b9f4ff98 	brlid	r15, -104	// 15dc <enable_caches>
    1648:	80000000 	or	r0, r0, r0
    init_uart();
}
    164c:	e9e10000 	lwi	r15, r1, 0
    1650:	b60f0008 	rtsd	r15, 8
    1654:	3021001c 	addik	r1, r1, 28

00001658 <cleanup_platform>:

void
cleanup_platform()
{
    1658:	3021ffe4 	addik	r1, r1, -28
    165c:	f9e10000 	swi	r15, r1, 0
    disable_caches();
    1660:	b9f4ffa8 	brlid	r15, -88	// 1608 <disable_caches>
    1664:	80000000 	or	r0, r0, r0
}
    1668:	e9e10000 	lwi	r15, r1, 0
    166c:	b60f0008 	rtsd	r15, 8
    1670:	3021001c 	addik	r1, r1, 28

00001674 <timenow>:
#define LOG_IF_ERROR(condition, message, ...) if (condition) PRINTFUNCTION(LOG_FMT message NEWLINE, LOG_ARGS(ERROR_TAG), ## __VA_ARGS__)
#else
#define LOG_IF_ERROR(condition, message, ...)
#endif

static inline char *timenow() {
    1674:	3021ffe0 	addik	r1, r1, -32
    1678:	f9e10000 	swi	r15, r1, 0
    static char buffer[64];
    time_t rawtime;
    struct tm *timeinfo;

    time(&rawtime);
    167c:	b0000000 	imm	0
    1680:	b9f41fbc 	brlid	r15, 8124	// 363c <time>
    1684:	30a1001c 	addik	r5, r1, 28
    timeinfo = localtime(&rawtime);
    1688:	b0000000 	imm	0
    168c:	b9f4380c 	brlid	r15, 14348	// 4e98 <localtime>
    1690:	30a1001c 	addik	r5, r1, 28

    strftime(buffer, 64, "%Y-%m-%d %H:%M:%S", timeinfo);
    1694:	b0000000 	imm	0
    1698:	30a0eaa4 	addik	r5, r0, -5468	// eaa4 <buffer.2636>
    169c:	b0000000 	imm	0
    16a0:	30e0d5c8 	addik	r7, r0, -10808
    16a4:	11030000 	addk	r8, r3, r0
    16a8:	b0000000 	imm	0
    16ac:	b9f45e2c 	brlid	r15, 24108	// 74d8 <strftime>
    16b0:	30c00040 	addik	r6, r0, 64

    return buffer;
}
    16b4:	b0000000 	imm	0
    16b8:	3060eaa4 	addik	r3, r0, -5468	// eaa4 <buffer.2636>
    16bc:	e9e10000 	lwi	r15, r1, 0
    16c0:	b60f0008 	rtsd	r15, 8
    16c4:	30210020 	addik	r1, r1, 32

000016c8 <RecvHandler>:
    currently_sending = 0;
  }
  LOG_DEBUG("sent %x\n", EventData);
}

void RecvHandler(void *CallBackRef, unsigned int EventData) {
    16c8:	3021ffe0 	addik	r1, r1, -32
  if (EventData != sizeof(uint32_t)) {
    16cc:	a8c60004 	xori	r6, r6, 4
    16d0:	be060064 	beqid	r6, 100		// 1734
    16d4:	f9e10000 	swi	r15, r1, 0
static inline char *timenow() {
    static char buffer[64];
    time_t rawtime;
    struct tm *timeinfo;

    time(&rawtime);
    16d8:	b0000000 	imm	0
    16dc:	b9f41f60 	brlid	r15, 8032	// 363c <time>
    16e0:	30a1001c 	addik	r5, r1, 28
    timeinfo = localtime(&rawtime);
    16e4:	b0000000 	imm	0
    16e8:	b9f437b0 	brlid	r15, 14256	// 4e98 <localtime>
    16ec:	30a1001c 	addik	r5, r1, 28

    strftime(buffer, 64, "%Y-%m-%d %H:%M:%S", timeinfo);
    16f0:	b0000000 	imm	0
    16f4:	30a0eaa4 	addik	r5, r0, -5468	// eaa4 <buffer.2636>
    16f8:	b0000000 	imm	0
    16fc:	30e0d5c8 	addik	r7, r0, -10808
    1700:	11030000 	addk	r8, r3, r0
    1704:	b0000000 	imm	0
    1708:	b9f45dd0 	brlid	r15, 24016	// 74d8 <strftime>
    170c:	30c00040 	addik	r6, r0, 64
    LOG_ERROR("ERROR: did not receive a whole word!\n");
    1710:	b0000000 	imm	0
    1714:	30a0d5dc 	addik	r5, r0, -10788
    1718:	b0000000 	imm	0
    171c:	30c0eaa4 	addik	r6, r0, -5468	// eaa4 <buffer.2636>
    1720:	b0000000 	imm	0
    1724:	30e0d610 	addik	r7, r0, -10736
    1728:	b0000000 	imm	0
    172c:	b9f42188 	brlid	r15, 8584	// 38b4 <xil_printf>
    1730:	80000000 	or	r0, r0, r0
  }
  cbuffer_push_back(rx_buffer, rx_tmp_buffer);
    1734:	b0000000 	imm	0
    1738:	e8c0ea9c 	lwi	r6, r0, -5476	// ea9c <rx_tmp_buffer>
    173c:	b0000000 	imm	0
    1740:	e8a0eae4 	lwi	r5, r0, -5404	// eae4 <rx_buffer>
    1744:	b0000000 	imm	0
    1748:	b9f40a38 	brlid	r15, 2616	// 2180 <cbuffer_push_back>
    174c:	80000000 	or	r0, r0, r0
  XUartLite_Recv(&UartLite, (u8*)&rx_tmp_buffer, sizeof(uint32_t));
    1750:	b0000000 	imm	0
    1754:	30a0ec5c 	addik	r5, r0, -5028	// ec5c <UartLite>
    1758:	b0000000 	imm	0
    175c:	30c0ea9c 	addik	r6, r0, -5476	// ea9c <rx_tmp_buffer>
    1760:	b0000000 	imm	0
    1764:	b9f43018 	brlid	r15, 12312	// 477c <XUartLite_Recv>
    1768:	30e00004 	addik	r7, r0, 4
  LOG_DEBUG("recv %x\n", EventData);
}
    176c:	e9e10000 	lwi	r15, r1, 0
    1770:	b60f0008 	rtsd	r15, 8
    1774:	30210020 	addik	r1, r1, 32

00001778 <SendHandler>:
static volatile uint32_t rx_tmp_buffer;
static volatile int currently_sending = 0;

int SetupInterruptSystem(XUartLite *UartLitePtr);

void SendHandler(void *CallBackRef, unsigned int EventData) {
    1778:	3021ffdc 	addik	r1, r1, -36
    177c:	fa610020 	swi	r19, r1, 32
    1780:	f9e10000 	swi	r15, r1, 0
  // delete the bytes which were sent previously
  if (EventData % sizeof(uint32_t)) {
    1784:	a4660003 	andi	r3, r6, 3
    1788:	be230058 	bneid	r3, 88		// 17e0
    178c:	12660000 	addk	r19, r6, r0
    LOG_ERROR("ERROR: sent data not word aligned!!!\n");
  }
  cbuffer_deletefront(tx_buffer, EventData / sizeof(uint32_t));
    1790:	b0000000 	imm	0
    1794:	e8a0eaa0 	lwi	r5, r0, -5472	// eaa0 <tx_buffer>
    1798:	10c09800 	addk	r6, r0, r19
    179c:	90d30041 	srl	r6, r19
    17a0:	90c60041 	srl	r6, r6
    17a4:	b0000000 	imm	0
    17a8:	b9f40c08 	brlid	r15, 3080	// 23b0 <cbuffer_deletefront>
    17ac:	80000000 	or	r0, r0, r0
  if (cbuffer_size(tx_buffer)) {
    17b0:	b0000000 	imm	0
    17b4:	e8a0eaa0 	lwi	r5, r0, -5472	// eaa0 <tx_buffer>
    17b8:	b0000000 	imm	0
    17bc:	b9f4075c 	brlid	r15, 1884	// 1f18 <cbuffer_size>
    17c0:	80000000 	or	r0, r0, r0
    17c4:	be23007c 	bneid	r3, 124		// 1840
    17c8:	e9e10000 	lwi	r15, r1, 0
    currently_sending = 1;
  } else {
    currently_sending = 0;
  }
  LOG_DEBUG("sent %x\n", EventData);
}
    17cc:	ea610020 	lwi	r19, r1, 32
  if (cbuffer_size(tx_buffer)) {
    unsigned int to_send = cbuffer_contiguous_data_size(tx_buffer) * sizeof(uint32_t);
    XUartLite_Send(&UartLite, (u8*)&(tx_buffer->data[tx_buffer->pos]), to_send);
    currently_sending = 1;
  } else {
    currently_sending = 0;
    17d0:	b0000000 	imm	0
    17d4:	f860ea98 	swi	r3, r0, -5480	// ea98 <currently_sending>
  }
  LOG_DEBUG("sent %x\n", EventData);
}
    17d8:	b60f0008 	rtsd	r15, 8
    17dc:	30210024 	addik	r1, r1, 36
static inline char *timenow() {
    static char buffer[64];
    time_t rawtime;
    struct tm *timeinfo;

    time(&rawtime);
    17e0:	b0000000 	imm	0
    17e4:	b9f41e58 	brlid	r15, 7768	// 363c <time>
    17e8:	30a1001c 	addik	r5, r1, 28
    timeinfo = localtime(&rawtime);
    17ec:	b0000000 	imm	0
    17f0:	b9f436a8 	brlid	r15, 13992	// 4e98 <localtime>
    17f4:	30a1001c 	addik	r5, r1, 28

    strftime(buffer, 64, "%Y-%m-%d %H:%M:%S", timeinfo);
    17f8:	b0000000 	imm	0
    17fc:	30a0eaa4 	addik	r5, r0, -5468	// eaa4 <buffer.2636>
    1800:	b0000000 	imm	0
    1804:	30e0d5c8 	addik	r7, r0, -10808
    1808:	11030000 	addk	r8, r3, r0
    180c:	b0000000 	imm	0
    1810:	b9f45cc8 	brlid	r15, 23752	// 74d8 <strftime>
    1814:	30c00040 	addik	r6, r0, 64
int SetupInterruptSystem(XUartLite *UartLitePtr);

void SendHandler(void *CallBackRef, unsigned int EventData) {
  // delete the bytes which were sent previously
  if (EventData % sizeof(uint32_t)) {
    LOG_ERROR("ERROR: sent data not word aligned!!!\n");
    1818:	b0000000 	imm	0
    181c:	30a0d618 	addik	r5, r0, -10728
    1820:	b0000000 	imm	0
    1824:	30c0eaa4 	addik	r6, r0, -5468	// eaa4 <buffer.2636>
    1828:	b0000000 	imm	0
    182c:	30e0d610 	addik	r7, r0, -10736
    1830:	b0000000 	imm	0
    1834:	b9f42080 	brlid	r15, 8320	// 38b4 <xil_printf>
    1838:	80000000 	or	r0, r0, r0
    183c:	b800ff54 	bri	-172		// 1790
  }
  cbuffer_deletefront(tx_buffer, EventData / sizeof(uint32_t));
  if (cbuffer_size(tx_buffer)) {
    unsigned int to_send = cbuffer_contiguous_data_size(tx_buffer) * sizeof(uint32_t);
    1840:	b0000000 	imm	0
    1844:	e8a0eaa0 	lwi	r5, r0, -5472	// eaa0 <tx_buffer>
    1848:	b0000000 	imm	0
    184c:	b9f406f0 	brlid	r15, 1776	// 1f3c <cbuffer_contiguous_data_size>
    1850:	80000000 	or	r0, r0, r0
    XUartLite_Send(&UartLite, (u8*)&(tx_buffer->data[tx_buffer->pos]), to_send);
    1854:	b0000000 	imm	0
    1858:	e880eaa0 	lwi	r4, r0, -5472	// eaa0 <tx_buffer>
    185c:	60e30004 	muli	r7, r3, 4
    1860:	b0000000 	imm	0
    1864:	30a0ec5c 	addik	r5, r0, -5028	// ec5c <UartLite>
    1868:	e8640008 	lwi	r3, r4, 8
    186c:	e8c40000 	lwi	r6, r4, 0
    1870:	60630004 	muli	r3, r3, 4
    1874:	b0000000 	imm	0
    1878:	b9f42cec 	brlid	r15, 11500	// 4564 <XUartLite_Send>
    187c:	10c61800 	addk	r6, r6, r3
    currently_sending = 1;
  } else {
    currently_sending = 0;
  }
  LOG_DEBUG("sent %x\n", EventData);
}
    1880:	e9e10000 	lwi	r15, r1, 0
    1884:	ea610020 	lwi	r19, r1, 32
  }
  cbuffer_deletefront(tx_buffer, EventData / sizeof(uint32_t));
  if (cbuffer_size(tx_buffer)) {
    unsigned int to_send = cbuffer_contiguous_data_size(tx_buffer) * sizeof(uint32_t);
    XUartLite_Send(&UartLite, (u8*)&(tx_buffer->data[tx_buffer->pos]), to_send);
    currently_sending = 1;
    1888:	30600001 	addik	r3, r0, 1
    188c:	b0000000 	imm	0
    1890:	f860ea98 	swi	r3, r0, -5480	// ea98 <currently_sending>
  } else {
    currently_sending = 0;
  }
  LOG_DEBUG("sent %x\n", EventData);
}
    1894:	b60f0008 	rtsd	r15, 8
    1898:	30210024 	addik	r1, r1, 36

0000189c <SetupInterruptSystem>:
    }
  }

}

int SetupInterruptSystem(XUartLite *UartLitePtr) {
    189c:	3021ffdc 	addik	r1, r1, -36
    18a0:	fac10020 	swi	r22, r1, 32
    18a4:	12c50000 	addk	r22, r5, r0

  /*
   * Initialize the interrupt controller driver so that it is ready to
   * use.
   */
  Status = XIntc_Initialize(&InterruptController, INTC_DEVICE_ID);
    18a8:	b0000000 	imm	0
    18ac:	30a0eca8 	addik	r5, r0, -4952	// eca8 <InterruptController>
    18b0:	10c00000 	addk	r6, r0, r0
    }
  }

}

int SetupInterruptSystem(XUartLite *UartLitePtr) {
    18b4:	fa61001c 	swi	r19, r1, 28
    18b8:	f9e10000 	swi	r15, r1, 0

  /*
   * Initialize the interrupt controller driver so that it is ready to
   * use.
   */
  Status = XIntc_Initialize(&InterruptController, INTC_DEVICE_ID);
    18bc:	b000ffff 	imm	-1
    18c0:	b9f4ed94 	brlid	r15, -4716	// 654 <XIntc_Initialize>
    18c4:	32600001 	addik	r19, r0, 1
  if (Status != XST_SUCCESS) {
    18c8:	be030020 	beqid	r3, 32		// 18e8
    18cc:	10d30000 	addk	r6, r19, r0
  Xil_ExceptionEnable();

  LOG_DEBUG("Setup interrupts okay\n");

  return XST_SUCCESS;
}
    18d0:	10730000 	addk	r3, r19, r0
    18d4:	e9e10000 	lwi	r15, r1, 0
    18d8:	ea61001c 	lwi	r19, r1, 28
    18dc:	eac10020 	lwi	r22, r1, 32
    18e0:	b60f0008 	rtsd	r15, 8
    18e4:	30210024 	addik	r1, r1, 36
  /*
   * Connect a device driver handler that will be called when an interrupt
   * for the device occurs, the device driver handler performs the
   * specific interrupt processing for the device.
   */
  Status = XIntc_Connect(&InterruptController, UARTLITE_INT_IRQ_ID,
    18e8:	b0000000 	imm	0
    18ec:	30a0eca8 	addik	r5, r0, -4952	// eca8 <InterruptController>
    18f0:	b0000000 	imm	0
    18f4:	30e04094 	addik	r7, r0, 16532	// 4094 <XUartLite_InterruptHandler>
    18f8:	b000ffff 	imm	-1
    18fc:	b9f4f044 	brlid	r15, -4028	// 940 <XIntc_Connect>
    1900:	11160000 	addk	r8, r22, r0
      (XInterruptHandler)XUartLite_InterruptHandler,
      (void *)UartLitePtr);
  if (Status != XST_SUCCESS) {
    1904:	be23ffd0 	bneid	r3, -48		// 18d4
    1908:	10730000 	addk	r3, r19, r0
  /*
   * Start the interrupt controller such that interrupts are enabled for
   * all devices that cause interrupts, specific real mode so that
   * the UartLite can cause interrupts through the interrupt controller.
   */
  Status = XIntc_Start(&InterruptController, XIN_REAL_MODE);
    190c:	b0000000 	imm	0
    1910:	30a0eca8 	addik	r5, r0, -4952	// eca8 <InterruptController>
    1914:	b000ffff 	imm	-1
    1918:	b9f4eea8 	brlid	r15, -4440	// 7c0 <XIntc_Start>
    191c:	10d30000 	addk	r6, r19, r0
  if (Status != XST_SUCCESS) {
    1920:	be23ffb0 	bneid	r3, -80		// 18d0
    1924:	10d30000 	addk	r6, r19, r0
  }

  /*
   * Enable the interrupt for the UartLite device.
   */
  XIntc_Enable(&InterruptController, UARTLITE_INT_IRQ_ID);
    1928:	b0000000 	imm	0
    192c:	30a0eca8 	addik	r5, r0, -4952	// eca8 <InterruptController>
    1930:	b000ffff 	imm	-1
    1934:	b9f4f220 	brlid	r15, -3552	// b54 <XIntc_Enable>
    1938:	12630000 	addk	r19, r3, r0

  /*
   * Initialize the exception table.
   */
  Xil_ExceptionInit();
    193c:	b0000000 	imm	0
    1940:	b9f42504 	brlid	r15, 9476	// 3e44 <Xil_ExceptionInit>
    1944:	80000000 	or	r0, r0, r0

  /*
   * Register the interrupt controller handler with the exception table.
   */
  Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
    1948:	b0000000 	imm	0
    194c:	30c04c34 	addik	r6, r0, 19508	// 4c34 <XIntc_InterruptHandler>
    1950:	b0000000 	imm	0
    1954:	30e0eca8 	addik	r7, r0, -4952	// eca8 <InterruptController>
    1958:	b0000000 	imm	0
    195c:	b9f42548 	brlid	r15, 9544	// 3ea4 <Xil_ExceptionRegisterHandler>
    1960:	30a00010 	addik	r5, r0, 16	// 10 <_vector_interrupt>
      &InterruptController);

  /*
   * Enable exceptions.
   */
  Xil_ExceptionEnable();
    1964:	b0000000 	imm	0
    1968:	b9f424e4 	brlid	r15, 9444	// 3e4c <Xil_ExceptionEnable>
    196c:	80000000 	or	r0, r0, r0

  LOG_DEBUG("Setup interrupts okay\n");

  return XST_SUCCESS;
    1970:	b810ff64 	brid	-156		// 18d4
    1974:	10730000 	addk	r3, r19, r0

00001978 <buffer_new>:
#include <stdlib.h>
#include <string.h>

#include "buffer.h"

Buffer* buffer_new(void* data, uint32_t size) {
    1978:	3021ffd4 	addik	r1, r1, -44
    197c:	fb010028 	swi	r24, r1, 40
    1980:	13060000 	addk	r24, r6, r0
    1984:	fae10024 	swi	r23, r1, 36
    1988:	12e50000 	addk	r23, r5, r0
  Buffer* output = malloc(sizeof(Buffer));
    198c:	30a00008 	addik	r5, r0, 8	// 8 <_vector_sw_exception>
#include <stdlib.h>
#include <string.h>

#include "buffer.h"

Buffer* buffer_new(void* data, uint32_t size) {
    1990:	f9e10000 	swi	r15, r1, 0
    1994:	fa61001c 	swi	r19, r1, 28
  Buffer* output = malloc(sizeof(Buffer));
    1998:	b0000000 	imm	0
    199c:	b9f4359c 	brlid	r15, 13724	// 4f38 <malloc>
    19a0:	fac10020 	swi	r22, r1, 32
  output->data = malloc(size * sizeof(uint32_t));
    19a4:	62d80004 	muli	r22, r24, 4
    19a8:	10b60000 	addk	r5, r22, r0
    19ac:	b0000000 	imm	0
    19b0:	b9f43588 	brlid	r15, 13704	// 4f38 <malloc>
    19b4:	12630000 	addk	r19, r3, r0
    19b8:	f8730000 	swi	r3, r19, 0
  output->size = size;
    19bc:	fb130004 	swi	r24, r19, 4
  if (data) {
    memcpy(output->data, data, size * sizeof(uint32_t));
    19c0:	10a30000 	addk	r5, r3, r0
    19c4:	10d70000 	addk	r6, r23, r0

Buffer* buffer_new(void* data, uint32_t size) {
  Buffer* output = malloc(sizeof(Buffer));
  output->data = malloc(size * sizeof(uint32_t));
  output->size = size;
  if (data) {
    19c8:	be170034 	beqid	r23, 52		// 19fc
    19cc:	10f60000 	addk	r7, r22, r0
    memcpy(output->data, data, size * sizeof(uint32_t));
    19d0:	b0000000 	imm	0
    19d4:	b9f44144 	brlid	r15, 16708	// 5b18 <memcpy>
    19d8:	80000000 	or	r0, r0, r0
  } else {
    memset(output->data, 0, size * sizeof(uint32_t));
  }
  return output;
}
    19dc:	10730000 	addk	r3, r19, r0
    19e0:	e9e10000 	lwi	r15, r1, 0
    19e4:	ea61001c 	lwi	r19, r1, 28
    19e8:	eac10020 	lwi	r22, r1, 32
    19ec:	eae10024 	lwi	r23, r1, 36
    19f0:	eb010028 	lwi	r24, r1, 40
    19f4:	b60f0008 	rtsd	r15, 8
    19f8:	3021002c 	addik	r1, r1, 44
  output->data = malloc(size * sizeof(uint32_t));
  output->size = size;
  if (data) {
    memcpy(output->data, data, size * sizeof(uint32_t));
  } else {
    memset(output->data, 0, size * sizeof(uint32_t));
    19fc:	b0000000 	imm	0
    1a00:	b9f445f4 	brlid	r15, 17908	// 5ff4 <memset>
    1a04:	80000000 	or	r0, r0, r0
  }
  return output;
}
    1a08:	10730000 	addk	r3, r19, r0
    1a0c:	e9e10000 	lwi	r15, r1, 0
    1a10:	ea61001c 	lwi	r19, r1, 28
    1a14:	eac10020 	lwi	r22, r1, 32
    1a18:	eae10024 	lwi	r23, r1, 36
    1a1c:	eb010028 	lwi	r24, r1, 40
    1a20:	b60f0008 	rtsd	r15, 8
    1a24:	3021002c 	addik	r1, r1, 44

00001a28 <buffer_free>:

void buffer_free(Buffer* buf) {
    1a28:	3021ffe0 	addik	r1, r1, -32
    1a2c:	f9e10000 	swi	r15, r1, 0
    1a30:	fa61001c 	swi	r19, r1, 28
    1a34:	12650000 	addk	r19, r5, r0
  free(buf->data);
    1a38:	b0000000 	imm	0
    1a3c:	b9f43528 	brlid	r15, 13608	// 4f64 <free>
    1a40:	e8a50000 	lwi	r5, r5, 0
  free(buf);
    1a44:	b0000000 	imm	0
    1a48:	b9f4351c 	brlid	r15, 13596	// 4f64 <free>
    1a4c:	10b30000 	addk	r5, r19, r0
}
    1a50:	e9e10000 	lwi	r15, r1, 0
    1a54:	ea61001c 	lwi	r19, r1, 28
    1a58:	b60f0008 	rtsd	r15, 8
    1a5c:	30210020 	addik	r1, r1, 32

00001a60 <buffer_resize>:

void buffer_resize(Buffer* buf, uint32_t size) {
    1a60:	3021ffdc 	addik	r1, r1, -36
    1a64:	f9e10000 	swi	r15, r1, 0
    1a68:	fa61001c 	swi	r19, r1, 28
    1a6c:	fac10020 	swi	r22, r1, 32
    1a70:	12650000 	addk	r19, r5, r0
  buf->data = realloc(buf->data, size * sizeof(uint32_t));
    1a74:	e8a50000 	lwi	r5, r5, 0
void buffer_free(Buffer* buf) {
  free(buf->data);
  free(buf);
}

void buffer_resize(Buffer* buf, uint32_t size) {
    1a78:	12c60000 	addk	r22, r6, r0
  buf->data = realloc(buf->data, size * sizeof(uint32_t));
    1a7c:	b0000000 	imm	0
    1a80:	b9f45114 	brlid	r15, 20756	// 6b94 <realloc>
    1a84:	60c60004 	muli	r6, r6, 4
    1a88:	f8730000 	swi	r3, r19, 0
  buf->size = size;
    1a8c:	fad30004 	swi	r22, r19, 4
}
    1a90:	e9e10000 	lwi	r15, r1, 0
    1a94:	ea61001c 	lwi	r19, r1, 28
    1a98:	eac10020 	lwi	r22, r1, 32
    1a9c:	b60f0008 	rtsd	r15, 8
    1aa0:	30210024 	addik	r1, r1, 36

00001aa4 <bytebuffer_ctor>:

#include <stdlib.h>
#include <string.h>
#include <unistd.h>

ByteBuffer bytebuffer_ctor(const unsigned char* data, size_t n) {
    1aa4:	3021ffd4 	addik	r1, r1, -44
    1aa8:	fa610020 	swi	r19, r1, 32
    1aac:	fac10024 	swi	r22, r1, 36
    1ab0:	fae10028 	swi	r23, r1, 40
    1ab4:	f9e10000 	swi	r15, r1, 0
    1ab8:	12670000 	addk	r19, r7, r0
    1abc:	12c50000 	addk	r22, r5, r0
  ByteBuffer output;
  output.bufsize = n;
  output.buf = NULL;
  if (n) {
    1ac0:	be070034 	beqid	r7, 52		// 1af4
    1ac4:	12e70000 	addk	r23, r7, r0
    if (data != NULL) {
    1ac8:	be060050 	beqid	r6, 80		// 1b18
    1acc:	10a70000 	addk	r5, r7, r0
      output.buf = malloc(n);
    1ad0:	b0000000 	imm	0
    1ad4:	b9f43464 	brlid	r15, 13412	// 4f38 <malloc>
    1ad8:	f8c1001c 	swi	r6, r1, 28
      memcpy(output.buf, data, n);
    1adc:	10a30000 	addk	r5, r3, r0
    1ae0:	e8c1001c 	lwi	r6, r1, 28
    1ae4:	10f30000 	addk	r7, r19, r0
    1ae8:	b0000000 	imm	0
    1aec:	b9f4402c 	brlid	r15, 16428	// 5b18 <memcpy>
    1af0:	12e30000 	addk	r23, r3, r0
    } else {
      output.buf = calloc(n, 1);
    }
  }
  return output;
    1af4:	fa760000 	swi	r19, r22, 0
    1af8:	faf60004 	swi	r23, r22, 4
}
    1afc:	10760000 	addk	r3, r22, r0
    1b00:	e9e10000 	lwi	r15, r1, 0
    1b04:	ea610020 	lwi	r19, r1, 32
    1b08:	eac10024 	lwi	r22, r1, 36
    1b0c:	eae10028 	lwi	r23, r1, 40
    1b10:	b60f0008 	rtsd	r15, 8
    1b14:	3021002c 	addik	r1, r1, 44
  if (n) {
    if (data != NULL) {
      output.buf = malloc(n);
      memcpy(output.buf, data, n);
    } else {
      output.buf = calloc(n, 1);
    1b18:	b0000000 	imm	0
    1b1c:	b9f43284 	brlid	r15, 12932	// 4da0 <calloc>
    1b20:	30c00001 	addik	r6, r0, 1
    1b24:	b810ffd0 	brid	-48		// 1af4
    1b28:	12e30000 	addk	r23, r3, r0

00001b2c <bytebuffer_free>:
    }
  }
  return output;
}

void bytebuffer_free(ByteBuffer* buffer) {
    1b2c:	3021ffe0 	addik	r1, r1, -32
    1b30:	f9e10000 	swi	r15, r1, 0
    1b34:	fa61001c 	swi	r19, r1, 28
    1b38:	12650000 	addk	r19, r5, r0
  free(buffer->buf);
    1b3c:	b0000000 	imm	0
    1b40:	b9f43424 	brlid	r15, 13348	// 4f64 <free>
    1b44:	e8a50004 	lwi	r5, r5, 4
  buffer->bufsize = 0;
    1b48:	f8130000 	swi	r0, r19, 0
  buffer->buf = NULL;
    1b4c:	f8130004 	swi	r0, r19, 4
}
    1b50:	e9e10000 	lwi	r15, r1, 0
    1b54:	ea61001c 	lwi	r19, r1, 28
    1b58:	b60f0008 	rtsd	r15, 8
    1b5c:	30210020 	addik	r1, r1, 32

00001b60 <bytebuffer_reserve_back>:

void bytebuffer_reserve_back(ByteBuffer* buffer, size_t n) {
    1b60:	3021ffdc 	addik	r1, r1, -36
    1b64:	f9e10000 	swi	r15, r1, 0
    1b68:	fa61001c 	swi	r19, r1, 28
    1b6c:	fac10020 	swi	r22, r1, 32
    1b70:	12c60000 	addk	r22, r6, r0
  // From: http://www.cplusplus.com/reference/cstdlib/realloc/
  // "Alternatively, this can be a null pointer, in which case a new block is
  // allocated (as if malloc was called)."
  buffer->buf = realloc(buffer->buf, buffer->bufsize + n);
    1b74:	e8c50000 	lwi	r6, r5, 0
  free(buffer->buf);
  buffer->bufsize = 0;
  buffer->buf = NULL;
}

void bytebuffer_reserve_back(ByteBuffer* buffer, size_t n) {
    1b78:	12650000 	addk	r19, r5, r0
  // From: http://www.cplusplus.com/reference/cstdlib/realloc/
  // "Alternatively, this can be a null pointer, in which case a new block is
  // allocated (as if malloc was called)."
  buffer->buf = realloc(buffer->buf, buffer->bufsize + n);
    1b7c:	e8a50004 	lwi	r5, r5, 4
    1b80:	b0000000 	imm	0
    1b84:	b9f45010 	brlid	r15, 20496	// 6b94 <realloc>
    1b88:	10d63000 	addk	r6, r22, r6
  buffer->bufsize += n;
    1b8c:	e8930000 	lwi	r4, r19, 0

void bytebuffer_reserve_back(ByteBuffer* buffer, size_t n) {
  // From: http://www.cplusplus.com/reference/cstdlib/realloc/
  // "Alternatively, this can be a null pointer, in which case a new block is
  // allocated (as if malloc was called)."
  buffer->buf = realloc(buffer->buf, buffer->bufsize + n);
    1b90:	f8730004 	swi	r3, r19, 4
  buffer->bufsize += n;
    1b94:	12c4b000 	addk	r22, r4, r22
    1b98:	fad30000 	swi	r22, r19, 0
}
    1b9c:	e9e10000 	lwi	r15, r1, 0
    1ba0:	ea61001c 	lwi	r19, r1, 28
    1ba4:	eac10020 	lwi	r22, r1, 32
    1ba8:	b60f0008 	rtsd	r15, 8
    1bac:	30210024 	addik	r1, r1, 36

00001bb0 <bytebuffer_append>:

void bytebuffer_append(ByteBuffer* buffer, const unsigned char* data, size_t n) {
    1bb0:	3021ffd4 	addik	r1, r1, -44
    1bb4:	fa610020 	swi	r19, r1, 32
    1bb8:	12660000 	addk	r19, r6, r0
  size_t original_size = buffer->bufsize;
  bytebuffer_reserve_back(buffer, n);
    1bbc:	10c70000 	addk	r6, r7, r0
  // allocated (as if malloc was called)."
  buffer->buf = realloc(buffer->buf, buffer->bufsize + n);
  buffer->bufsize += n;
}

void bytebuffer_append(ByteBuffer* buffer, const unsigned char* data, size_t n) {
    1bc0:	fac10024 	swi	r22, r1, 36
    1bc4:	12c50000 	addk	r22, r5, r0
    1bc8:	f9e10000 	swi	r15, r1, 0
    1bcc:	fae10028 	swi	r23, r1, 40
  size_t original_size = buffer->bufsize;
    1bd0:	eae50000 	lwi	r23, r5, 0
  bytebuffer_reserve_back(buffer, n);
    1bd4:	b9f4ff8c 	brlid	r15, -116	// 1b60 <bytebuffer_reserve_back>
    1bd8:	f8e1001c 	swi	r7, r1, 28
  if (data != NULL) {
    memcpy(buffer->buf + original_size, data, n);
    1bdc:	e8b60004 	lwi	r5, r22, 4
}

void bytebuffer_append(ByteBuffer* buffer, const unsigned char* data, size_t n) {
  size_t original_size = buffer->bufsize;
  bytebuffer_reserve_back(buffer, n);
  if (data != NULL) {
    1be0:	e8e1001c 	lwi	r7, r1, 28
    memcpy(buffer->buf + original_size, data, n);
    1be4:	10d30000 	addk	r6, r19, r0
}

void bytebuffer_append(ByteBuffer* buffer, const unsigned char* data, size_t n) {
  size_t original_size = buffer->bufsize;
  bytebuffer_reserve_back(buffer, n);
  if (data != NULL) {
    1be8:	be13002c 	beqid	r19, 44		// 1c14
    1bec:	10a5b800 	addk	r5, r5, r23
    memcpy(buffer->buf + original_size, data, n);
    1bf0:	b0000000 	imm	0
    1bf4:	b9f43f24 	brlid	r15, 16164	// 5b18 <memcpy>
    1bf8:	80000000 	or	r0, r0, r0
  } else {
    memset(buffer->buf + original_size, 0, n);
  }
}
    1bfc:	e9e10000 	lwi	r15, r1, 0
    1c00:	ea610020 	lwi	r19, r1, 32
    1c04:	eac10024 	lwi	r22, r1, 36
    1c08:	eae10028 	lwi	r23, r1, 40
    1c0c:	b60f0008 	rtsd	r15, 8
    1c10:	3021002c 	addik	r1, r1, 44
  size_t original_size = buffer->bufsize;
  bytebuffer_reserve_back(buffer, n);
  if (data != NULL) {
    memcpy(buffer->buf + original_size, data, n);
  } else {
    memset(buffer->buf + original_size, 0, n);
    1c14:	b0000000 	imm	0
    1c18:	b9f443dc 	brlid	r15, 17372	// 5ff4 <memset>
    1c1c:	80000000 	or	r0, r0, r0
  }
}
    1c20:	e9e10000 	lwi	r15, r1, 0
    1c24:	ea610020 	lwi	r19, r1, 32
    1c28:	eac10024 	lwi	r22, r1, 36
    1c2c:	eae10028 	lwi	r23, r1, 40
    1c30:	b60f0008 	rtsd	r15, 8
    1c34:	3021002c 	addik	r1, r1, 44

00001c38 <bytebuffer_del_back>:

void bytebuffer_del_back(ByteBuffer* buffer, size_t n) {
    1c38:	3021ffe0 	addik	r1, r1, -32
    1c3c:	fa61001c 	swi	r19, r1, 28
    1c40:	f9e10000 	swi	r15, r1, 0
  if (n >= buffer->bufsize) {
    1c44:	e8650000 	lwi	r3, r5, 0
    1c48:	14833003 	cmpu	r4, r3, r6
    1c4c:	bea40034 	bgeid	r4, 52		// 1c80
    1c50:	12650000 	addk	r19, r5, r0
    bytebuffer_free(buffer);
  } else {
    buffer->bufsize -= n;
    1c54:	14661800 	rsubk	r3, r6, r3
    buffer->buf = realloc(buffer->buf, buffer->bufsize);
    1c58:	e8a50004 	lwi	r5, r5, 4
    1c5c:	10c30000 	addk	r6, r3, r0
    1c60:	b0000000 	imm	0
    1c64:	b9f44f30 	brlid	r15, 20272	// 6b94 <realloc>
    1c68:	f8730000 	swi	r3, r19, 0
    1c6c:	f8730004 	swi	r3, r19, 4
  }
}
    1c70:	e9e10000 	lwi	r15, r1, 0
    1c74:	ea61001c 	lwi	r19, r1, 28
    1c78:	b60f0008 	rtsd	r15, 8
    1c7c:	30210020 	addik	r1, r1, 32
  }
}

void bytebuffer_del_back(ByteBuffer* buffer, size_t n) {
  if (n >= buffer->bufsize) {
    bytebuffer_free(buffer);
    1c80:	b9f4feac 	brlid	r15, -340	// 1b2c <bytebuffer_free>
    1c84:	80000000 	or	r0, r0, r0
  } else {
    buffer->bufsize -= n;
    buffer->buf = realloc(buffer->buf, buffer->bufsize);
  }
}
    1c88:	e9e10000 	lwi	r15, r1, 0
    1c8c:	ea61001c 	lwi	r19, r1, 28
    1c90:	b60f0008 	rtsd	r15, 8
    1c94:	30210020 	addik	r1, r1, 32

00001c98 <bytebuffer_del_front>:

void bytebuffer_del_front(ByteBuffer* buffer, size_t n) {
    1c98:	3021ffdc 	addik	r1, r1, -36
    1c9c:	fa61001c 	swi	r19, r1, 28
    1ca0:	fac10020 	swi	r22, r1, 32
    1ca4:	f9e10000 	swi	r15, r1, 0
  if (n >= buffer->bufsize) {
    1ca8:	e8e50000 	lwi	r7, r5, 0
    buffer->bufsize -= n;
    buffer->buf = realloc(buffer->buf, buffer->bufsize);
  }
}

void bytebuffer_del_front(ByteBuffer* buffer, size_t n) {
    1cac:	12c50000 	addk	r22, r5, r0
  if (n >= buffer->bufsize) {
    1cb0:	14673003 	cmpu	r3, r7, r6
    1cb4:	bea3003c 	bgeid	r3, 60		// 1cf0
    1cb8:	12660000 	addk	r19, r6, r0
    bytebuffer_free(buffer);
  } else {
    // shift original data back to front of buffer
    memmove(buffer->buf, buffer->buf + n, buffer->bufsize - n);
    1cbc:	e8a50004 	lwi	r5, r5, 4
    1cc0:	14e63800 	rsubk	r7, r6, r7
    1cc4:	b0000000 	imm	0
    1cc8:	b9f44090 	brlid	r15, 16528	// 5d58 <memmove>
    1ccc:	10c53000 	addk	r6, r5, r6
    bytebuffer_del_back(buffer, n);
    1cd0:	10b60000 	addk	r5, r22, r0
    1cd4:	b9f4ff64 	brlid	r15, -156	// 1c38 <bytebuffer_del_back>
    1cd8:	10d30000 	addk	r6, r19, r0
  }
}
    1cdc:	e9e10000 	lwi	r15, r1, 0
    1ce0:	ea61001c 	lwi	r19, r1, 28
    1ce4:	eac10020 	lwi	r22, r1, 32
    1ce8:	b60f0008 	rtsd	r15, 8
    1cec:	30210024 	addik	r1, r1, 36
  }
}

void bytebuffer_del_front(ByteBuffer* buffer, size_t n) {
  if (n >= buffer->bufsize) {
    bytebuffer_free(buffer);
    1cf0:	b9f4fe3c 	brlid	r15, -452	// 1b2c <bytebuffer_free>
    1cf4:	80000000 	or	r0, r0, r0
  } else {
    // shift original data back to front of buffer
    memmove(buffer->buf, buffer->buf + n, buffer->bufsize - n);
    bytebuffer_del_back(buffer, n);
  }
}
    1cf8:	e9e10000 	lwi	r15, r1, 0
    1cfc:	ea61001c 	lwi	r19, r1, 28
    1d00:	eac10020 	lwi	r22, r1, 32
    1d04:	b60f0008 	rtsd	r15, 8
    1d08:	30210024 	addik	r1, r1, 36

00001d0c <bytebuffer_pop>:

ByteBuffer bytebuffer_pop(ByteBuffer* buffer, size_t n) {
    1d0c:	3021ffd4 	addik	r1, r1, -44
    1d10:	fa61001c 	swi	r19, r1, 28
    1d14:	fac10020 	swi	r22, r1, 32
    1d18:	fae10024 	swi	r23, r1, 36
    1d1c:	f9e10000 	swi	r15, r1, 0
    1d20:	fb010028 	swi	r24, r1, 40
  ByteBuffer output;
  // the requested amount is greater than what we have, pop everything.
  if (n >= buffer->bufsize) {
    1d24:	eb060000 	lwi	r24, r6, 0
    memmove(buffer->buf, buffer->buf + n, buffer->bufsize - n);
    bytebuffer_del_back(buffer, n);
  }
}

ByteBuffer bytebuffer_pop(ByteBuffer* buffer, size_t n) {
    1d28:	12e60000 	addk	r23, r6, r0
    1d2c:	12c70000 	addk	r22, r7, r0
  ByteBuffer output;
  // the requested amount is greater than what we have, pop everything.
  if (n >= buffer->bufsize) {
    1d30:	14783803 	cmpu	r3, r24, r7
    1d34:	bea30060 	bgeid	r3, 96		// 1d94
    1d38:	12650000 	addk	r19, r5, r0
    output.buf = malloc(buffer->bufsize);
    memcpy(output.buf, buffer->buf, buffer->bufsize);
    bytebuffer_free(buffer);
    return output;
  }
  output.buf = malloc(n);
    1d3c:	b0000000 	imm	0
    1d40:	b9f431f8 	brlid	r15, 12792	// 4f38 <malloc>
    1d44:	10a70000 	addk	r5, r7, r0
  output.bufsize = n;
  memcpy(output.buf, buffer->buf, n);
    1d48:	10f60000 	addk	r7, r22, r0
    1d4c:	e8d70004 	lwi	r6, r23, 4
    1d50:	10a30000 	addk	r5, r3, r0
    1d54:	b0000000 	imm	0
    1d58:	b9f43dc0 	brlid	r15, 15808	// 5b18 <memcpy>
    1d5c:	13030000 	addk	r24, r3, r0
  bytebuffer_del_front(buffer, n);
    1d60:	10b70000 	addk	r5, r23, r0
    1d64:	b9f4ff34 	brlid	r15, -204	// 1c98 <bytebuffer_del_front>
    1d68:	10d60000 	addk	r6, r22, r0
  return output;
    1d6c:	fad30000 	swi	r22, r19, 0
    1d70:	fb130004 	swi	r24, r19, 4
}
    1d74:	10730000 	addk	r3, r19, r0
    1d78:	e9e10000 	lwi	r15, r1, 0
    1d7c:	ea61001c 	lwi	r19, r1, 28
    1d80:	eac10020 	lwi	r22, r1, 32
    1d84:	eae10024 	lwi	r23, r1, 36
    1d88:	eb010028 	lwi	r24, r1, 40
    1d8c:	b60f0008 	rtsd	r15, 8
    1d90:	3021002c 	addik	r1, r1, 44
ByteBuffer bytebuffer_pop(ByteBuffer* buffer, size_t n) {
  ByteBuffer output;
  // the requested amount is greater than what we have, pop everything.
  if (n >= buffer->bufsize) {
    output.bufsize = buffer->bufsize;
    output.buf = malloc(buffer->bufsize);
    1d94:	b0000000 	imm	0
    1d98:	b9f431a0 	brlid	r15, 12704	// 4f38 <malloc>
    1d9c:	10b80000 	addk	r5, r24, r0
    memcpy(output.buf, buffer->buf, buffer->bufsize);
    1da0:	e8d70004 	lwi	r6, r23, 4
    1da4:	10f80000 	addk	r7, r24, r0
    1da8:	10a30000 	addk	r5, r3, r0
    1dac:	b0000000 	imm	0
    1db0:	b9f43d68 	brlid	r15, 15720	// 5b18 <memcpy>
    1db4:	12c30000 	addk	r22, r3, r0
    bytebuffer_free(buffer);
    1db8:	b9f4fd74 	brlid	r15, -652	// 1b2c <bytebuffer_free>
    1dbc:	10b70000 	addk	r5, r23, r0
    return output;
    1dc0:	fb130000 	swi	r24, r19, 0
    1dc4:	fad30004 	swi	r22, r19, 4
  output.buf = malloc(n);
  output.bufsize = n;
  memcpy(output.buf, buffer->buf, n);
  bytebuffer_del_front(buffer, n);
  return output;
}
    1dc8:	10730000 	addk	r3, r19, r0
    1dcc:	e9e10000 	lwi	r15, r1, 0
    1dd0:	ea61001c 	lwi	r19, r1, 28
    1dd4:	eac10020 	lwi	r22, r1, 32
    1dd8:	eae10024 	lwi	r23, r1, 36
    1ddc:	eb010028 	lwi	r24, r1, 40
    1de0:	b60f0008 	rtsd	r15, 8
    1de4:	3021002c 	addik	r1, r1, 44

00001de8 <bytebuffer_read_fd>:

ssize_t bytebuffer_read_fd(ByteBuffer* buffer, int fd, size_t n) {
    1de8:	3021ffd0 	addik	r1, r1, -48
    1dec:	fb01002c 	swi	r24, r1, 44
    1df0:	13060000 	addk	r24, r6, r0
  size_t original_size = buffer->bufsize;
  bytebuffer_reserve_back(buffer, n);
    1df4:	10c70000 	addk	r6, r7, r0
  memcpy(output.buf, buffer->buf, n);
  bytebuffer_del_front(buffer, n);
  return output;
}

ssize_t bytebuffer_read_fd(ByteBuffer* buffer, int fd, size_t n) {
    1df8:	fa610020 	swi	r19, r1, 32
    1dfc:	12650000 	addk	r19, r5, r0
    1e00:	f9e10000 	swi	r15, r1, 0
    1e04:	fac10024 	swi	r22, r1, 36
    1e08:	fae10028 	swi	r23, r1, 40
    1e0c:	12c70000 	addk	r22, r7, r0
  size_t original_size = buffer->bufsize;
  bytebuffer_reserve_back(buffer, n);
    1e10:	b9f4fd50 	brlid	r15, -688	// 1b60 <bytebuffer_reserve_back>
    1e14:	eae50000 	lwi	r23, r5, 0
  ssize_t bytes_read = read(fd, &(buffer->buf[original_size]), n);
    1e18:	e8d30004 	lwi	r6, r19, 4
    1e1c:	10f60000 	addk	r7, r22, r0
    1e20:	10b80000 	addk	r5, r24, r0
    1e24:	b0000000 	imm	0
    1e28:	b9f41788 	brlid	r15, 6024	// 35b0 <read>
    1e2c:	10c6b800 	addk	r6, r6, r23
  // unallocate any leftover room at the end of the buffer
  bytebuffer_del_back(buffer, n - bytes_read);
    1e30:	10b30000 	addk	r5, r19, r0
    1e34:	14c3b000 	rsubk	r6, r3, r22
    1e38:	b9f4fe00 	brlid	r15, -512	// 1c38 <bytebuffer_del_back>
    1e3c:	f861001c 	swi	r3, r1, 28
  return bytes_read;
}
    1e40:	e861001c 	lwi	r3, r1, 28
    1e44:	e9e10000 	lwi	r15, r1, 0
    1e48:	ea610020 	lwi	r19, r1, 32
    1e4c:	eac10024 	lwi	r22, r1, 36
    1e50:	eae10028 	lwi	r23, r1, 40
    1e54:	eb01002c 	lwi	r24, r1, 44
    1e58:	b60f0008 	rtsd	r15, 8
    1e5c:	30210030 	addik	r1, r1, 48

00001e60 <cbuffer_new>:
#ifndef max
#define max(a,b) (((a) (b)) ? (a) : (b))
#define min(a,b) (((a) < (b)) ? (a) : (b))
#endif

CircularBuffer* cbuffer_new(void) {
    1e60:	3021ffe0 	addik	r1, r1, -32
  CircularBuffer* output = malloc(sizeof(CircularBuffer));
    1e64:	30a0000c 	addik	r5, r0, 12
#ifndef max
#define max(a,b) (((a) (b)) ? (a) : (b))
#define min(a,b) (((a) < (b)) ? (a) : (b))
#endif

CircularBuffer* cbuffer_new(void) {
    1e68:	f9e10000 	swi	r15, r1, 0
  CircularBuffer* output = malloc(sizeof(CircularBuffer));
    1e6c:	b0000000 	imm	0
    1e70:	b9f430c8 	brlid	r15, 12488	// 4f38 <malloc>
    1e74:	fa61001c 	swi	r19, r1, 28
    1e78:	12630000 	addk	r19, r3, r0
  output->data = malloc(IO_BUFFER_SIZE * sizeof(uint32_t));
    1e7c:	b0000000 	imm	0
    1e80:	b9f430b8 	brlid	r15, 12472	// 4f38 <malloc>
    1e84:	30a00100 	addik	r5, r0, 256
    1e88:	f8730000 	swi	r3, r19, 0
  output->tail = 0;
    1e8c:	f8130004 	swi	r0, r19, 4
  output->pos = 0;
  return output;
}
    1e90:	10730000 	addk	r3, r19, r0

CircularBuffer* cbuffer_new(void) {
  CircularBuffer* output = malloc(sizeof(CircularBuffer));
  output->data = malloc(IO_BUFFER_SIZE * sizeof(uint32_t));
  output->tail = 0;
  output->pos = 0;
    1e94:	f8130008 	swi	r0, r19, 8
  return output;
}
    1e98:	e9e10000 	lwi	r15, r1, 0
    1e9c:	ea61001c 	lwi	r19, r1, 28
    1ea0:	b60f0008 	rtsd	r15, 8
    1ea4:	30210020 	addik	r1, r1, 32

00001ea8 <cbuffer_copy>:

CircularBuffer* cbuffer_copy(CircularBuffer* from) {
    1ea8:	3021ffdc 	addik	r1, r1, -36
    1eac:	fac10020 	swi	r22, r1, 32
    1eb0:	12c50000 	addk	r22, r5, r0
  CircularBuffer* output = malloc(sizeof(CircularBuffer));
    1eb4:	30a0000c 	addik	r5, r0, 12
  output->tail = 0;
  output->pos = 0;
  return output;
}

CircularBuffer* cbuffer_copy(CircularBuffer* from) {
    1eb8:	f9e10000 	swi	r15, r1, 0
  CircularBuffer* output = malloc(sizeof(CircularBuffer));
    1ebc:	b0000000 	imm	0
    1ec0:	b9f43078 	brlid	r15, 12408	// 4f38 <malloc>
    1ec4:	fa61001c 	swi	r19, r1, 28
  output->data = malloc(IO_BUFFER_SIZE * sizeof(uint32_t));
    1ec8:	30a00100 	addik	r5, r0, 256
    1ecc:	b0000000 	imm	0
    1ed0:	b9f43068 	brlid	r15, 12392	// 4f38 <malloc>
    1ed4:	12630000 	addk	r19, r3, r0
  memcpy(output->data, from->data, IO_BUFFER_SIZE * sizeof(uint32_t));
    1ed8:	e8d60000 	lwi	r6, r22, 0
    1edc:	10a30000 	addk	r5, r3, r0
    1ee0:	30e00100 	addik	r7, r0, 256
    1ee4:	b0000000 	imm	0
    1ee8:	b9f43c30 	brlid	r15, 15408	// 5b18 <memcpy>
    1eec:	f8730000 	swi	r3, r19, 0
  output->tail = from->tail;
    1ef0:	e8960004 	lwi	r4, r22, 4
  output->pos = from->pos;
    1ef4:	ead60008 	lwi	r22, r22, 8
  return output;
}
    1ef8:	10730000 	addk	r3, r19, r0

CircularBuffer* cbuffer_copy(CircularBuffer* from) {
  CircularBuffer* output = malloc(sizeof(CircularBuffer));
  output->data = malloc(IO_BUFFER_SIZE * sizeof(uint32_t));
  memcpy(output->data, from->data, IO_BUFFER_SIZE * sizeof(uint32_t));
  output->tail = from->tail;
    1efc:	f8930004 	swi	r4, r19, 4
  output->pos = from->pos;
    1f00:	fad30008 	swi	r22, r19, 8
  return output;
}
    1f04:	e9e10000 	lwi	r15, r1, 0
    1f08:	ea61001c 	lwi	r19, r1, 28
    1f0c:	eac10020 	lwi	r22, r1, 32
    1f10:	b60f0008 	rtsd	r15, 8
    1f14:	30210024 	addik	r1, r1, 36

00001f18 <cbuffer_size>:

uint32_t cbuffer_size(const CircularBuffer* buffer) {
  if (buffer->pos <= buffer->tail) 
    1f18:	e8650008 	lwi	r3, r5, 8
    1f1c:	e8850004 	lwi	r4, r5, 4
    1f20:	14a32003 	cmpu	r5, r3, r4
    1f24:	bca50010 	bgei	r5, 16		// 1f34
    return buffer->tail - buffer->pos;
  return buffer->tail + IO_BUFFER_SIZE - buffer->pos;
    1f28:	30840040 	addik	r4, r4, 64
}
    1f2c:	b60f0008 	rtsd	r15, 8
    1f30:	14632000 	rsubk	r3, r3, r4
  return output;
}

uint32_t cbuffer_size(const CircularBuffer* buffer) {
  if (buffer->pos <= buffer->tail) 
    return buffer->tail - buffer->pos;
    1f34:	b60f0008 	rtsd	r15, 8
    1f38:	14632000 	rsubk	r3, r3, r4

00001f3c <cbuffer_contiguous_data_size>:
  return buffer->tail + IO_BUFFER_SIZE - buffer->pos;
}

uint32_t cbuffer_contiguous_data_size(const CircularBuffer* buffer) {
  if (buffer->pos <= buffer->tail) 
    1f3c:	e8850008 	lwi	r4, r5, 8
    1f40:	e8a50004 	lwi	r5, r5, 4
    return buffer->tail - buffer->pos;
  return IO_BUFFER_SIZE - buffer->pos;
    1f44:	30c00040 	addik	r6, r0, 64
    1f48:	14643000 	rsubk	r3, r4, r6
    return buffer->tail - buffer->pos;
  return buffer->tail + IO_BUFFER_SIZE - buffer->pos;
}

uint32_t cbuffer_contiguous_data_size(const CircularBuffer* buffer) {
  if (buffer->pos <= buffer->tail) 
    1f4c:	14c42803 	cmpu	r6, r4, r5
    1f50:	bca6000c 	bgei	r6, 12		// 1f5c
    return buffer->tail - buffer->pos;
  return IO_BUFFER_SIZE - buffer->pos;
}
    1f54:	b60f0008 	rtsd	r15, 8
    1f58:	80000000 	or	r0, r0, r0
    1f5c:	b60f0008 	rtsd	r15, 8
    1f60:	14642800 	rsubk	r3, r4, r5

00001f64 <cbuffer_free>:

void cbuffer_free(CircularBuffer* tokill) {
    1f64:	3021ffe0 	addik	r1, r1, -32
    1f68:	f9e10000 	swi	r15, r1, 0
    1f6c:	fa61001c 	swi	r19, r1, 28
    1f70:	12650000 	addk	r19, r5, r0
  free(tokill->data);
    1f74:	b0000000 	imm	0
    1f78:	b9f42fec 	brlid	r15, 12268	// 4f64 <free>
    1f7c:	e8a50000 	lwi	r5, r5, 0
  free(tokill);
    1f80:	b0000000 	imm	0
    1f84:	b9f42fe0 	brlid	r15, 12256	// 4f64 <free>
    1f88:	10b30000 	addk	r5, r19, r0
}
    1f8c:	e9e10000 	lwi	r15, r1, 0
    1f90:	ea61001c 	lwi	r19, r1, 28
    1f94:	b60f0008 	rtsd	r15, 8
    1f98:	30210020 	addik	r1, r1, 32

00001f9c <cbuffer_value_at>:

uint32_t cbuffer_value_at(const CircularBuffer* buf, uint32_t idx) {
  uint32_t actual_idx = (buf->pos + idx) % IO_BUFFER_SIZE;
    1f9c:	e8850008 	lwi	r4, r5, 8
  return buf->data[actual_idx];
    1fa0:	e8650000 	lwi	r3, r5, 0
  free(tokill->data);
  free(tokill);
}

uint32_t cbuffer_value_at(const CircularBuffer* buf, uint32_t idx) {
  uint32_t actual_idx = (buf->pos + idx) % IO_BUFFER_SIZE;
    1fa4:	10c62000 	addk	r6, r6, r4
    1fa8:	a4c6003f 	andi	r6, r6, 63
  return buf->data[actual_idx];
    1fac:	60c60004 	muli	r6, r6, 4
}
    1fb0:	b60f0008 	rtsd	r15, 8
    1fb4:	c8661800 	lw	r3, r6, r3

00001fb8 <cbuffer_value_at_net>:
  free(tokill->data);
  free(tokill);
}

uint32_t cbuffer_value_at(const CircularBuffer* buf, uint32_t idx) {
  uint32_t actual_idx = (buf->pos + idx) % IO_BUFFER_SIZE;
    1fb8:	e8850008 	lwi	r4, r5, 8
  return buf->data[actual_idx];
    1fbc:	e8650000 	lwi	r3, r5, 0
  free(tokill->data);
  free(tokill);
}

uint32_t cbuffer_value_at(const CircularBuffer* buf, uint32_t idx) {
  uint32_t actual_idx = (buf->pos + idx) % IO_BUFFER_SIZE;
    1fc0:	10c62000 	addk	r6, r6, r4
    1fc4:	a4c6003f 	andi	r6, r6, 63
  return buf->data[actual_idx];
    1fc8:	60c60004 	muli	r6, r6, 4
    1fcc:	c8661800 	lw	r3, r6, r3
}

uint32_t cbuffer_value_at_net(const CircularBuffer* buf, uint32_t idx) {
  return network_to_host(cbuffer_value_at(buf, idx));
    1fd0:	b0000000 	imm	0
    1fd4:	a4a3ffff 	andi	r5, r3, -1
    1fd8:	10801800 	addk	r4, r0, r3
    1fdc:	90830041 	srl	r4, r3
    1fe0:	90840041 	srl	r4, r4
    1fe4:	90840041 	srl	r4, r4
    1fe8:	90840041 	srl	r4, r4
    1fec:	90840041 	srl	r4, r4
    1ff0:	90840041 	srl	r4, r4
    1ff4:	90840041 	srl	r4, r4
    1ff8:	90840041 	srl	r4, r4
    1ffc:	90840041 	srl	r4, r4
    2000:	90840041 	srl	r4, r4
    2004:	90840041 	srl	r4, r4
    2008:	90840041 	srl	r4, r4
    200c:	90840041 	srl	r4, r4
    2010:	90840041 	srl	r4, r4
    2014:	90840041 	srl	r4, r4
    2018:	90840041 	srl	r4, r4
    201c:	60e50100 	muli	r7, r5, 256
    2020:	60640100 	muli	r3, r4, 256
    2024:	10c02800 	addk	r6, r0, r5
    2028:	90c50041 	srl	r6, r5
    202c:	90c60041 	srl	r6, r6
    2030:	90c60041 	srl	r6, r6
    2034:	90c60041 	srl	r6, r6
    2038:	90c60041 	srl	r6, r6
    203c:	90c60041 	srl	r6, r6
    2040:	90c60041 	srl	r6, r6
    2044:	90c60041 	srl	r6, r6
    2048:	b0000000 	imm	0
    204c:	a463ffff 	andi	r3, r3, -1
    2050:	80c73000 	or	r6, r7, r6
    2054:	10a02000 	addk	r5, r0, r4
    2058:	90a40041 	srl	r5, r4
    205c:	90a50041 	srl	r5, r5
    2060:	90a50041 	srl	r5, r5
    2064:	90a50041 	srl	r5, r5
    2068:	90a50041 	srl	r5, r5
    206c:	90a50041 	srl	r5, r5
    2070:	90a50041 	srl	r5, r5
    2074:	90a50041 	srl	r5, r5
    2078:	b0000001 	imm	1
    207c:	60860000 	muli	r4, r6, 0
    2080:	80632800 	or	r3, r3, r5
}
    2084:	b60f0008 	rtsd	r15, 8
    2088:	80632000 	or	r3, r3, r4

0000208c <cbuffer_freespace>:

uint32_t cbuffer_freespace(const CircularBuffer* buf) {
    208c:	3021ffe4 	addik	r1, r1, -28
    2090:	f9e10000 	swi	r15, r1, 0
  return IO_BUFFER_SIZE - cbuffer_size(buf) - 1;
    2094:	b9f4fe84 	brlid	r15, -380	// 1f18 <cbuffer_size>
    2098:	80000000 	or	r0, r0, r0
}
    209c:	e9e10000 	lwi	r15, r1, 0
    20a0:	3080003f 	addik	r4, r0, 63
    20a4:	14632000 	rsubk	r3, r3, r4
    20a8:	b60f0008 	rtsd	r15, 8
    20ac:	3021001c 	addik	r1, r1, 28

000020b0 <cbuffer_append>:

int cbuffer_append(CircularBuffer* buffer, void* data, uint32_t nwords) {
    20b0:	3021ffd4 	addik	r1, r1, -44
    20b4:	fac10020 	swi	r22, r1, 32
    20b8:	12c70000 	addk	r22, r7, r0
    20bc:	fa61001c 	swi	r19, r1, 28
    20c0:	fb010028 	swi	r24, r1, 40
    20c4:	f9e10000 	swi	r15, r1, 0
    20c8:	fae10024 	swi	r23, r1, 36
    20cc:	12650000 	addk	r19, r5, r0
  uint32_t freespace = cbuffer_freespace(buffer);
    20d0:	b9f4ffbc 	brlid	r15, -68	// 208c <cbuffer_freespace>
    20d4:	13060000 	addk	r24, r6, r0
  if (freespace < nwords) {
    20d8:	14761803 	cmpu	r3, r22, r3
    20dc:	be43005c 	bltid	r3, 92		// 2138
    20e0:	3080ffff 	addik	r4, r0, -1
  }

  // words available on "tail" until we hit the absolute end of the memory.
  // we know from the freespace check that we can't overwrite the head with
  // only <nwords>.
  uint32_t tail_length = IO_BUFFER_SIZE - buffer->tail;
    20e4:	e8b30004 	lwi	r5, r19, 4
    20e8:	30600040 	addik	r3, r0, 64

  memcpy(
    20ec:	e8930000 	lwi	r4, r19, 0
  }

  // words available on "tail" until we hit the absolute end of the memory.
  // we know from the freespace check that we can't overwrite the head with
  // only <nwords>.
  uint32_t tail_length = IO_BUFFER_SIZE - buffer->tail;
    20f0:	16e51800 	rsubk	r23, r5, r3

  memcpy(
      &(buffer->data[buffer->tail]),
      data, 
      sizeof(uint32_t) * min(nwords, tail_length));
    20f4:	1476b803 	cmpu	r3, r22, r23
  // we know from the freespace check that we can't overwrite the head with
  // only <nwords>.
  uint32_t tail_length = IO_BUFFER_SIZE - buffer->tail;

  memcpy(
      &(buffer->data[buffer->tail]),
    20f8:	60a50004 	muli	r5, r5, 4
      data, 
      sizeof(uint32_t) * min(nwords, tail_length));
    20fc:	10f60000 	addk	r7, r22, r0
    2100:	be430078 	bltid	r3, 120		// 2178
    2104:	10a42800 	addk	r5, r4, r5
  // words available on "tail" until we hit the absolute end of the memory.
  // we know from the freespace check that we can't overwrite the head with
  // only <nwords>.
  uint32_t tail_length = IO_BUFFER_SIZE - buffer->tail;

  memcpy(
    2108:	10d80000 	addk	r6, r24, r0
    210c:	b0000000 	imm	0
    2110:	b9f43a08 	brlid	r15, 14856	// 5b18 <memcpy>
    2114:	60e70004 	muli	r7, r7, 4
      &(buffer->data[buffer->tail]),
      data, 
      sizeof(uint32_t) * min(nwords, tail_length));

  // if we didn't write everything, we need to wrap around to the beginning.
  if (tail_length < nwords) {
    2118:	1476b803 	cmpu	r3, r22, r23
    211c:	be43003c 	bltid	r3, 60		// 2158
    2120:	60d70004 	muli	r6, r23, 4
    memcpy(
        buffer->data, 
        data + sizeof(uint32_t) * tail_length,
        sizeof(uint32_t) * (nwords - tail_length));
  }
  buffer->tail = (buffer->tail + nwords) % IO_BUFFER_SIZE;
    2124:	e8730004 	lwi	r3, r19, 4
  return 0;
    2128:	10800000 	addk	r4, r0, r0
    memcpy(
        buffer->data, 
        data + sizeof(uint32_t) * tail_length,
        sizeof(uint32_t) * (nwords - tail_length));
  }
  buffer->tail = (buffer->tail + nwords) % IO_BUFFER_SIZE;
    212c:	12d61800 	addk	r22, r22, r3
    2130:	a6d6003f 	andi	r22, r22, 63
    2134:	fad30004 	swi	r22, r19, 4
  return 0;
}
    2138:	10640000 	addk	r3, r4, r0
    213c:	e9e10000 	lwi	r15, r1, 0
    2140:	ea61001c 	lwi	r19, r1, 28
    2144:	eac10020 	lwi	r22, r1, 32
    2148:	eae10024 	lwi	r23, r1, 36
    214c:	eb010028 	lwi	r24, r1, 40
    2150:	b60f0008 	rtsd	r15, 8
    2154:	3021002c 	addik	r1, r1, 44
      data, 
      sizeof(uint32_t) * min(nwords, tail_length));

  // if we didn't write everything, we need to wrap around to the beginning.
  if (tail_length < nwords) {
    memcpy(
    2158:	e8b30000 	lwi	r5, r19, 0
        buffer->data, 
        data + sizeof(uint32_t) * tail_length,
        sizeof(uint32_t) * (nwords - tail_length));
    215c:	14f7b000 	rsubk	r7, r23, r22
      data, 
      sizeof(uint32_t) * min(nwords, tail_length));

  // if we didn't write everything, we need to wrap around to the beginning.
  if (tail_length < nwords) {
    memcpy(
    2160:	10d83000 	addk	r6, r24, r6
    2164:	b0000000 	imm	0
    2168:	b9f439b0 	brlid	r15, 14768	// 5b18 <memcpy>
    216c:	60e70004 	muli	r7, r7, 4
        buffer->data, 
        data + sizeof(uint32_t) * tail_length,
        sizeof(uint32_t) * (nwords - tail_length));
  }
  buffer->tail = (buffer->tail + nwords) % IO_BUFFER_SIZE;
    2170:	b810ffb8 	brid	-72		// 2128
    2174:	e8730004 	lwi	r3, r19, 4
  uint32_t tail_length = IO_BUFFER_SIZE - buffer->tail;

  memcpy(
      &(buffer->data[buffer->tail]),
      data, 
      sizeof(uint32_t) * min(nwords, tail_length));
    2178:	b810ff90 	brid	-112		// 2108
    217c:	10f70000 	addk	r7, r23, r0

00002180 <cbuffer_push_back>:
  }
  buffer->tail = (buffer->tail + nwords) % IO_BUFFER_SIZE;
  return 0;
}

int cbuffer_push_back(CircularBuffer* buffer, uint32_t data) {
    2180:	3021ffdc 	addik	r1, r1, -36
    2184:	fa61001c 	swi	r19, r1, 28
    2188:	fac10020 	swi	r22, r1, 32
    218c:	f9e10000 	swi	r15, r1, 0
    2190:	12650000 	addk	r19, r5, r0
  uint32_t freespace = cbuffer_freespace(buffer);
    2194:	b9f4fef8 	brlid	r15, -264	// 208c <cbuffer_freespace>
    2198:	12c60000 	addk	r22, r6, r0
  if (freespace < 1) {
    219c:	be03002c 	beqid	r3, 44		// 21c8
    21a0:	3080ffff 	addik	r4, r0, -1
    return -1;
  }
  buffer->data[buffer->tail] = data;
    21a4:	e8730004 	lwi	r3, r19, 4
    21a8:	e8b30000 	lwi	r5, r19, 0
  buffer->tail = ((uint32_t)(buffer->tail + 1)) % IO_BUFFER_SIZE;
  return 0;
    21ac:	10800000 	addk	r4, r0, r0
int cbuffer_push_back(CircularBuffer* buffer, uint32_t data) {
  uint32_t freespace = cbuffer_freespace(buffer);
  if (freespace < 1) {
    return -1;
  }
  buffer->data[buffer->tail] = data;
    21b0:	60630004 	muli	r3, r3, 4
    21b4:	dac32800 	sw	r22, r3, r5
  buffer->tail = ((uint32_t)(buffer->tail + 1)) % IO_BUFFER_SIZE;
    21b8:	e8730004 	lwi	r3, r19, 4
    21bc:	30630001 	addik	r3, r3, 1
    21c0:	a463003f 	andi	r3, r3, 63
    21c4:	f8730004 	swi	r3, r19, 4
  return 0;
}
    21c8:	10640000 	addk	r3, r4, r0
    21cc:	e9e10000 	lwi	r15, r1, 0
    21d0:	ea61001c 	lwi	r19, r1, 28
    21d4:	eac10020 	lwi	r22, r1, 32
    21d8:	b60f0008 	rtsd	r15, 8
    21dc:	30210024 	addik	r1, r1, 36

000021e0 <cbuffer_push_back_net>:

int cbuffer_push_back_net(CircularBuffer* buffer, uint32_t data) {
  return cbuffer_push_back(buffer, host_to_network(data));
    21e0:	b0000000 	imm	0
    21e4:	a486ffff 	andi	r4, r6, -1
    21e8:	61040100 	muli	r8, r4, 256
    21ec:	10603000 	addk	r3, r0, r6
    21f0:	90660041 	srl	r3, r6
    21f4:	90630041 	srl	r3, r3
    21f8:	90630041 	srl	r3, r3
    21fc:	90630041 	srl	r3, r3
    2200:	90630041 	srl	r3, r3
    2204:	90630041 	srl	r3, r3
    2208:	90630041 	srl	r3, r3
    220c:	90630041 	srl	r3, r3
    2210:	90630041 	srl	r3, r3
    2214:	90630041 	srl	r3, r3
    2218:	90630041 	srl	r3, r3
    221c:	90630041 	srl	r3, r3
    2220:	90630041 	srl	r3, r3
    2224:	90630041 	srl	r3, r3
    2228:	90630041 	srl	r3, r3
    222c:	90630041 	srl	r3, r3
    2230:	60c30100 	muli	r6, r3, 256
    2234:	10e02000 	addk	r7, r0, r4
    2238:	90e40041 	srl	r7, r4
    223c:	90e70041 	srl	r7, r7
    2240:	90e70041 	srl	r7, r7
    2244:	90e70041 	srl	r7, r7
    2248:	90e70041 	srl	r7, r7
    224c:	90e70041 	srl	r7, r7
    2250:	90e70041 	srl	r7, r7
    2254:	90e70041 	srl	r7, r7
    2258:	b0000000 	imm	0
    225c:	a4c6ffff 	andi	r6, r6, -1
    2260:	80e83800 	or	r7, r8, r7
    2264:	10801800 	addk	r4, r0, r3
    2268:	90830041 	srl	r4, r3
    226c:	90840041 	srl	r4, r4
    2270:	90840041 	srl	r4, r4
    2274:	90840041 	srl	r4, r4
    2278:	90840041 	srl	r4, r4
    227c:	90840041 	srl	r4, r4
    2280:	90840041 	srl	r4, r4
    2284:	90840041 	srl	r4, r4
    2288:	b0000001 	imm	1
    228c:	60670000 	muli	r3, r7, 0
    2290:	80c62000 	or	r6, r6, r4
  buffer->data[buffer->tail] = data;
  buffer->tail = ((uint32_t)(buffer->tail + 1)) % IO_BUFFER_SIZE;
  return 0;
}

int cbuffer_push_back_net(CircularBuffer* buffer, uint32_t data) {
    2294:	3021ffe4 	addik	r1, r1, -28
    2298:	f9e10000 	swi	r15, r1, 0
  return cbuffer_push_back(buffer, host_to_network(data));
    229c:	b9f4fee4 	brlid	r15, -284	// 2180 <cbuffer_push_back>
    22a0:	80c61800 	or	r6, r6, r3
}
    22a4:	e9e10000 	lwi	r15, r1, 0
    22a8:	b60f0008 	rtsd	r15, 8
    22ac:	3021001c 	addik	r1, r1, 28

000022b0 <cbuffer_read>:

uint32_t cbuffer_read(const CircularBuffer* buffer, uint32_t* output, uint32_t nwords) {
    22b0:	3021ffd0 	addik	r1, r1, -48
    22b4:	fb010028 	swi	r24, r1, 40
    22b8:	13070000 	addk	r24, r7, r0
    22bc:	fa61001c 	swi	r19, r1, 28
    22c0:	fac10020 	swi	r22, r1, 32
    22c4:	fae10024 	swi	r23, r1, 36
    22c8:	f9e10000 	swi	r15, r1, 0
    22cc:	fb21002c 	swi	r25, r1, 44
    22d0:	12c50000 	addk	r22, r5, r0
  uint32_t words_to_read = min(nwords, cbuffer_size(buffer));
    22d4:	b9f4fc44 	brlid	r15, -956	// 1f18 <cbuffer_size>
    22d8:	12e60000 	addk	r23, r6, r0
    22dc:	12630000 	addk	r19, r3, r0
    22e0:	1463c003 	cmpu	r3, r3, r24
    22e4:	bc4300c4 	blti	r3, 196		// 23a8
    return buffer->tail - buffer->pos;
  return buffer->tail + IO_BUFFER_SIZE - buffer->pos;
}

uint32_t cbuffer_contiguous_data_size(const CircularBuffer* buffer) {
  if (buffer->pos <= buffer->tail) 
    22e8:	e8960008 	lwi	r4, r22, 8
    22ec:	e8760004 	lwi	r3, r22, 4
    return buffer->tail - buffer->pos;
  return IO_BUFFER_SIZE - buffer->pos;
    22f0:	30c00040 	addik	r6, r0, 64
    22f4:	14a43000 	rsubk	r5, r4, r6
    return buffer->tail - buffer->pos;
  return buffer->tail + IO_BUFFER_SIZE - buffer->pos;
}

uint32_t cbuffer_contiguous_data_size(const CircularBuffer* buffer) {
  if (buffer->pos <= buffer->tail) 
    22f8:	14c41803 	cmpu	r6, r4, r3
    22fc:	be460010 	bltid	r6, 16		// 230c
    2300:	14a59803 	cmpu	r5, r5, r19
    return buffer->tail - buffer->pos;
    2304:	14a41800 	rsubk	r5, r4, r3
  return cbuffer_push_back(buffer, host_to_network(data));
}

uint32_t cbuffer_read(const CircularBuffer* buffer, uint32_t* output, uint32_t nwords) {
  uint32_t words_to_read = min(nwords, cbuffer_size(buffer));
  uint32_t tail_words_to_read = min(words_to_read, cbuffer_contiguous_data_size(buffer));
    2308:	14a59803 	cmpu	r5, r5, r19
    230c:	be45007c 	bltid	r5, 124		// 2388
    2310:	10b70000 	addk	r5, r23, r0
}

uint32_t cbuffer_contiguous_data_size(const CircularBuffer* buffer) {
  if (buffer->pos <= buffer->tail) 
    return buffer->tail - buffer->pos;
  return IO_BUFFER_SIZE - buffer->pos;
    2314:	30c00040 	addik	r6, r0, 64
    return buffer->tail - buffer->pos;
  return buffer->tail + IO_BUFFER_SIZE - buffer->pos;
}

uint32_t cbuffer_contiguous_data_size(const CircularBuffer* buffer) {
  if (buffer->pos <= buffer->tail) 
    2318:	14a41803 	cmpu	r5, r4, r3
    231c:	be45000c 	bltid	r5, 12		// 2328
    2320:	17043000 	rsubk	r24, r4, r6
    return buffer->tail - buffer->pos;
    2324:	17041800 	rsubk	r24, r4, r3
}

uint32_t cbuffer_read(const CircularBuffer* buffer, uint32_t* output, uint32_t nwords) {
  uint32_t words_to_read = min(nwords, cbuffer_size(buffer));
  uint32_t tail_words_to_read = min(words_to_read, cbuffer_contiguous_data_size(buffer));
  memcpy(
    2328:	e8d60000 	lwi	r6, r22, 0
    232c:	63380004 	muli	r25, r24, 4
    2330:	10b70000 	addk	r5, r23, r0
    2334:	10f90000 	addk	r7, r25, r0
      output,
      &(buffer->data[buffer->pos]),
    2338:	60840004 	muli	r4, r4, 4
}

uint32_t cbuffer_read(const CircularBuffer* buffer, uint32_t* output, uint32_t nwords) {
  uint32_t words_to_read = min(nwords, cbuffer_size(buffer));
  uint32_t tail_words_to_read = min(words_to_read, cbuffer_contiguous_data_size(buffer));
  memcpy(
    233c:	10c62000 	addk	r6, r6, r4
    2340:	b0000000 	imm	0
    2344:	b9f437d4 	brlid	r15, 14292	// 5b18 <memcpy>
    2348:	17189800 	rsubk	r24, r24, r19
      output,
      &(buffer->data[buffer->pos]),
      sizeof(uint32_t) * tail_words_to_read);
  // check if we need to wrap around.
  uint32_t remaining_words_at_head = words_to_read - tail_words_to_read;
  if (remaining_words_at_head) {
    234c:	be180018 	beqid	r24, 24		// 2364
    2350:	10b7c800 	addk	r5, r23, r25
    memcpy(
    2354:	e8d60000 	lwi	r6, r22, 0
    2358:	b0000000 	imm	0
    235c:	b9f437bc 	brlid	r15, 14268	// 5b18 <memcpy>
    2360:	60f80004 	muli	r7, r24, 4
        &(output[tail_words_to_read]), 
        buffer->data, 
        sizeof(uint32_t) * remaining_words_at_head);
  }
  return words_to_read;
}
    2364:	10730000 	addk	r3, r19, r0
    2368:	e9e10000 	lwi	r15, r1, 0
    236c:	ea61001c 	lwi	r19, r1, 28
    2370:	eac10020 	lwi	r22, r1, 32
    2374:	eae10024 	lwi	r23, r1, 36
    2378:	eb010028 	lwi	r24, r1, 40
    237c:	eb21002c 	lwi	r25, r1, 44
    2380:	b60f0008 	rtsd	r15, 8
    2384:	30210030 	addik	r1, r1, 48
}

uint32_t cbuffer_read(const CircularBuffer* buffer, uint32_t* output, uint32_t nwords) {
  uint32_t words_to_read = min(nwords, cbuffer_size(buffer));
  uint32_t tail_words_to_read = min(words_to_read, cbuffer_contiguous_data_size(buffer));
  memcpy(
    2388:	e8d60000 	lwi	r6, r22, 0
      output,
      &(buffer->data[buffer->pos]),
    238c:	60840004 	muli	r4, r4, 4
}

uint32_t cbuffer_read(const CircularBuffer* buffer, uint32_t* output, uint32_t nwords) {
  uint32_t words_to_read = min(nwords, cbuffer_size(buffer));
  uint32_t tail_words_to_read = min(words_to_read, cbuffer_contiguous_data_size(buffer));
  memcpy(
    2390:	10c62000 	addk	r6, r6, r4
    2394:	b0000000 	imm	0
    2398:	b9f43780 	brlid	r15, 14208	// 5b18 <memcpy>
    239c:	60f30004 	muli	r7, r19, 4
        &(output[tail_words_to_read]), 
        buffer->data, 
        sizeof(uint32_t) * remaining_words_at_head);
  }
  return words_to_read;
}
    23a0:	b810ffc8 	brid	-56		// 2368
    23a4:	10730000 	addk	r3, r19, r0
int cbuffer_push_back_net(CircularBuffer* buffer, uint32_t data) {
  return cbuffer_push_back(buffer, host_to_network(data));
}

uint32_t cbuffer_read(const CircularBuffer* buffer, uint32_t* output, uint32_t nwords) {
  uint32_t words_to_read = min(nwords, cbuffer_size(buffer));
    23a8:	b810ff40 	brid	-192		// 22e8
    23ac:	12780000 	addk	r19, r24, r0

000023b0 <cbuffer_deletefront>:
        sizeof(uint32_t) * remaining_words_at_head);
  }
  return words_to_read;
}

uint32_t cbuffer_deletefront(CircularBuffer* buffer, uint32_t nwords) {
    23b0:	3021ffdc 	addik	r1, r1, -36
    23b4:	fac10020 	swi	r22, r1, 32
    23b8:	12c60000 	addk	r22, r6, r0
    23bc:	fa61001c 	swi	r19, r1, 28
    23c0:	f9e10000 	swi	r15, r1, 0
  uint32_t words_to_delete = min(nwords, cbuffer_size(buffer));
    23c4:	b9f4fb54 	brlid	r15, -1196	// 1f18 <cbuffer_size>
    23c8:	12650000 	addk	r19, r5, r0
    23cc:	10830000 	addk	r4, r3, r0
    23d0:	1463b003 	cmpu	r3, r3, r22
    23d4:	bc43002c 	blti	r3, 44		// 2400
  buffer->pos += words_to_delete;
    23d8:	e8b30008 	lwi	r5, r19, 8
  buffer->pos %= IO_BUFFER_SIZE;
  return words_to_delete;
}
    23dc:	10640000 	addk	r3, r4, r0
  return words_to_read;
}

uint32_t cbuffer_deletefront(CircularBuffer* buffer, uint32_t nwords) {
  uint32_t words_to_delete = min(nwords, cbuffer_size(buffer));
  buffer->pos += words_to_delete;
    23e0:	10842800 	addk	r4, r4, r5
  buffer->pos %= IO_BUFFER_SIZE;
    23e4:	a484003f 	andi	r4, r4, 63
    23e8:	f8930008 	swi	r4, r19, 8
  return words_to_delete;
}
    23ec:	e9e10000 	lwi	r15, r1, 0
    23f0:	ea61001c 	lwi	r19, r1, 28
    23f4:	eac10020 	lwi	r22, r1, 32
    23f8:	b60f0008 	rtsd	r15, 8
    23fc:	30210024 	addik	r1, r1, 36
  }
  return words_to_read;
}

uint32_t cbuffer_deletefront(CircularBuffer* buffer, uint32_t nwords) {
  uint32_t words_to_delete = min(nwords, cbuffer_size(buffer));
    2400:	b810ffd8 	brid	-40		// 23d8
    2404:	10960000 	addk	r4, r22, r0

00002408 <cbuffer_pop>:
  buffer->pos += words_to_delete;
  buffer->pos %= IO_BUFFER_SIZE;
  return words_to_delete;
}

Buffer* cbuffer_pop(CircularBuffer* buffer, uint32_t nwords) {
    2408:	3021ffd8 	addik	r1, r1, -40
    240c:	fac10020 	swi	r22, r1, 32
    2410:	fae10024 	swi	r23, r1, 36
    2414:	12c60000 	addk	r22, r6, r0
    2418:	12e50000 	addk	r23, r5, r0
  Buffer* output = buffer_new(NULL, nwords);
    241c:	10a00000 	addk	r5, r0, r0
  buffer->pos += words_to_delete;
  buffer->pos %= IO_BUFFER_SIZE;
  return words_to_delete;
}

Buffer* cbuffer_pop(CircularBuffer* buffer, uint32_t nwords) {
    2420:	f9e10000 	swi	r15, r1, 0
  Buffer* output = buffer_new(NULL, nwords);
    2424:	b000ffff 	imm	-1
    2428:	b9f4f550 	brlid	r15, -2736	// 1978 <buffer_new>
    242c:	fa61001c 	swi	r19, r1, 28
  uint32_t actually_read = cbuffer_read(buffer, output->data, nwords);
    2430:	10f60000 	addk	r7, r22, r0
    2434:	10b70000 	addk	r5, r23, r0
    2438:	e8c30000 	lwi	r6, r3, 0
    243c:	b9f4fe74 	brlid	r15, -396	// 22b0 <cbuffer_read>
    2440:	12630000 	addk	r19, r3, r0
  buffer_resize(output, actually_read);
    2444:	10b30000 	addk	r5, r19, r0
    2448:	b000ffff 	imm	-1
    244c:	b9f4f614 	brlid	r15, -2540	// 1a60 <buffer_resize>
    2450:	10c30000 	addk	r6, r3, r0
  cbuffer_deletefront(buffer, nwords);
    2454:	10b70000 	addk	r5, r23, r0
    2458:	b9f4ff58 	brlid	r15, -168	// 23b0 <cbuffer_deletefront>
    245c:	10d60000 	addk	r6, r22, r0
  return output;
}
    2460:	10730000 	addk	r3, r19, r0
    2464:	e9e10000 	lwi	r15, r1, 0
    2468:	ea61001c 	lwi	r19, r1, 28
    246c:	eac10020 	lwi	r22, r1, 32
    2470:	eae10024 	lwi	r23, r1, 36
    2474:	b60f0008 	rtsd	r15, 8
    2478:	30210028 	addik	r1, r1, 40

0000247c <cbuffer_pop_front>:

uint32_t cbuffer_pop_front(CircularBuffer* buffer) {
    247c:	3021ffdc 	addik	r1, r1, -36
    2480:	fa61001c 	swi	r19, r1, 28
    2484:	fac10020 	swi	r22, r1, 32
    2488:	f9e10000 	swi	r15, r1, 0
  if (!cbuffer_size(buffer)) 
    248c:	b9f4fa8c 	brlid	r15, -1396	// 1f18 <cbuffer_size>
    2490:	12c50000 	addk	r22, r5, r0
    return 0xDEADBEEF;
    2494:	b000dead 	imm	-8531
    2498:	3260beef 	addik	r19, r0, -16657
  cbuffer_deletefront(buffer, nwords);
  return output;
}

uint32_t cbuffer_pop_front(CircularBuffer* buffer) {
  if (!cbuffer_size(buffer)) 
    249c:	be23001c 	bneid	r3, 28		// 24b8
    24a0:	10730000 	addk	r3, r19, r0
    return 0xDEADBEEF;
  uint32_t output = cbuffer_value_at(buffer, 0);
  cbuffer_deletefront(buffer, 1);
  return output;
}
    24a4:	e9e10000 	lwi	r15, r1, 0
    24a8:	ea61001c 	lwi	r19, r1, 28
    24ac:	eac10020 	lwi	r22, r1, 32
    24b0:	b60f0008 	rtsd	r15, 8
    24b4:	30210024 	addik	r1, r1, 36
  free(tokill->data);
  free(tokill);
}

uint32_t cbuffer_value_at(const CircularBuffer* buf, uint32_t idx) {
  uint32_t actual_idx = (buf->pos + idx) % IO_BUFFER_SIZE;
    24b8:	e8760008 	lwi	r3, r22, 8
  return buf->data[actual_idx];
    24bc:	e8960000 	lwi	r4, r22, 0

uint32_t cbuffer_pop_front(CircularBuffer* buffer) {
  if (!cbuffer_size(buffer)) 
    return 0xDEADBEEF;
  uint32_t output = cbuffer_value_at(buffer, 0);
  cbuffer_deletefront(buffer, 1);
    24c0:	10b60000 	addk	r5, r22, r0
  free(tokill->data);
  free(tokill);
}

uint32_t cbuffer_value_at(const CircularBuffer* buf, uint32_t idx) {
  uint32_t actual_idx = (buf->pos + idx) % IO_BUFFER_SIZE;
    24c4:	a463003f 	andi	r3, r3, 63
  return buf->data[actual_idx];
    24c8:	60630004 	muli	r3, r3, 4
    24cc:	ca632000 	lw	r19, r3, r4

uint32_t cbuffer_pop_front(CircularBuffer* buffer) {
  if (!cbuffer_size(buffer)) 
    return 0xDEADBEEF;
  uint32_t output = cbuffer_value_at(buffer, 0);
  cbuffer_deletefront(buffer, 1);
    24d0:	b9f4fee0 	brlid	r15, -288	// 23b0 <cbuffer_deletefront>
    24d4:	30c00001 	addik	r6, r0, 1
  return output;
}
    24d8:	10730000 	addk	r3, r19, r0
    24dc:	e9e10000 	lwi	r15, r1, 0
    24e0:	ea61001c 	lwi	r19, r1, 28
    24e4:	eac10020 	lwi	r22, r1, 32
    24e8:	b60f0008 	rtsd	r15, 8
    24ec:	30210024 	addik	r1, r1, 36

000024f0 <cbuffer_write_fd>:

ssize_t cbuffer_write_fd(CircularBuffer* buffer, int fd, size_t nwords) {
    24f0:	3021ffd0 	addik	r1, r1, -48
    24f4:	fa61001c 	swi	r19, r1, 28
    24f8:	fac10020 	swi	r22, r1, 32
    24fc:	fb010028 	swi	r24, r1, 40
    2500:	fb21002c 	swi	r25, r1, 44
    2504:	f9e10000 	swi	r15, r1, 0
    2508:	fae10024 	swi	r23, r1, 36
    250c:	12670000 	addk	r19, r7, r0
    2510:	12c50000 	addk	r22, r5, r0
    2514:	13260000 	addk	r25, r6, r0
  if (!nwords) {
    2518:	be0700b0 	beqid	r7, 176		// 25c8
    251c:	13070000 	addk	r24, r7, r0
    2520:	b8100088 	brid	136		// 25a8
    2524:	13000000 	addk	r24, r0, r0
    return buffer->tail - buffer->pos;
  return buffer->tail + IO_BUFFER_SIZE - buffer->pos;
}

uint32_t cbuffer_contiguous_data_size(const CircularBuffer* buffer) {
  if (buffer->pos <= buffer->tail) 
    2528:	e8960008 	lwi	r4, r22, 8
    252c:	e9160004 	lwi	r8, r22, 4
    return buffer->tail - buffer->pos;
  return IO_BUFFER_SIZE - buffer->pos;
    2530:	30c00040 	addik	r6, r0, 64
ssize_t cbuffer_write_fd(CircularBuffer* buffer, int fd, size_t nwords) {
  if (!nwords) {
    return 0;
  }
  uint32_t words_to_write = min(nwords, cbuffer_size(buffer));
  uint32_t tail_words_to_read = min(words_to_write, cbuffer_contiguous_data_size(buffer));
    2534:	10e90000 	addk	r7, r9, r0
    return buffer->tail - buffer->pos;
  return buffer->tail + IO_BUFFER_SIZE - buffer->pos;
}

uint32_t cbuffer_contiguous_data_size(const CircularBuffer* buffer) {
  if (buffer->pos <= buffer->tail) 
    2538:	15644003 	cmpu	r11, r4, r8
  if (!nwords) {
    return 0;
  }
  uint32_t words_to_write = min(nwords, cbuffer_size(buffer));
  uint32_t tail_words_to_read = min(words_to_write, cbuffer_contiguous_data_size(buffer));
  ssize_t written = write(fd, &(buffer->data[buffer->pos]), 
    253c:	61440004 	muli	r10, r4, 4
    return buffer->tail - buffer->pos;
  return buffer->tail + IO_BUFFER_SIZE - buffer->pos;
}

uint32_t cbuffer_contiguous_data_size(const CircularBuffer* buffer) {
  if (buffer->pos <= buffer->tail) 
    2540:	15844003 	cmpu	r12, r4, r8
    2544:	be4b000c 	bltid	r11, 12		// 2550
    2548:	14643000 	rsubk	r3, r4, r6
    return buffer->tail - buffer->pos;
    254c:	14644000 	rsubk	r3, r4, r8
ssize_t cbuffer_write_fd(CircularBuffer* buffer, int fd, size_t nwords) {
  if (!nwords) {
    return 0;
  }
  uint32_t words_to_write = min(nwords, cbuffer_size(buffer));
  uint32_t tail_words_to_read = min(words_to_write, cbuffer_contiguous_data_size(buffer));
    2550:	15234803 	cmpu	r9, r3, r9
    2554:	be490014 	bltid	r9, 20		// 2568
    2558:	30600040 	addik	r3, r0, 64
    return buffer->tail - buffer->pos;
  return buffer->tail + IO_BUFFER_SIZE - buffer->pos;
}

uint32_t cbuffer_contiguous_data_size(const CircularBuffer* buffer) {
  if (buffer->pos <= buffer->tail) 
    255c:	be4c000c 	bltid	r12, 12		// 2568
    2560:	14e41800 	rsubk	r7, r4, r3
    return buffer->tail - buffer->pos;
    2564:	14e44000 	rsubk	r7, r4, r8
  if (!nwords) {
    return 0;
  }
  uint32_t words_to_write = min(nwords, cbuffer_size(buffer));
  uint32_t tail_words_to_read = min(words_to_write, cbuffer_contiguous_data_size(buffer));
  ssize_t written = write(fd, &(buffer->data[buffer->pos]), 
    2568:	e8d60000 	lwi	r6, r22, 0
    256c:	60e70004 	muli	r7, r7, 4
    2570:	b0000000 	imm	0
    2574:	b9f40fa8 	brlid	r15, 4008	// 351c <write>
    2578:	10c65000 	addk	r6, r6, r10
      tail_words_to_read * sizeof(uint32_t)) / sizeof(uint32_t);
    257c:	12e01800 	addk	r23, r0, r3
    2580:	92e30041 	srl	r23, r3
    2584:	92f70041 	srl	r23, r23
  cbuffer_deletefront(buffer, written);
    2588:	10b60000 	addk	r5, r22, r0
    258c:	10d70000 	addk	r6, r23, r0
    2590:	b9f4fe20 	brlid	r15, -480	// 23b0 <cbuffer_deletefront>
    2594:	16779800 	rsubk	r19, r23, r19
  if (written == 0)
    2598:	be170034 	beqid	r23, 52		// 25cc
    259c:	10780000 	addk	r3, r24, r0
  cbuffer_deletefront(buffer, 1);
  return output;
}

ssize_t cbuffer_write_fd(CircularBuffer* buffer, int fd, size_t nwords) {
  if (!nwords) {
    25a0:	be130028 	beqid	r19, 40		// 25c8
    25a4:	1318b800 	addk	r24, r24, r23
    return 0;
  }
  uint32_t words_to_write = min(nwords, cbuffer_size(buffer));
    25a8:	b9f4f970 	brlid	r15, -1680	// 1f18 <cbuffer_size>
    25ac:	10b60000 	addk	r5, r22, r0
    25b0:	14931803 	cmpu	r4, r19, r3
  uint32_t tail_words_to_read = min(words_to_write, cbuffer_contiguous_data_size(buffer));
  ssize_t written = write(fd, &(buffer->data[buffer->pos]), 
    25b4:	10b90000 	addk	r5, r25, r0

ssize_t cbuffer_write_fd(CircularBuffer* buffer, int fd, size_t nwords) {
  if (!nwords) {
    return 0;
  }
  uint32_t words_to_write = min(nwords, cbuffer_size(buffer));
    25b8:	bea4ff70 	bgeid	r4, -144		// 2528
    25bc:	11330000 	addk	r9, r19, r0
    25c0:	b810ff68 	brid	-152		// 2528
    25c4:	11230000 	addk	r9, r3, r0
      tail_words_to_read * sizeof(uint32_t)) / sizeof(uint32_t);
  cbuffer_deletefront(buffer, written);
  if (written == 0)
    return 0;
  return written + cbuffer_write_fd(buffer, fd, nwords - written);
}
    25c8:	10780000 	addk	r3, r24, r0
    25cc:	e9e10000 	lwi	r15, r1, 0
    25d0:	ea61001c 	lwi	r19, r1, 28
    25d4:	eac10020 	lwi	r22, r1, 32
    25d8:	eae10024 	lwi	r23, r1, 36
    25dc:	eb010028 	lwi	r24, r1, 40
    25e0:	eb21002c 	lwi	r25, r1, 44
    25e4:	b60f0008 	rtsd	r15, 8
    25e8:	30210030 	addik	r1, r1, 48

000025ec <cbuffer_read_fd>:

ssize_t cbuffer_read_fd(CircularBuffer* buffer, int fd, size_t nwords) {
    25ec:	3021ffd0 	addik	r1, r1, -48
    25f0:	fa61001c 	swi	r19, r1, 28
    25f4:	fac10020 	swi	r22, r1, 32
    25f8:	fb010028 	swi	r24, r1, 40
    25fc:	fb21002c 	swi	r25, r1, 44
    2600:	f9e10000 	swi	r15, r1, 0
    2604:	fae10024 	swi	r23, r1, 36
    2608:	12670000 	addk	r19, r7, r0
    260c:	12c50000 	addk	r22, r5, r0
    2610:	13260000 	addk	r25, r6, r0
  if (!nwords) {
    2614:	be07009c 	beqid	r7, 156		// 26b0
    2618:	13070000 	addk	r24, r7, r0
    261c:	eae50004 	lwi	r23, r5, 4
    2620:	b8100050 	brid	80		// 2670
    2624:	13000000 	addk	r24, r0, r0
  // words available on "tail" until we hit the absolute end of the memory.
  // we know from the freespace check that we can't overwrite the head with
  // only <nwords>.
  words_to_read = min(IO_BUFFER_SIZE - buffer->tail, words_to_read);

  ssize_t words_read = read(fd, &(buffer->data[buffer->tail]), 
    2628:	e8d60000 	lwi	r6, r22, 0
  size_t words_to_read = min(nwords, freespace);

  // words available on "tail" until we hit the absolute end of the memory.
  // we know from the freespace check that we can't overwrite the head with
  // only <nwords>.
  words_to_read = min(IO_BUFFER_SIZE - buffer->tail, words_to_read);
    262c:	14672003 	cmpu	r3, r7, r4
    2630:	be430078 	bltid	r3, 120		// 26a8
    2634:	10c6b800 	addk	r6, r6, r23

  ssize_t words_read = read(fd, &(buffer->data[buffer->tail]), 
    2638:	b0000000 	imm	0
    263c:	b9f40f74 	brlid	r15, 3956	// 35b0 <read>
    2640:	60e70004 	muli	r7, r7, 4
      words_to_read * sizeof(uint32_t)) / sizeof(uint32_t);

  buffer->tail = (buffer->tail + words_read) % IO_BUFFER_SIZE;
    2644:	eaf60004 	lwi	r23, r22, 4
  // we know from the freespace check that we can't overwrite the head with
  // only <nwords>.
  words_to_read = min(IO_BUFFER_SIZE - buffer->tail, words_to_read);

  ssize_t words_read = read(fd, &(buffer->data[buffer->tail]), 
      words_to_read * sizeof(uint32_t)) / sizeof(uint32_t);
    2648:	10801800 	addk	r4, r0, r3
    264c:	90830041 	srl	r4, r3
    2650:	90840041 	srl	r4, r4
  buffer->tail = (buffer->tail + words_read) % IO_BUFFER_SIZE;

  if (words_read == 0) {
    return 0;
  } 
  return words_read + cbuffer_read_fd(buffer, fd, nwords - words_read);
    2654:	16649800 	rsubk	r19, r4, r19
  words_to_read = min(IO_BUFFER_SIZE - buffer->tail, words_to_read);

  ssize_t words_read = read(fd, &(buffer->data[buffer->tail]), 
      words_to_read * sizeof(uint32_t)) / sizeof(uint32_t);

  buffer->tail = (buffer->tail + words_read) % IO_BUFFER_SIZE;
    2658:	12e4b800 	addk	r23, r4, r23
    265c:	a6f7003f 	andi	r23, r23, 63

  if (words_read == 0) {
    2660:	be040050 	beqid	r4, 80		// 26b0
    2664:	faf60004 	swi	r23, r22, 4
    return 0;
  return written + cbuffer_write_fd(buffer, fd, nwords - written);
}

ssize_t cbuffer_read_fd(CircularBuffer* buffer, int fd, size_t nwords) {
  if (!nwords) {
    2668:	be130048 	beqid	r19, 72		// 26b0
    266c:	13182000 	addk	r24, r24, r4
    return 0;
  }
  uint32_t freespace = cbuffer_freespace(buffer);
    2670:	b9f4fa1c 	brlid	r15, -1508	// 208c <cbuffer_freespace>
    2674:	10b60000 	addk	r5, r22, r0
  size_t words_to_read = min(nwords, freespace);

  // words available on "tail" until we hit the absolute end of the memory.
  // we know from the freespace check that we can't overwrite the head with
  // only <nwords>.
  words_to_read = min(IO_BUFFER_SIZE - buffer->tail, words_to_read);
    2678:	30c00040 	addik	r6, r0, 64
ssize_t cbuffer_read_fd(CircularBuffer* buffer, int fd, size_t nwords) {
  if (!nwords) {
    return 0;
  }
  uint32_t freespace = cbuffer_freespace(buffer);
  size_t words_to_read = min(nwords, freespace);
    267c:	15131803 	cmpu	r8, r19, r3

  // words available on "tail" until we hit the absolute end of the memory.
  // we know from the freespace check that we can't overwrite the head with
  // only <nwords>.
  words_to_read = min(IO_BUFFER_SIZE - buffer->tail, words_to_read);
    2680:	14973000 	rsubk	r4, r23, r6

  ssize_t words_read = read(fd, &(buffer->data[buffer->tail]), 
    2684:	10b90000 	addk	r5, r25, r0
    2688:	62f70004 	muli	r23, r23, 4
ssize_t cbuffer_read_fd(CircularBuffer* buffer, int fd, size_t nwords) {
  if (!nwords) {
    return 0;
  }
  uint32_t freespace = cbuffer_freespace(buffer);
  size_t words_to_read = min(nwords, freespace);
    268c:	bea8ff9c 	bgeid	r8, -100		// 2628
    2690:	10f30000 	addk	r7, r19, r0
    2694:	10e30000 	addk	r7, r3, r0
  // words available on "tail" until we hit the absolute end of the memory.
  // we know from the freespace check that we can't overwrite the head with
  // only <nwords>.
  words_to_read = min(IO_BUFFER_SIZE - buffer->tail, words_to_read);

  ssize_t words_read = read(fd, &(buffer->data[buffer->tail]), 
    2698:	e8d60000 	lwi	r6, r22, 0
  size_t words_to_read = min(nwords, freespace);

  // words available on "tail" until we hit the absolute end of the memory.
  // we know from the freespace check that we can't overwrite the head with
  // only <nwords>.
  words_to_read = min(IO_BUFFER_SIZE - buffer->tail, words_to_read);
    269c:	14672003 	cmpu	r3, r7, r4
    26a0:	bea3ff98 	bgeid	r3, -104		// 2638
    26a4:	10c6b800 	addk	r6, r6, r23
    26a8:	b810ff90 	brid	-112		// 2638
    26ac:	10e40000 	addk	r7, r4, r0

  if (words_read == 0) {
    return 0;
  } 
  return words_read + cbuffer_read_fd(buffer, fd, nwords - words_read);
}
    26b0:	10780000 	addk	r3, r24, r0
    26b4:	e9e10000 	lwi	r15, r1, 0
    26b8:	ea61001c 	lwi	r19, r1, 28
    26bc:	eac10020 	lwi	r22, r1, 32
    26c0:	eae10024 	lwi	r23, r1, 36
    26c4:	eb010028 	lwi	r24, r1, 40
    26c8:	eb21002c 	lwi	r25, r1, 44
    26cc:	b60f0008 	rtsd	r15, 8
    26d0:	30210030 	addik	r1, r1, 48

000026d4 <ipbus_transaction_payload_size>:
#include <stdlib.h>
#include <string.h>

size_t ipbus_transaction_payload_size(unsigned char words, unsigned char type, unsigned char info_code) {
  size_t datasize = 0;
  if (info_code != IPBUS_INFO_REQUEST && info_code != IPBUS_INFO_SUCCESS) {
    26d4:	be27003c 	bneid	r7, 60		// 2710
    26d8:	3080000f 	addik	r4, r0, 15
    // this is an error, w/ no data returned.
    datasize = 0;
  } else {
    int is_response = (info_code == IPBUS_INFO_SUCCESS);
    switch (type) {
    26dc:	30800005 	addik	r4, r0, 5
  size_t datasize = 0;
  if (info_code != IPBUS_INFO_REQUEST && info_code != IPBUS_INFO_SUCCESS) {
    // this is an error, w/ no data returned.
    datasize = 0;
  } else {
    int is_response = (info_code == IPBUS_INFO_SUCCESS);
    26e0:	10600000 	addk	r3, r0, r0
    switch (type) {
    26e4:	14862003 	cmpu	r4, r6, r4
    26e8:	be440034 	bltid	r4, 52		// 271c
    26ec:	88e71c00 	pcmpeq	r7, r7, r3
    26f0:	60c60004 	muli	r6, r6, 4
    26f4:	b0000000 	imm	0
    26f8:	30c6d740 	addik	r6, r6, -10432
    26fc:	e8660000 	lwi	r3, r6, 0
    2700:	98081800 	bra	r3
        datasize = is_response ? 1 : 3;
        break;
      case IPBUS_RMWSUM:
        // request = addr, addend
        // response = contentes of addr before modify/write
        datasize = is_response ? 1 : 2;
    2704:	a8e70001 	xori	r7, r7, 1
        break;
    }
  }
  return datasize;
}
    2708:	b60f0008 	rtsd	r15, 8
    270c:	30670001 	addik	r3, r7, 1
#include <stdlib.h>
#include <string.h>

size_t ipbus_transaction_payload_size(unsigned char words, unsigned char type, unsigned char info_code) {
  size_t datasize = 0;
  if (info_code != IPBUS_INFO_REQUEST && info_code != IPBUS_INFO_SUCCESS) {
    2710:	8c872400 	pcmpne	r4, r7, r4
    2714:	be04ffc8 	beqid	r4, -56		// 26dc
    2718:	10600000 	addk	r3, r0, r0
        datasize = is_response ? 1 : 2;
        break;
    }
  }
  return datasize;
}
    271c:	b60f0008 	rtsd	r15, 8
    2720:	80000000 	or	r0, r0, r0
        datasize = is_response ? 0 : words + 1;
        break;
      case IPBUS_RMW:
        // request = addr, AND term, OR term
        // response = contentes of addr before modify/write
        datasize = is_response ? 1 : 3;
    2724:	be07fff8 	beqid	r7, -8		// 271c
    2728:	30600003 	addik	r3, r0, 3
    272c:	b60f0008 	rtsd	r15, 8
    2730:	30600001 	addik	r3, r0, 1
        break;
      case IPBUS_WRITE:
      case IPBUS_NIWRITE:
        // request = base addr + n words to write at addr
        // response = nothing
        datasize = is_response ? 0 : words + 1;
    2734:	be27ffe8 	bneid	r7, -24		// 271c
    2738:	10600000 	addk	r3, r0, r0
    273c:	b60f0008 	rtsd	r15, 8
    2740:	30650001 	addik	r3, r5, 1
    switch (type) {
      case IPBUS_READ:
      case IPBUS_NIREAD:
        // request = 1 word with addr to read
        // response = n words read starting from addr
        datasize = is_response ? words : 1;
    2744:	be07ffd8 	beqid	r7, -40		// 271c
    2748:	30600001 	addik	r3, r0, 1
    274c:	b60f0008 	rtsd	r15, 8
    2750:	10650000 	addk	r3, r5, r0

00002754 <ipbus_detect_packet_header>:
int ipbus_detect_packet_header(uint32_t headerword) {
  // check endianess.  
  uint32_t msnibble = headerword & 0xf0000000;
  uint32_t lsnibble = headerword & 0xf0;

  if (lsnibble == 0x20 && msnibble == 0xf0000000) {
    2754:	b000f000 	imm	-4096
    2758:	30600000 	addik	r3, r0, 0
  return datasize;
}

int ipbus_detect_packet_header(uint32_t headerword) {
  // check endianess.  
  uint32_t msnibble = headerword & 0xf0000000;
    275c:	b000f000 	imm	-4096
    2760:	a4850000 	andi	r4, r5, 0
  uint32_t lsnibble = headerword & 0xf0;

  if (lsnibble == 0x20 && msnibble == 0xf0000000) {
    2764:	88641c00 	pcmpeq	r3, r4, r3
    2768:	be030020 	beqid	r3, 32		// 2788
    276c:	a4a500f0 	andi	r5, r5, 240
    2770:	30c00020 	addik	r6, r0, 32	// 20 <_vector_hw_exception>
    2774:	88c53400 	pcmpeq	r6, r5, r6
    2778:	be060010 	beqid	r6, 16		// 2788
    277c:	30600002 	addik	r3, r0, 2
    return 2;
  } else if (lsnibble != 0xf0 || msnibble != 0x20000000) {
    return 0;
  }
  return 1;
}
    2780:	b60f0008 	rtsd	r15, 8
    2784:	80000000 	or	r0, r0, r0
  uint32_t lsnibble = headerword & 0xf0;

  if (lsnibble == 0x20 && msnibble == 0xf0000000) {
    // we need to swap the endianness
    return 2;
  } else if (lsnibble != 0xf0 || msnibble != 0x20000000) {
    2788:	306000f0 	addik	r3, r0, 240
    278c:	8ca51c00 	pcmpne	r5, r5, r3
    2790:	b0002000 	imm	8192
    2794:	30600000 	addik	r3, r0, 0
    2798:	8c641c00 	pcmpne	r3, r4, r3
    279c:	80632800 	or	r3, r3, r5
    return 0;
  }
  return 1;
}
    27a0:	b60f0008 	rtsd	r15, 8
    27a4:	a8630001 	xori	r3, r3, 1

000027a8 <ipbus_decode_transaction_header>:
  LOG_DEBUG("Partial transaction size: %"PRIx32, cbuffer_size(input_buffer));
  return IPBUS_ISTREAM_PARTIAL_TRANS;
}

// initialize IPbus transaction from a stream
ipbus_transaction_t ipbus_decode_transaction_header(const CircularBuffer* buf, int swapbytes) {
    27a8:	3021ffd0 	addik	r1, r1, -48
    27ac:	fa61001c 	swi	r19, r1, 28
    27b0:	12650000 	addk	r19, r5, r0
  ipbus_transaction_t output;

  uint32_t headerword = cbuffer_value_at_net(buf, 0);
    27b4:	10a60000 	addk	r5, r6, r0
  LOG_DEBUG("Partial transaction size: %"PRIx32, cbuffer_size(input_buffer));
  return IPBUS_ISTREAM_PARTIAL_TRANS;
}

// initialize IPbus transaction from a stream
ipbus_transaction_t ipbus_decode_transaction_header(const CircularBuffer* buf, int swapbytes) {
    27b8:	fae10024 	swi	r23, r1, 36
    27bc:	12e70000 	addk	r23, r7, r0
  ipbus_transaction_t output;

  uint32_t headerword = cbuffer_value_at_net(buf, 0);
    27c0:	10c00000 	addk	r6, r0, r0
  LOG_DEBUG("Partial transaction size: %"PRIx32, cbuffer_size(input_buffer));
  return IPBUS_ISTREAM_PARTIAL_TRANS;
}

// initialize IPbus transaction from a stream
ipbus_transaction_t ipbus_decode_transaction_header(const CircularBuffer* buf, int swapbytes) {
    27c4:	fac10020 	swi	r22, r1, 32
    27c8:	f9e10000 	swi	r15, r1, 0
    27cc:	fb010028 	swi	r24, r1, 40
  ipbus_transaction_t output;

  uint32_t headerword = cbuffer_value_at_net(buf, 0);
    27d0:	b000ffff 	imm	-1
    27d4:	b9f4f7e4 	brlid	r15, -2076	// 1fb8 <cbuffer_value_at_net>
    27d8:	fb21002c 	swi	r25, r1, 44

  if (swapbytes)
    27dc:	be1700c0 	beqid	r23, 192		// 289c
    27e0:	12c30000 	addk	r22, r3, r0
    headerword = __bswap_32(headerword);
    27e4:	b0000000 	imm	0
    27e8:	a483ffff 	andi	r4, r3, -1
    27ec:	60c40100 	muli	r6, r4, 256
    27f0:	1060b000 	addk	r3, r0, r22
    27f4:	90760041 	srl	r3, r22
    27f8:	90630041 	srl	r3, r3
    27fc:	90630041 	srl	r3, r3
    2800:	90630041 	srl	r3, r3
    2804:	90630041 	srl	r3, r3
    2808:	90630041 	srl	r3, r3
    280c:	90630041 	srl	r3, r3
    2810:	90630041 	srl	r3, r3
    2814:	90630041 	srl	r3, r3
    2818:	90630041 	srl	r3, r3
    281c:	90630041 	srl	r3, r3
    2820:	90630041 	srl	r3, r3
    2824:	90630041 	srl	r3, r3
    2828:	90630041 	srl	r3, r3
    282c:	90630041 	srl	r3, r3
    2830:	90630041 	srl	r3, r3
    2834:	62c30100 	muli	r22, r3, 256
    2838:	10a02000 	addk	r5, r0, r4
    283c:	90a40041 	srl	r5, r4
    2840:	90a50041 	srl	r5, r5
    2844:	90a50041 	srl	r5, r5
    2848:	90a50041 	srl	r5, r5
    284c:	90a50041 	srl	r5, r5
    2850:	90a50041 	srl	r5, r5
    2854:	90a50041 	srl	r5, r5
    2858:	90a50041 	srl	r5, r5
    285c:	b0000000 	imm	0
    2860:	a6d6ffff 	andi	r22, r22, -1
    2864:	80a62800 	or	r5, r6, r5
    2868:	10801800 	addk	r4, r0, r3
    286c:	90830041 	srl	r4, r3
    2870:	90840041 	srl	r4, r4
    2874:	90840041 	srl	r4, r4
    2878:	90840041 	srl	r4, r4
    287c:	90840041 	srl	r4, r4
    2880:	90840041 	srl	r4, r4
    2884:	90840041 	srl	r4, r4
    2888:	90840041 	srl	r4, r4
    288c:	b0000001 	imm	1
    2890:	60650000 	muli	r3, r5, 0
    2894:	82d62000 	or	r22, r22, r4
    2898:	82d61800 	or	r22, r22, r3

  output.info = headerword & 0x0f;
    289c:	a6f6000f 	andi	r23, r22, 15
  output.type = (headerword & 0xf0) >> 4;
    28a0:	a49600f0 	andi	r4, r22, 240
  output.words = (headerword & 0xff00) >> 8;
    28a4:	b0000000 	imm	0
    28a8:	a476ff00 	andi	r3, r22, -256

  if (swapbytes)
    headerword = __bswap_32(headerword);

  output.info = headerword & 0x0f;
  output.type = (headerword & 0xf0) >> 4;
    28ac:	13002000 	addk	r24, r0, r4
    28b0:	93040041 	srl	r24, r4
    28b4:	93180041 	srl	r24, r24
    28b8:	93180041 	srl	r24, r24
    28bc:	93180041 	srl	r24, r24
  output.words = (headerword & 0xff00) >> 8;
    28c0:	13201800 	addk	r25, r0, r3
    28c4:	93230041 	srl	r25, r3
    28c8:	93390041 	srl	r25, r25
    28cc:	93390041 	srl	r25, r25
    28d0:	93390041 	srl	r25, r25
    28d4:	93390041 	srl	r25, r25
    28d8:	93390041 	srl	r25, r25
    28dc:	93390041 	srl	r25, r25
    28e0:	93390041 	srl	r25, r25
  output.id = (headerword & 0x0fff0000) >> 16;

  // determine payload size
  output.data.size = ipbus_transaction_payload_size(
    28e4:	10d80000 	addk	r6, r24, r0
    28e8:	10b90000 	addk	r5, r25, r0
    headerword = __bswap_32(headerword);

  output.info = headerword & 0x0f;
  output.type = (headerword & 0xf0) >> 4;
  output.words = (headerword & 0xff00) >> 8;
  output.id = (headerword & 0x0fff0000) >> 16;
    28ec:	b0000fff 	imm	4095
    28f0:	a6d60000 	andi	r22, r22, 0

  // determine payload size
  output.data.size = ipbus_transaction_payload_size(
    28f4:	b9f4fde0 	brlid	r15, -544	// 26d4 <ipbus_transaction_payload_size>
    28f8:	10f70000 	addk	r7, r23, r0
    28fc:	f0730008 	sbi	r3, r19, 8
      output.words, output.type, output.info);

  output.data.words = NULL;

  return output;
    2900:	f3330002 	sbi	r25, r19, 2
    2904:	f3130003 	sbi	r24, r19, 3
    2908:	f2f30004 	sbi	r23, r19, 4
    290c:	f813000c 	swi	r0, r19, 12
    headerword = __bswap_32(headerword);

  output.info = headerword & 0x0f;
  output.type = (headerword & 0xf0) >> 4;
  output.words = (headerword & 0xff00) >> 8;
  output.id = (headerword & 0x0fff0000) >> 16;
    2910:	1080b000 	addk	r4, r0, r22
    2914:	90960041 	srl	r4, r22
    2918:	90840041 	srl	r4, r4
    291c:	90840041 	srl	r4, r4
    2920:	90840041 	srl	r4, r4
    2924:	90840041 	srl	r4, r4
    2928:	90840041 	srl	r4, r4
    292c:	90840041 	srl	r4, r4
    2930:	90840041 	srl	r4, r4
    2934:	90840041 	srl	r4, r4
    2938:	90840041 	srl	r4, r4
    293c:	90840041 	srl	r4, r4
    2940:	90840041 	srl	r4, r4
    2944:	90840041 	srl	r4, r4
    2948:	90840041 	srl	r4, r4
    294c:	90840041 	srl	r4, r4
    2950:	90840041 	srl	r4, r4
    2954:	f4930000 	shi	r4, r19, 0
      output.words, output.type, output.info);

  output.data.words = NULL;

  return output;
}
    2958:	10730000 	addk	r3, r19, r0
    295c:	e9e10000 	lwi	r15, r1, 0
    2960:	ea61001c 	lwi	r19, r1, 28
    2964:	eac10020 	lwi	r22, r1, 32
    2968:	eae10024 	lwi	r23, r1, 36
    296c:	eb010028 	lwi	r24, r1, 40
    2970:	eb21002c 	lwi	r25, r1, 44
    2974:	b60f0008 	rtsd	r15, 8
    2978:	30210030 	addik	r1, r1, 48

0000297c <ipbus_stream_state>:
    return 0;
  }
  return 1;
}

int ipbus_stream_state(const CircularBuffer* input_buffer, int* swapbytes) {
    297c:	3021ffcc 	addik	r1, r1, -52
    2980:	fa61002c 	swi	r19, r1, 44
    2984:	fac10030 	swi	r22, r1, 48
    2988:	f9e10000 	swi	r15, r1, 0
    298c:	12650000 	addk	r19, r5, r0
  if (!cbuffer_size(input_buffer)) {
    2990:	b000ffff 	imm	-1
    2994:	b9f4f584 	brlid	r15, -2684	// 1f18 <cbuffer_size>
    2998:	12c60000 	addk	r22, r6, r0
    299c:	be23001c 	bneid	r3, 28		// 29b8
    29a0:	10b30000 	addk	r5, r19, r0
    return IPBUS_ISTREAM_FULL_TRANS;
  }

  LOG_DEBUG("Partial transaction size: %"PRIx32, cbuffer_size(input_buffer));
  return IPBUS_ISTREAM_PARTIAL_TRANS;
}
    29a4:	e9e10000 	lwi	r15, r1, 0
    29a8:	ea61002c 	lwi	r19, r1, 44
    29ac:	eac10030 	lwi	r22, r1, 48
    29b0:	b60f0008 	rtsd	r15, 8
    29b4:	30210034 	addik	r1, r1, 52

int ipbus_stream_state(const CircularBuffer* input_buffer, int* swapbytes) {
  if (!cbuffer_size(input_buffer)) {
    return IPBUS_ISTREAM_EMPTY;
  }
  uint32_t firstword = cbuffer_value_at_net(input_buffer, 0);
    29b8:	b000ffff 	imm	-1
    29bc:	b9f4f5fc 	brlid	r15, -2564	// 1fb8 <cbuffer_value_at_net>
    29c0:	10c00000 	addk	r6, r0, r0
int ipbus_detect_packet_header(uint32_t headerword) {
  // check endianess.  
  uint32_t msnibble = headerword & 0xf0000000;
  uint32_t lsnibble = headerword & 0xf0;

  if (lsnibble == 0x20 && msnibble == 0xf0000000) {
    29c4:	b000f000 	imm	-4096
    29c8:	30a00000 	addik	r5, r0, 0
  return datasize;
}

int ipbus_detect_packet_header(uint32_t headerword) {
  // check endianess.  
  uint32_t msnibble = headerword & 0xf0000000;
    29cc:	b000f000 	imm	-4096
    29d0:	a4830000 	andi	r4, r3, 0
  uint32_t lsnibble = headerword & 0xf0;

  if (lsnibble == 0x20 && msnibble == 0xf0000000) {
    29d4:	88a42c00 	pcmpeq	r5, r4, r5
    29d8:	be050018 	beqid	r5, 24		// 29f0
    29dc:	a4c300f0 	andi	r6, r3, 240
    29e0:	30a00020 	addik	r5, r0, 32	// 20 <_vector_hw_exception>
    29e4:	88a62c00 	pcmpeq	r5, r6, r5
    29e8:	be2500dc 	bneid	r5, 220		// 2ac4
    29ec:	30600002 	addik	r3, r0, 2
    // we need to swap the endianness
    return 2;
  } else if (lsnibble != 0xf0 || msnibble != 0x20000000) {
    29f0:	b0002000 	imm	8192
    29f4:	30600000 	addik	r3, r0, 0
    29f8:	8c841c00 	pcmpne	r4, r4, r3
    29fc:	bc240010 	bnei	r4, 16		// 2a0c
    2a00:	306000f0 	addik	r3, r0, 240
    2a04:	8cc61c00 	pcmpne	r6, r6, r3
    2a08:	bc0600b8 	beqi	r6, 184		// 2ac0
  }
  // Double check if it is reasonable transaction packet
  // header.  We should never have the middle of a transaction
  // at the header of the buffer - we always wait for a 
  // transaction to be in-buffer before reading it out.
  ipbus_transaction_t transaction = ipbus_decode_transaction_header(
    2a0c:	10d30000 	addk	r6, r19, r0
    2a10:	e8f60000 	lwi	r7, r22, 0
    2a14:	b9f4fd94 	brlid	r15, -620	// 27a8 <ipbus_decode_transaction_header>
    2a18:	30a1001c 	addik	r5, r1, 28
      input_buffer, *swapbytes);

  if (cbuffer_size(input_buffer) >= (transaction.data.size + 1)) {
    2a1c:	b000ffff 	imm	-1
    2a20:	b9f4f4f8 	brlid	r15, -2824	// 1f18 <cbuffer_size>
    2a24:	10b30000 	addk	r5, r19, r0
    2a28:	e0810024 	lbui	r4, r1, 36
    2a2c:	30840001 	addik	r4, r4, 1
    2a30:	14841803 	cmpu	r4, r4, r3
    return IPBUS_ISTREAM_FULL_TRANS;
    2a34:	10602000 	addk	r3, r0, r4
    2a38:	90640041 	srl	r3, r4
    2a3c:	90630041 	srl	r3, r3
    2a40:	90630041 	srl	r3, r3
    2a44:	90630041 	srl	r3, r3
    2a48:	90630041 	srl	r3, r3
    2a4c:	90630041 	srl	r3, r3
    2a50:	90630041 	srl	r3, r3
    2a54:	90630041 	srl	r3, r3
    2a58:	90630041 	srl	r3, r3
    2a5c:	90630041 	srl	r3, r3
    2a60:	90630041 	srl	r3, r3
    2a64:	90630041 	srl	r3, r3
    2a68:	90630041 	srl	r3, r3
    2a6c:	90630041 	srl	r3, r3
    2a70:	90630041 	srl	r3, r3
    2a74:	90630041 	srl	r3, r3
    2a78:	90630041 	srl	r3, r3
    2a7c:	90630041 	srl	r3, r3
    2a80:	90630041 	srl	r3, r3
    2a84:	90630041 	srl	r3, r3
    2a88:	90630041 	srl	r3, r3
    2a8c:	90630041 	srl	r3, r3
    2a90:	90630041 	srl	r3, r3
    2a94:	90630041 	srl	r3, r3
    2a98:	90630041 	srl	r3, r3
    2a9c:	90630041 	srl	r3, r3
    2aa0:	90630041 	srl	r3, r3
    2aa4:	90630041 	srl	r3, r3
    2aa8:	90630041 	srl	r3, r3
    2aac:	90630041 	srl	r3, r3
    2ab0:	90630041 	srl	r3, r3
    2ab4:	30800004 	addik	r4, r0, 4
    2ab8:	b810feec 	brid	-276		// 29a4
    2abc:	14632000 	rsubk	r3, r3, r4
    // we need to swap the endianness
    return 2;
  } else if (lsnibble != 0xf0 || msnibble != 0x20000000) {
    return 0;
  }
  return 1;
    2ac0:	30600001 	addik	r3, r0, 1
  LOG_DEBUG("Got a word: %"PRIx32, firstword);
  // check if this is a packet header
  int is_pkt = ipbus_detect_packet_header(firstword);
  if (is_pkt) {
    // check if we want to update an endianness flag
    if (swapbytes != NULL) {
    2ac4:	be16fee0 	beqid	r22, -288		// 29a4
    2ac8:	a8830001 	xori	r4, r3, 1
      if (is_pkt == IPBUS_ISTREAM_PACKET)
    2acc:	bc040024 	beqi	r4, 36		// 2af0
        *swapbytes = 0;
      if (is_pkt == IPBUS_ISTREAM_PACKET_SWP_ORD)
        *swapbytes = 1;
    2ad0:	30600001 	addik	r3, r0, 1
    2ad4:	f8760000 	swi	r3, r22, 0
    return IPBUS_ISTREAM_FULL_TRANS;
  }

  LOG_DEBUG("Partial transaction size: %"PRIx32, cbuffer_size(input_buffer));
  return IPBUS_ISTREAM_PARTIAL_TRANS;
}
    2ad8:	e9e10000 	lwi	r15, r1, 0
    2adc:	ea61002c 	lwi	r19, r1, 44
    2ae0:	eac10030 	lwi	r22, r1, 48
    // check if we want to update an endianness flag
    if (swapbytes != NULL) {
      if (is_pkt == IPBUS_ISTREAM_PACKET)
        *swapbytes = 0;
      if (is_pkt == IPBUS_ISTREAM_PACKET_SWP_ORD)
        *swapbytes = 1;
    2ae4:	30600002 	addik	r3, r0, 2
    return IPBUS_ISTREAM_FULL_TRANS;
  }

  LOG_DEBUG("Partial transaction size: %"PRIx32, cbuffer_size(input_buffer));
  return IPBUS_ISTREAM_PARTIAL_TRANS;
}
    2ae8:	b60f0008 	rtsd	r15, 8
    2aec:	30210034 	addik	r1, r1, 52
  int is_pkt = ipbus_detect_packet_header(firstword);
  if (is_pkt) {
    // check if we want to update an endianness flag
    if (swapbytes != NULL) {
      if (is_pkt == IPBUS_ISTREAM_PACKET)
        *swapbytes = 0;
    2af0:	b810feb4 	brid	-332		// 29a4
    2af4:	f8960000 	swi	r4, r22, 0

00002af8 <ipbus_decode_transaction>:

  return output;
}

// read an IPbus transaction from a stream
ipbus_transaction_t ipbus_decode_transaction(const CircularBuffer *buf, int swapbytes) {
    2af8:	3021ffac 	addik	r1, r1, -84
    2afc:	fbc10050 	swi	r30, r1, 80
    2b00:	13c50000 	addk	r30, r5, r0
  ipbus_transaction_t output = ipbus_decode_transaction_header(buf, swapbytes);
    2b04:	30a1001c 	addik	r5, r1, 28

  return output;
}

// read an IPbus transaction from a stream
ipbus_transaction_t ipbus_decode_transaction(const CircularBuffer *buf, int swapbytes) {
    2b08:	f9e10000 	swi	r15, r1, 0
    2b0c:	fac10030 	swi	r22, r1, 48
    2b10:	fb010038 	swi	r24, r1, 56
    2b14:	fb810048 	swi	r28, r1, 72
    2b18:	fba1004c 	swi	r29, r1, 76
    2b1c:	12c60000 	addk	r22, r6, r0
    2b20:	13a70000 	addk	r29, r7, r0
    2b24:	fa61002c 	swi	r19, r1, 44
    2b28:	fae10034 	swi	r23, r1, 52
    2b2c:	fb21003c 	swi	r25, r1, 60
    2b30:	fb410040 	swi	r26, r1, 64
  ipbus_transaction_t output = ipbus_decode_transaction_header(buf, swapbytes);
    2b34:	b9f4fc74 	brlid	r15, -908	// 27a8 <ipbus_decode_transaction_header>
    2b38:	fb610044 	swi	r27, r1, 68
    2b3c:	e3010024 	lbui	r24, r1, 36

  size_t words_read = 1;

  output.data.words = malloc(output.data.size * sizeof(uint32_t));
    2b40:	b0000000 	imm	0
    2b44:	b9f423f4 	brlid	r15, 9204	// 4f38 <malloc>
    2b48:	60b80004 	muli	r5, r24, 4

  for (unsigned int i = 0; i < output.data.size; ++i) {
    2b4c:	be180204 	beqid	r24, 516		// 2d50
    2b50:	13830000 	addk	r28, r3, r0
    2b54:	12e00000 	addk	r23, r0, r0
    2b58:	32600001 	addik	r19, r0, 1
    uint32_t dataword = network_to_host(cbuffer_value_at(buf, words_read)); 
    2b5c:	10d30000 	addk	r6, r19, r0
    2b60:	b000ffff 	imm	-1
    2b64:	b9f4f438 	brlid	r15, -3016	// 1f9c <cbuffer_value_at>
    2b68:	10b60000 	addk	r5, r22, r0
    2b6c:	10d30000 	addk	r6, r19, r0
    2b70:	10b60000 	addk	r5, r22, r0
    2b74:	b000ffff 	imm	-1
    2b78:	b9f4f424 	brlid	r15, -3036	// 1f9c <cbuffer_value_at>
    2b7c:	13630000 	addk	r27, r3, r0
    2b80:	10d30000 	addk	r6, r19, r0
    2b84:	10b60000 	addk	r5, r22, r0
    2b88:	b000ffff 	imm	-1
    2b8c:	b9f4f410 	brlid	r15, -3056	// 1f9c <cbuffer_value_at>
    2b90:	13430000 	addk	r26, r3, r0
    2b94:	10d30000 	addk	r6, r19, r0
    2b98:	10b60000 	addk	r5, r22, r0
    2b9c:	13230000 	addk	r25, r3, r0
    2ba0:	b000ffff 	imm	-1
    2ba4:	b9f4f3f8 	brlid	r15, -3080	// 1f9c <cbuffer_value_at>
    2ba8:	32730001 	addik	r19, r19, 1
    2bac:	b0000000 	imm	0
    2bb0:	a4daffff 	andi	r6, r26, -1
    2bb4:	611b0100 	muli	r8, r27, 256
    2bb8:	11203000 	addk	r9, r0, r6
    2bbc:	91260041 	srl	r9, r6
    2bc0:	91290041 	srl	r9, r9
    2bc4:	91290041 	srl	r9, r9
    2bc8:	91290041 	srl	r9, r9
    2bcc:	91290041 	srl	r9, r9
    2bd0:	91290041 	srl	r9, r9
    2bd4:	91290041 	srl	r9, r9
    2bd8:	91290041 	srl	r9, r9
    2bdc:	1080c800 	addk	r4, r0, r25
    2be0:	90990041 	srl	r4, r25
    2be4:	90840041 	srl	r4, r4
    2be8:	90840041 	srl	r4, r4
    2bec:	90840041 	srl	r4, r4
    2bf0:	90840041 	srl	r4, r4
    2bf4:	90840041 	srl	r4, r4
    2bf8:	90840041 	srl	r4, r4
    2bfc:	90840041 	srl	r4, r4
    2c00:	81084800 	or	r8, r8, r9
    2c04:	b0000000 	imm	0
    2c08:	a484ff00 	andi	r4, r4, -256
    2c0c:	10c01800 	addk	r6, r0, r3
    2c10:	90c30041 	srl	r6, r3
    2c14:	90c60041 	srl	r6, r6
    2c18:	90c60041 	srl	r6, r6
    2c1c:	90c60041 	srl	r6, r6
    2c20:	90c60041 	srl	r6, r6
    2c24:	90c60041 	srl	r6, r6
    2c28:	90c60041 	srl	r6, r6
    2c2c:	90c60041 	srl	r6, r6
    2c30:	90c60041 	srl	r6, r6
    2c34:	90c60041 	srl	r6, r6
    2c38:	90c60041 	srl	r6, r6
    2c3c:	90c60041 	srl	r6, r6
    2c40:	90c60041 	srl	r6, r6
    2c44:	90c60041 	srl	r6, r6
    2c48:	90c60041 	srl	r6, r6
    2c4c:	90c60041 	srl	r6, r6
    2c50:	90c60041 	srl	r6, r6
    2c54:	90c60041 	srl	r6, r6
    2c58:	90c60041 	srl	r6, r6
    2c5c:	90c60041 	srl	r6, r6
    2c60:	90c60041 	srl	r6, r6
    2c64:	90c60041 	srl	r6, r6
    2c68:	90c60041 	srl	r6, r6
    2c6c:	90c60041 	srl	r6, r6
    2c70:	b0000001 	imm	1
    2c74:	61080000 	muli	r8, r8, 0
    2c78:	80843000 	or	r4, r4, r6
    2c7c:	80844000 	or	r4, r4, r8
    words_read += 1;
    if (swapbytes) {
      dataword = __bswap_32(dataword);
    2c80:	b0000000 	imm	0
    2c84:	a504ffff 	andi	r8, r4, -1
    2c88:	10c02000 	addk	r6, r0, r4
    2c8c:	90c40041 	srl	r6, r4
    2c90:	90c60041 	srl	r6, r6
    2c94:	90c60041 	srl	r6, r6
    2c98:	90c60041 	srl	r6, r6
    2c9c:	90c60041 	srl	r6, r6
    2ca0:	90c60041 	srl	r6, r6
    2ca4:	90c60041 	srl	r6, r6
    2ca8:	90c60041 	srl	r6, r6
    2cac:	90c60041 	srl	r6, r6
    2cb0:	90c60041 	srl	r6, r6
    2cb4:	90c60041 	srl	r6, r6
    2cb8:	90c60041 	srl	r6, r6
    2cbc:	90c60041 	srl	r6, r6
    2cc0:	90c60041 	srl	r6, r6
    2cc4:	90c60041 	srl	r6, r6
    2cc8:	90c60041 	srl	r6, r6
    2ccc:	63280100 	muli	r25, r8, 256
    2cd0:	61660100 	muli	r11, r6, 256
    2cd4:	11804000 	addk	r12, r0, r8
    2cd8:	91880041 	srl	r12, r8
    2cdc:	918c0041 	srl	r12, r12
    2ce0:	918c0041 	srl	r12, r12
    2ce4:	918c0041 	srl	r12, r12
    2ce8:	918c0041 	srl	r12, r12
    2cec:	918c0041 	srl	r12, r12
    2cf0:	918c0041 	srl	r12, r12
    2cf4:	918c0041 	srl	r12, r12
    }
    output.data.words[i] = dataword;
    2cf8:	61570004 	muli	r10, r23, 4

  for (unsigned int i = 0; i < output.data.size; ++i) {
    uint32_t dataword = network_to_host(cbuffer_value_at(buf, words_read)); 
    words_read += 1;
    if (swapbytes) {
      dataword = __bswap_32(dataword);
    2cfc:	b0000000 	imm	0
    2d00:	a56bffff 	andi	r11, r11, -1

  size_t words_read = 1;

  output.data.words = malloc(output.data.size * sizeof(uint32_t));

  for (unsigned int i = 0; i < output.data.size; ++i) {
    2d04:	32f70001 	addik	r23, r23, 1
    uint32_t dataword = network_to_host(cbuffer_value_at(buf, words_read)); 
    words_read += 1;
    if (swapbytes) {
      dataword = __bswap_32(dataword);
    2d08:	81996000 	or	r12, r25, r12
    2d0c:	11003000 	addk	r8, r0, r6
    2d10:	91060041 	srl	r8, r6
    2d14:	91080041 	srl	r8, r8
    2d18:	91080041 	srl	r8, r8
    2d1c:	91080041 	srl	r8, r8
    2d20:	91080041 	srl	r8, r8
    2d24:	91080041 	srl	r8, r8
    2d28:	91080041 	srl	r8, r8
    2d2c:	91080041 	srl	r8, r8

  size_t words_read = 1;

  output.data.words = malloc(output.data.size * sizeof(uint32_t));

  for (unsigned int i = 0; i < output.data.size; ++i) {
    2d30:	1538b803 	cmpu	r9, r24, r23
    uint32_t dataword = network_to_host(cbuffer_value_at(buf, words_read)); 
    words_read += 1;
    if (swapbytes) {
      dataword = __bswap_32(dataword);
    2d34:	b0000001 	imm	1
    2d38:	618c0000 	muli	r12, r12, 0
  output.data.words = malloc(output.data.size * sizeof(uint32_t));

  for (unsigned int i = 0; i < output.data.size; ++i) {
    uint32_t dataword = network_to_host(cbuffer_value_at(buf, words_read)); 
    words_read += 1;
    if (swapbytes) {
    2d3c:	be1d000c 	beqid	r29, 12		// 2d48
    2d40:	810b4000 	or	r8, r11, r8
      dataword = __bswap_32(dataword);
    2d44:	80886000 	or	r4, r8, r12

  size_t words_read = 1;

  output.data.words = malloc(output.data.size * sizeof(uint32_t));

  for (unsigned int i = 0; i < output.data.size; ++i) {
    2d48:	be49fe14 	bltid	r9, -492		// 2b5c
    2d4c:	d88ae000 	sw	r4, r10, r28
    if (swapbytes) {
      dataword = __bswap_32(dataword);
    }
    output.data.words[i] = dataword;
  }
  return output;
    2d50:	e861001c 	lwi	r3, r1, 28
    2d54:	fb9e000c 	swi	r28, r30, 12
    2d58:	f87e0000 	swi	r3, r30, 0
    2d5c:	e8610024 	lwi	r3, r1, 36
    2d60:	f87e0008 	swi	r3, r30, 8
    2d64:	e8610020 	lwi	r3, r1, 32
    2d68:	f31e0008 	sbi	r24, r30, 8
    2d6c:	f87e0004 	swi	r3, r30, 4
}
    2d70:	e9e10000 	lwi	r15, r1, 0
    2d74:	107e0000 	addk	r3, r30, r0
    2d78:	ea61002c 	lwi	r19, r1, 44
    2d7c:	eac10030 	lwi	r22, r1, 48
    2d80:	eae10034 	lwi	r23, r1, 52
    2d84:	eb010038 	lwi	r24, r1, 56
    2d88:	eb21003c 	lwi	r25, r1, 60
    2d8c:	eb410040 	lwi	r26, r1, 64
    2d90:	eb610044 	lwi	r27, r1, 68
    2d94:	eb810048 	lwi	r28, r1, 72
    2d98:	eba1004c 	lwi	r29, r1, 76
    2d9c:	ebc10050 	lwi	r30, r1, 80
    2da0:	b60f0008 	rtsd	r15, 8
    2da4:	30210054 	addik	r1, r1, 84

00002da8 <ipbus_transaction_endocded_size>:

size_t ipbus_transaction_endocded_size(const ipbus_transaction_t* trans) {
    2da8:	10650000 	addk	r3, r5, r0
    2dac:	3021ffe4 	addik	r1, r1, -28
    2db0:	f9e10000 	swi	r15, r1, 0
  return (1 + ipbus_transaction_payload_size(trans->words, trans->type, trans->info)); 
    2db4:	e0a50002 	lbui	r5, r5, 2
    2db8:	e0c30003 	lbui	r6, r3, 3
    2dbc:	b9f4f918 	brlid	r15, -1768	// 26d4 <ipbus_transaction_payload_size>
    2dc0:	e0e30004 	lbui	r7, r3, 4
}
    2dc4:	e9e10000 	lwi	r15, r1, 0
    2dc8:	30630001 	addik	r3, r3, 1
    2dcc:	b60f0008 	rtsd	r15, 8
    2dd0:	3021001c 	addik	r1, r1, 28

00002dd4 <ipbus_transaction_header>:
    uint32_t words,
    uint32_t type_id,
    uint32_t info_code) {
  uint32_t output = 
      (protocol << 28) |
      ((transaction_id & 0xfff) << 16) |
    2dd4:	a4c60fff 	andi	r6, r6, 4095
    2dd8:	b0000001 	imm	1
    2ddc:	60660000 	muli	r3, r6, 0
    uint32_t transaction_id,
    uint32_t words,
    uint32_t type_id,
    uint32_t info_code) {
  uint32_t output = 
      (protocol << 28) |
    2de0:	b0001000 	imm	4096
    2de4:	60a50000 	muli	r5, r5, 0
      ((transaction_id & 0xfff) << 16) |
      ((words & 0xff) << 8) |
    2de8:	60e70100 	muli	r7, r7, 256
    uint32_t transaction_id,
    uint32_t words,
    uint32_t type_id,
    uint32_t info_code) {
  uint32_t output = 
      (protocol << 28) |
    2dec:	80632800 	or	r3, r3, r5
      ((transaction_id & 0xfff) << 16) |
      ((words & 0xff) << 8) |
    2df0:	b0000000 	imm	0
    2df4:	a4e7ffff 	andi	r7, r7, -1
      ((type_id & 0xf) << 4) |
    2df8:	61080010 	muli	r8, r8, 16
    uint32_t words,
    uint32_t type_id,
    uint32_t info_code) {
  uint32_t output = 
      (protocol << 28) |
      ((transaction_id & 0xfff) << 16) |
    2dfc:	80633800 	or	r3, r3, r7
      ((words & 0xff) << 8) |
      ((type_id & 0xf) << 4) |
    2e00:	a50800ff 	andi	r8, r8, 255
    uint32_t type_id,
    uint32_t info_code) {
  uint32_t output = 
      (protocol << 28) |
      ((transaction_id & 0xfff) << 16) |
      ((words & 0xff) << 8) |
    2e04:	80634000 	or	r3, r3, r8
      ((type_id & 0xf) << 4) |
      (info_code & 0x0f);
    2e08:	a529000f 	andi	r9, r9, 15
  return output;
}
    2e0c:	b60f0008 	rtsd	r15, 8
    2e10:	80634800 	or	r3, r3, r9

00002e14 <ipbus_encode_transaction>:

void ipbus_encode_transaction(CircularBuffer* into, const ipbus_transaction_t* transaction, int swapbytes) {
    2e14:	3021ffd4 	addik	r1, r1, -44
    2e18:	fa61001c 	swi	r19, r1, 28
    2e1c:	12660000 	addk	r19, r6, r0
    2e20:	fae10024 	swi	r23, r1, 36
    2e24:	fb010028 	swi	r24, r1, 40
    2e28:	f9e10000 	swi	r15, r1, 0
    2e2c:	fac10020 	swi	r22, r1, 32
    2e30:	12e50000 	addk	r23, r5, r0
  uint32_t headerword = ipbus_transaction_header(
    2e34:	e0c60004 	lbui	r6, r6, 4
    2e38:	e4b30000 	lhui	r5, r19, 0
    2e3c:	e0930002 	lbui	r4, r19, 2
    2e40:	e0730003 	lbui	r3, r19, 3
  uint32_t output = 
      (protocol << 28) |
      ((transaction_id & 0xfff) << 16) |
      ((words & 0xff) << 8) |
      ((type_id & 0xf) << 4) |
      (info_code & 0x0f);
    2e44:	a4c6000f 	andi	r6, r6, 15
    uint32_t words,
    uint32_t type_id,
    uint32_t info_code) {
  uint32_t output = 
      (protocol << 28) |
      ((transaction_id & 0xfff) << 16) |
    2e48:	a4a50fff 	andi	r5, r5, 4095
    uint32_t transaction_id,
    uint32_t words,
    uint32_t type_id,
    uint32_t info_code) {
  uint32_t output = 
      (protocol << 28) |
    2e4c:	b0002000 	imm	8192
    2e50:	a0c60000 	ori	r6, r6, 0
      ((transaction_id & 0xfff) << 16) |
    2e54:	b0000001 	imm	1
    2e58:	60a50000 	muli	r5, r5, 0
    2e5c:	80c62800 	or	r6, r6, r5
      ((words & 0xff) << 8) |
    2e60:	60840100 	muli	r4, r4, 256
      ((type_id & 0xf) << 4) |
    2e64:	60630010 	muli	r3, r3, 16
    uint32_t type_id,
    uint32_t info_code) {
  uint32_t output = 
      (protocol << 28) |
      ((transaction_id & 0xfff) << 16) |
      ((words & 0xff) << 8) |
    2e68:	80c62000 	or	r6, r6, r4
      ((type_id & 0xf) << 4) |
    2e6c:	a46300ff 	andi	r3, r3, 255
      (info_code & 0x0f);
  return output;
}

void ipbus_encode_transaction(CircularBuffer* into, const ipbus_transaction_t* transaction, int swapbytes) {
    2e70:	13070000 	addk	r24, r7, r0
  uint32_t headerword = ipbus_transaction_header(
      2, transaction->id, transaction->words, transaction->type, transaction->info);
  if (swapbytes) {
    2e74:	be0700c0 	beqid	r7, 192		// 2f34
    2e78:	80c61800 	or	r6, r6, r3
    headerword = __bswap_32(headerword);
    2e7c:	b0000000 	imm	0
    2e80:	a486ffff 	andi	r4, r6, -1
    2e84:	10603000 	addk	r3, r0, r6
    2e88:	90660041 	srl	r3, r6
    2e8c:	90630041 	srl	r3, r3
    2e90:	90630041 	srl	r3, r3
    2e94:	90630041 	srl	r3, r3
    2e98:	90630041 	srl	r3, r3
    2e9c:	90630041 	srl	r3, r3
    2ea0:	90630041 	srl	r3, r3
    2ea4:	90630041 	srl	r3, r3
    2ea8:	90630041 	srl	r3, r3
    2eac:	90630041 	srl	r3, r3
    2eb0:	90630041 	srl	r3, r3
    2eb4:	90630041 	srl	r3, r3
    2eb8:	90630041 	srl	r3, r3
    2ebc:	90630041 	srl	r3, r3
    2ec0:	90630041 	srl	r3, r3
    2ec4:	90630041 	srl	r3, r3
    2ec8:	60e40100 	muli	r7, r4, 256
    2ecc:	60c30100 	muli	r6, r3, 256
    2ed0:	10a02000 	addk	r5, r0, r4
    2ed4:	90a40041 	srl	r5, r4
    2ed8:	90a50041 	srl	r5, r5
    2edc:	90a50041 	srl	r5, r5
    2ee0:	90a50041 	srl	r5, r5
    2ee4:	90a50041 	srl	r5, r5
    2ee8:	90a50041 	srl	r5, r5
    2eec:	90a50041 	srl	r5, r5
    2ef0:	90a50041 	srl	r5, r5
    2ef4:	b0000000 	imm	0
    2ef8:	a4c6ffff 	andi	r6, r6, -1
    2efc:	80a72800 	or	r5, r7, r5
    2f00:	10801800 	addk	r4, r0, r3
    2f04:	90830041 	srl	r4, r3
    2f08:	90840041 	srl	r4, r4
    2f0c:	90840041 	srl	r4, r4
    2f10:	90840041 	srl	r4, r4
    2f14:	90840041 	srl	r4, r4
    2f18:	90840041 	srl	r4, r4
    2f1c:	90840041 	srl	r4, r4
    2f20:	90840041 	srl	r4, r4
    2f24:	b0000001 	imm	1
    2f28:	60650000 	muli	r3, r5, 0
    2f2c:	80c62000 	or	r6, r6, r4
    2f30:	80c61800 	or	r6, r6, r3
  }
  cbuffer_push_back_net(into, headerword);
    2f34:	b000ffff 	imm	-1
    2f38:	b9f4f2a8 	brlid	r15, -3416	// 21e0 <cbuffer_push_back_net>
    2f3c:	10b70000 	addk	r5, r23, r0
  for (size_t i = 0; i < transaction->data.size; ++i) {
    2f40:	e0730008 	lbui	r3, r19, 8
    2f44:	be0300f0 	beqid	r3, 240		// 3034
    2f48:	12c00000 	addk	r22, r0, r0
    uint32_t datum = transaction->data.words[i];
    2f4c:	e893000c 	lwi	r4, r19, 12
    2f50:	60760004 	muli	r3, r22, 4
    if (swapbytes) {
      datum = __bswap_32(datum);
    }
    cbuffer_push_back_net(into, datum);
    2f54:	10b70000 	addk	r5, r23, r0
      2, transaction->id, transaction->words, transaction->type, transaction->info);
  if (swapbytes) {
    headerword = __bswap_32(headerword);
  }
  cbuffer_push_back_net(into, headerword);
  for (size_t i = 0; i < transaction->data.size; ++i) {
    2f58:	32d60001 	addik	r22, r22, 1
    uint32_t datum = transaction->data.words[i];
    if (swapbytes) {
    2f5c:	be1800c0 	beqid	r24, 192		// 301c
    2f60:	c8c32000 	lw	r6, r3, r4
      datum = __bswap_32(datum);
    2f64:	b0000000 	imm	0
    2f68:	a486ffff 	andi	r4, r6, -1
    2f6c:	10603000 	addk	r3, r0, r6
    2f70:	90660041 	srl	r3, r6
    2f74:	90630041 	srl	r3, r3
    2f78:	90630041 	srl	r3, r3
    2f7c:	90630041 	srl	r3, r3
    2f80:	90630041 	srl	r3, r3
    2f84:	90630041 	srl	r3, r3
    2f88:	90630041 	srl	r3, r3
    2f8c:	90630041 	srl	r3, r3
    2f90:	90630041 	srl	r3, r3
    2f94:	90630041 	srl	r3, r3
    2f98:	90630041 	srl	r3, r3
    2f9c:	90630041 	srl	r3, r3
    2fa0:	90630041 	srl	r3, r3
    2fa4:	90630041 	srl	r3, r3
    2fa8:	90630041 	srl	r3, r3
    2fac:	90630041 	srl	r3, r3
    2fb0:	61040100 	muli	r8, r4, 256
    2fb4:	60c30100 	muli	r6, r3, 256
    2fb8:	10e02000 	addk	r7, r0, r4
    2fbc:	90e40041 	srl	r7, r4
    2fc0:	90e70041 	srl	r7, r7
    2fc4:	90e70041 	srl	r7, r7
    2fc8:	90e70041 	srl	r7, r7
    2fcc:	90e70041 	srl	r7, r7
    2fd0:	90e70041 	srl	r7, r7
    2fd4:	90e70041 	srl	r7, r7
    2fd8:	90e70041 	srl	r7, r7
    2fdc:	b0000000 	imm	0
    2fe0:	a4c6ffff 	andi	r6, r6, -1
    2fe4:	80e83800 	or	r7, r8, r7
    2fe8:	10801800 	addk	r4, r0, r3
    2fec:	90830041 	srl	r4, r3
    2ff0:	90840041 	srl	r4, r4
    2ff4:	90840041 	srl	r4, r4
    2ff8:	90840041 	srl	r4, r4
    2ffc:	90840041 	srl	r4, r4
    3000:	90840041 	srl	r4, r4
    3004:	90840041 	srl	r4, r4
    3008:	90840041 	srl	r4, r4
    300c:	b0000001 	imm	1
    3010:	60670000 	muli	r3, r7, 0
    3014:	80c62000 	or	r6, r6, r4
    3018:	80c61800 	or	r6, r6, r3
    }
    cbuffer_push_back_net(into, datum);
    301c:	b000ffff 	imm	-1
    3020:	b9f4f1c0 	brlid	r15, -3648	// 21e0 <cbuffer_push_back_net>
    3024:	80000000 	or	r0, r0, r0
      2, transaction->id, transaction->words, transaction->type, transaction->info);
  if (swapbytes) {
    headerword = __bswap_32(headerword);
  }
  cbuffer_push_back_net(into, headerword);
  for (size_t i = 0; i < transaction->data.size; ++i) {
    3028:	e0730008 	lbui	r3, r19, 8
    302c:	1463b003 	cmpu	r3, r3, r22
    3030:	bc43ff1c 	blti	r3, -228		// 2f4c
    if (swapbytes) {
      datum = __bswap_32(datum);
    }
    cbuffer_push_back_net(into, datum);
  }
}
    3034:	e9e10000 	lwi	r15, r1, 0
    3038:	ea61001c 	lwi	r19, r1, 28
    303c:	eac10020 	lwi	r22, r1, 32
    3040:	eae10024 	lwi	r23, r1, 36
    3044:	eb010028 	lwi	r24, r1, 40
    3048:	b60f0008 	rtsd	r15, 8
    304c:	3021002c 	addik	r1, r1, 44

00003050 <ipbus_packet_header>:

uint32_t ipbus_packet_header(uint32_t packet_id, uint32_t type) {
  return 0x200000f0 | ((0xffff & packet_id) << 8) | (0xf & type);
    3050:	b0000000 	imm	0
    3054:	a4a5ffff 	andi	r5, r5, -1
    3058:	60650100 	muli	r3, r5, 256
    305c:	a4c6000f 	andi	r6, r6, 15
    3060:	80633000 	or	r3, r3, r6
}
    3064:	b0002000 	imm	8192
    3068:	a06300f0 	ori	r3, r3, 240
    306c:	b60f0008 	rtsd	r15, 8
    3070:	80000000 	or	r0, r0, r0

00003074 <ipbus_process_input_stream>:
#include "macrologger.h"
#include "protocol.h"
#include "serialization.h"
#include "transactionhandler.h"

size_t ipbus_process_input_stream(Client* client) {
    3074:	3021ffd0 	addik	r1, r1, -48
    3078:	fa61001c 	swi	r19, r1, 28
    307c:	12650000 	addk	r19, r5, r0
    3080:	fac10020 	swi	r22, r1, 32
    3084:	fae10024 	swi	r23, r1, 36
    3088:	fb010028 	swi	r24, r1, 40
    308c:	f9e10000 	swi	r15, r1, 0
    3090:	fb21002c 	swi	r25, r1, 44
    3094:	32e50018 	addik	r23, r5, 24
  // check the state of the stream, and update the clients endian-ness (maybe)
  int stream_state = ipbus_stream_state(client->inputstream, &(client->swapbytes));
    3098:	10d70000 	addk	r6, r23, r0
    309c:	e8b30000 	lwi	r5, r19, 0
  size_t data_processed = 0;
  switch (stream_state) {
    30a0:	33000004 	addik	r24, r0, 4
#include "serialization.h"
#include "transactionhandler.h"

size_t ipbus_process_input_stream(Client* client) {
  // check the state of the stream, and update the clients endian-ness (maybe)
  int stream_state = ipbus_stream_state(client->inputstream, &(client->swapbytes));
    30a4:	b000ffff 	imm	-1
    30a8:	b9f4f8d4 	brlid	r15, -1836	// 297c <ipbus_stream_state>
    30ac:	12c00000 	addk	r22, r0, r0
  size_t data_processed = 0;
  switch (stream_state) {
    30b0:	1483c003 	cmpu	r4, r3, r24
    30b4:	be440070 	bltid	r4, 112		// 3124
    30b8:	60630004 	muli	r3, r3, 4
    30bc:	b0000000 	imm	0
    30c0:	3063d758 	addik	r3, r3, -10408
    30c4:	e8630000 	lwi	r3, r3, 0
    30c8:	98081800 	bra	r3
      }

    case IPBUS_ISTREAM_PACKET:
    case IPBUS_ISTREAM_PACKET_SWP_ORD:
      {
        uint32_t headerword = cbuffer_value_at_net(client->inputstream, 0);
    30cc:	e8b30000 	lwi	r5, r19, 0
    30d0:	b000ffff 	imm	-1
    30d4:	b9f4eee4 	brlid	r15, -4380	// 1fb8 <cbuffer_value_at_net>
    30d8:	10c00000 	addk	r6, r0, r0
        // now pop the data we processed off the input buffer
        cbuffer_deletefront(client->inputstream, 1);
    30dc:	e8b30000 	lwi	r5, r19, 0
      }

    case IPBUS_ISTREAM_PACKET:
    case IPBUS_ISTREAM_PACKET_SWP_ORD:
      {
        uint32_t headerword = cbuffer_value_at_net(client->inputstream, 0);
    30e0:	13230000 	addk	r25, r3, r0
        // now pop the data we processed off the input buffer
        cbuffer_deletefront(client->inputstream, 1);
    30e4:	b000ffff 	imm	-1
    30e8:	b9f4f2c8 	brlid	r15, -3384	// 23b0 <cbuffer_deletefront>
    30ec:	30c00001 	addik	r6, r0, 1
        LOG_DEBUG("Got new header packet %"PRIx32, headerword);
        // by definition this is in the correct endianness for the client
        cbuffer_push_back_net(client->outputstream, headerword);
    30f0:	e8b30004 	lwi	r5, r19, 4
    30f4:	b000ffff 	imm	-1
    30f8:	b9f4f0e8 	brlid	r15, -3864	// 21e0 <cbuffer_push_back_net>
    30fc:	10d90000 	addk	r6, r25, r0
        // pop off the data we've just processed
        data_processed += 1;
    3100:	30600001 	addik	r3, r0, 1
        break;
    3104:	12d61800 	addk	r22, r22, r3
#include "serialization.h"
#include "transactionhandler.h"

size_t ipbus_process_input_stream(Client* client) {
  // check the state of the stream, and update the clients endian-ness (maybe)
  int stream_state = ipbus_stream_state(client->inputstream, &(client->swapbytes));
    3108:	e8b30000 	lwi	r5, r19, 0
    310c:	b000ffff 	imm	-1
    3110:	b9f4f86c 	brlid	r15, -1940	// 297c <ipbus_stream_state>
    3114:	10d70000 	addk	r6, r23, r0
  size_t data_processed = 0;
  switch (stream_state) {
    3118:	1483c003 	cmpu	r4, r3, r24
    311c:	bea4ffa0 	bgeid	r4, -96		// 30bc
    3120:	60630004 	muli	r3, r3, 4
#include "transactionhandler.h"

size_t ipbus_process_input_stream(Client* client) {
  // check the state of the stream, and update the clients endian-ness (maybe)
  int stream_state = ipbus_stream_state(client->inputstream, &(client->swapbytes));
  size_t data_processed = 0;
    3124:	10600000 	addk	r3, r0, r0
        LOG_DEBUG("Got new header packet %"PRIx32, headerword);
        // by definition this is in the correct endianness for the client
        cbuffer_push_back_net(client->outputstream, headerword);
        // pop off the data we've just processed
        data_processed += 1;
        break;
    3128:	b810ffe0 	brid	-32		// 3108
    312c:	12d61800 	addk	r22, r22, r3
        LOG_DEBUG("Partial transaction");
        return 0; // and wait for more data
  }
  // recurse to process more data, if there is any.
  return data_processed + ipbus_process_input_stream(client);
}
    3130:	10760000 	addk	r3, r22, r0
    3134:	e9e10000 	lwi	r15, r1, 0
    3138:	ea61001c 	lwi	r19, r1, 28
    313c:	eac10020 	lwi	r22, r1, 32
    3140:	eae10024 	lwi	r23, r1, 36
    3144:	eb010028 	lwi	r24, r1, 40
    3148:	eb21002c 	lwi	r25, r1, 44
    314c:	b60f0008 	rtsd	r15, 8
    3150:	30210030 	addik	r1, r1, 48

    case IPBUS_ISTREAM_FULL_TRANS: 
      { 
        LOG_DEBUG("Processing full transaction");
        // why the brace: http://stackoverflow.com/questions/1231198/declaring-variables-inside-a-switch-statement
        data_processed += handle_transaction_stream(client->inputstream, client->swapbytes, client->outputstream);
    3154:	e8b30000 	lwi	r5, r19, 0
    3158:	e8d30018 	lwi	r6, r19, 24
    315c:	b0000000 	imm	0
    3160:	b9f40010 	brlid	r15, 16	// 3170 <handle_transaction_stream>
    3164:	e8f30004 	lwi	r7, r19, 4
        LOG_DEBUG("Got new header packet %"PRIx32, headerword);
        // by definition this is in the correct endianness for the client
        cbuffer_push_back_net(client->outputstream, headerword);
        // pop off the data we've just processed
        data_processed += 1;
        break;
    3168:	b810ffa0 	brid	-96		// 3108
    316c:	12d61800 	addk	r22, r22, r3

00003170 <handle_transaction_stream>:
  }

  return output;
}

int handle_transaction_stream(CircularBuffer* input, int swapbytes, CircularBuffer* output) {
    3170:	3021ff98 	addik	r1, r1, -104
    3174:	fb21005c 	swi	r25, r1, 92
    3178:	13260000 	addk	r25, r6, r0
    317c:	fb610064 	swi	r27, r1, 100
  ipbus_transaction_t trans_req = ipbus_decode_transaction(input, swapbytes);
    3180:	10c50000 	addk	r6, r5, r0
  }

  return output;
}

int handle_transaction_stream(CircularBuffer* input, int swapbytes, CircularBuffer* output) {
    3184:	13670000 	addk	r27, r7, r0
  ipbus_transaction_t trans_req = ipbus_decode_transaction(input, swapbytes);
    3188:	10f90000 	addk	r7, r25, r0
  }

  return output;
}

int handle_transaction_stream(CircularBuffer* input, int swapbytes, CircularBuffer* output) {
    318c:	fa61004c 	swi	r19, r1, 76
    3190:	12650000 	addk	r19, r5, r0
  ipbus_transaction_t trans_req = ipbus_decode_transaction(input, swapbytes);
    3194:	30a1003c 	addik	r5, r1, 60
  }

  return output;
}

int handle_transaction_stream(CircularBuffer* input, int swapbytes, CircularBuffer* output) {
    3198:	f9e10000 	swi	r15, r1, 0
    319c:	fae10054 	swi	r23, r1, 84
    31a0:	fb010058 	swi	r24, r1, 88
    31a4:	fb410060 	swi	r26, r1, 96
  ipbus_transaction_t trans_req = ipbus_decode_transaction(input, swapbytes);
    31a8:	b000ffff 	imm	-1
    31ac:	b9f4f94c 	brlid	r15, -1716	// 2af8 <ipbus_decode_transaction>
    31b0:	fac10050 	swi	r22, r1, 80
  LOG_DEBUG("Processing transaction %03x", trans_req.id);
  // indicate how much we consumed so we can delete it from the input stream
  int wordsprocessed = ipbus_transaction_endocded_size(&trans_req);
    31b4:	b000ffff 	imm	-1
    31b8:	b9f4fbf0 	brlid	r15, -1040	// 2da8 <ipbus_transaction_endocded_size>
    31bc:	30a1003c 	addik	r5, r1, 60
  cbuffer_deletefront(input, wordsprocessed);
    31c0:	10b30000 	addk	r5, r19, r0
    31c4:	10c30000 	addk	r6, r3, r0
    31c8:	b000ffff 	imm	-1
    31cc:	b9f4f1e4 	brlid	r15, -3612	// 23b0 <cbuffer_deletefront>
    31d0:	13030000 	addk	r24, r3, r0
#include "handlers.h"

static ipbus_transaction_t ipbus_process_transaction(const ipbus_transaction_t* input) {
  ipbus_transaction_t output;
  output.id = input->id;
  output.type = input->type;
    31d4:	e261003f 	lbui	r19, r1, 63
  output.info = IPBUS_INFO_SUCCESS;
  output.words = input->words;
  output.data.words = NULL;
  output.data.size = 0;

  switch (output.type) {
    31d8:	30600005 	addik	r3, r0, 5
#include "serialization.h"
#include "handlers.h"

static ipbus_transaction_t ipbus_process_transaction(const ipbus_transaction_t* input) {
  ipbus_transaction_t output;
  output.id = input->id;
    31dc:	e741003c 	lhui	r26, r1, 60
  output.info = IPBUS_INFO_SUCCESS;
  output.words = input->words;
  output.data.words = NULL;
  output.data.size = 0;

  switch (output.type) {
    31e0:	14731803 	cmpu	r3, r19, r3
    31e4:	be430164 	bltid	r3, 356		// 3348
    31e8:	e2e1003e 	lbui	r23, r1, 62
    31ec:	60730004 	muli	r3, r19, 4
    31f0:	b0000000 	imm	0
    31f4:	3063d76c 	addik	r3, r3, -10388
    31f8:	e8630000 	lwi	r3, r3, 0
    31fc:	98081800 	bra	r3
    case IPBUS_NIWRITE:
      handle_IPBUS_NIWRITE(input->words, &(input->data));
      break;
    case IPBUS_RMW:
      output.data.size = 1;
      output.data.words = malloc(sizeof(uint32_t));
    3200:	b0000000 	imm	0
    3204:	b9f41d34 	brlid	r15, 7476	// 4f38 <malloc>
    3208:	30a00004 	addik	r5, r0, 4
    320c:	12c30000 	addk	r22, r3, r0
      output.data.words[0] = handle_IPBUS_RMW(
          input->data.words[0], input->data.words[1], input->data.words[2]);
    3210:	e8610048 	lwi	r3, r1, 72
      handle_IPBUS_NIWRITE(input->words, &(input->data));
      break;
    case IPBUS_RMW:
      output.data.size = 1;
      output.data.words = malloc(sizeof(uint32_t));
      output.data.words[0] = handle_IPBUS_RMW(
    3214:	e8a30000 	lwi	r5, r3, 0
    3218:	e8c30004 	lwi	r6, r3, 4
    321c:	b0000000 	imm	0
    3220:	b9f402b8 	brlid	r15, 696	// 34d8 <handle_IPBUS_RMW>
    3224:	e8e30008 	lwi	r7, r3, 8
    3228:	f8760000 	swi	r3, r22, 0
      break;
    case IPBUS_NIWRITE:
      handle_IPBUS_NIWRITE(input->words, &(input->data));
      break;
    case IPBUS_RMW:
      output.data.size = 1;
    322c:	30800001 	addik	r4, r0, 1
      output.data.words[0] = handle_IPBUS_RMWSUM(
          input->data.words[0], input->data.words[1]);
      break;
  }

  return output;
    3230:	e8610020 	lwi	r3, r1, 32
  // indicate how much we consumed so we can delete it from the input stream
  int wordsprocessed = ipbus_transaction_endocded_size(&trans_req);
  cbuffer_deletefront(input, wordsprocessed);
  // perform request action(s) and prepare response
  ipbus_transaction_t trans_resp = ipbus_process_transaction(&trans_req);
  ipbus_encode_transaction(output, &trans_resp, swapbytes);
    3234:	10bb0000 	addk	r5, r27, r0
    3238:	10f90000 	addk	r7, r25, r0
      output.data.words[0] = handle_IPBUS_RMWSUM(
          input->data.words[0], input->data.words[1]);
      break;
  }

  return output;
    323c:	f8610030 	swi	r3, r1, 48
    3240:	e8610024 	lwi	r3, r1, 36
  // indicate how much we consumed so we can delete it from the input stream
  int wordsprocessed = ipbus_transaction_endocded_size(&trans_req);
  cbuffer_deletefront(input, wordsprocessed);
  // perform request action(s) and prepare response
  ipbus_transaction_t trans_resp = ipbus_process_transaction(&trans_req);
  ipbus_encode_transaction(output, &trans_resp, swapbytes);
    3244:	30c1002c 	addik	r6, r1, 44
      output.data.words[0] = handle_IPBUS_RMWSUM(
          input->data.words[0], input->data.words[1]);
      break;
  }

  return output;
    3248:	f741002c 	shi	r26, r1, 44
    324c:	f8610034 	swi	r3, r1, 52
    3250:	f2e1002e 	sbi	r23, r1, 46
    3254:	f261002f 	sbi	r19, r1, 47
    3258:	fac10038 	swi	r22, r1, 56
    325c:	f0010030 	sbi	r0, r1, 48
  // indicate how much we consumed so we can delete it from the input stream
  int wordsprocessed = ipbus_transaction_endocded_size(&trans_req);
  cbuffer_deletefront(input, wordsprocessed);
  // perform request action(s) and prepare response
  ipbus_transaction_t trans_resp = ipbus_process_transaction(&trans_req);
  ipbus_encode_transaction(output, &trans_resp, swapbytes);
    3260:	b000ffff 	imm	-1
    3264:	b9f4fbb0 	brlid	r15, -1104	// 2e14 <ipbus_encode_transaction>
    3268:	f0810034 	sbi	r4, r1, 52
  return wordsprocessed;
}
    326c:	10780000 	addk	r3, r24, r0
    3270:	e9e10000 	lwi	r15, r1, 0
    3274:	ea61004c 	lwi	r19, r1, 76
    3278:	eac10050 	lwi	r22, r1, 80
    327c:	eae10054 	lwi	r23, r1, 84
    3280:	eb010058 	lwi	r24, r1, 88
    3284:	eb21005c 	lwi	r25, r1, 92
    3288:	eb410060 	lwi	r26, r1, 96
    328c:	eb610064 	lwi	r27, r1, 100
    3290:	b60f0008 	rtsd	r15, 8
    3294:	30210068 	addik	r1, r1, 104
      output.data.words[0] = handle_IPBUS_RMW(
          input->data.words[0], input->data.words[1], input->data.words[2]);
      break;
    case IPBUS_RMWSUM:
      output.data.size = 1;
      output.data.words = malloc(sizeof(uint32_t));
    3298:	b0000000 	imm	0
    329c:	b9f41c9c 	brlid	r15, 7324	// 4f38 <malloc>
    32a0:	30a00004 	addik	r5, r0, 4
    32a4:	12c30000 	addk	r22, r3, r0
      output.data.words[0] = handle_IPBUS_RMWSUM(
          input->data.words[0], input->data.words[1]);
    32a8:	e8610048 	lwi	r3, r1, 72
          input->data.words[0], input->data.words[1], input->data.words[2]);
      break;
    case IPBUS_RMWSUM:
      output.data.size = 1;
      output.data.words = malloc(sizeof(uint32_t));
      output.data.words[0] = handle_IPBUS_RMWSUM(
    32ac:	e8a30000 	lwi	r5, r3, 0
    32b0:	b0000000 	imm	0
    32b4:	b9f40240 	brlid	r15, 576	// 34f4 <handle_IPBUS_RMWSUM>
    32b8:	e8c30004 	lwi	r6, r3, 4
    32bc:	f8760000 	swi	r3, r22, 0
      output.data.words = malloc(sizeof(uint32_t));
      output.data.words[0] = handle_IPBUS_RMW(
          input->data.words[0], input->data.words[1], input->data.words[2]);
      break;
    case IPBUS_RMWSUM:
      output.data.size = 1;
    32c0:	b810ff70 	brid	-144		// 3230
    32c4:	30800001 	addik	r4, r0, 1
  output.data.words = NULL;
  output.data.size = 0;

  switch (output.type) {
    case IPBUS_READ:
      output.data = handle_IPBUS_READ(input->words, input->data.words[0]);
    32c8:	e8610048 	lwi	r3, r1, 72
    32cc:	10d70000 	addk	r6, r23, r0
    32d0:	30a10024 	addik	r5, r1, 36
    32d4:	b0000000 	imm	0
    32d8:	b9f4007c 	brlid	r15, 124	// 3354 <handle_IPBUS_READ>
    32dc:	e8e30000 	lwi	r7, r3, 0
    32e0:	e0810024 	lbui	r4, r1, 36
    32e4:	b810ff4c 	brid	-180		// 3230
    32e8:	eac10028 	lwi	r22, r1, 40
      break;
    case IPBUS_NIREAD:
      output.data = handle_IPBUS_NIREAD(input->words, input->data.words[0]);
      break;
    case IPBUS_WRITE:
      handle_IPBUS_WRITE(input->words, &(input->data));
    32ec:	10b70000 	addk	r5, r23, r0
    32f0:	b0000000 	imm	0
    32f4:	b9f40160 	brlid	r15, 352	// 3454 <handle_IPBUS_WRITE>
    32f8:	30c10044 	addik	r6, r1, 68
  output.id = input->id;
  output.type = input->type;
  output.info = IPBUS_INFO_SUCCESS;
  output.words = input->words;
  output.data.words = NULL;
  output.data.size = 0;
    32fc:	10800000 	addk	r4, r0, r0
  ipbus_transaction_t output;
  output.id = input->id;
  output.type = input->type;
  output.info = IPBUS_INFO_SUCCESS;
  output.words = input->words;
  output.data.words = NULL;
    3300:	b810ff30 	brid	-208		// 3230
    3304:	12c40000 	addk	r22, r4, r0
  switch (output.type) {
    case IPBUS_READ:
      output.data = handle_IPBUS_READ(input->words, input->data.words[0]);
      break;
    case IPBUS_NIREAD:
      output.data = handle_IPBUS_NIREAD(input->words, input->data.words[0]);
    3308:	e8610048 	lwi	r3, r1, 72
    330c:	10d70000 	addk	r6, r23, r0
    3310:	30a10024 	addik	r5, r1, 36
    3314:	b0000000 	imm	0
    3318:	b9f400c0 	brlid	r15, 192	// 33d8 <handle_IPBUS_NIREAD>
    331c:	e8e30000 	lwi	r7, r3, 0
    3320:	e0810024 	lbui	r4, r1, 36
    3324:	b810ff0c 	brid	-244		// 3230
    3328:	eac10028 	lwi	r22, r1, 40
      break;
    case IPBUS_WRITE:
      handle_IPBUS_WRITE(input->words, &(input->data));
      break;
    case IPBUS_NIWRITE:
      handle_IPBUS_NIWRITE(input->words, &(input->data));
    332c:	10b70000 	addk	r5, r23, r0
    3330:	b0000000 	imm	0
    3334:	b9f4015c 	brlid	r15, 348	// 3490 <handle_IPBUS_NIWRITE>
    3338:	30c10044 	addik	r6, r1, 68
  output.id = input->id;
  output.type = input->type;
  output.info = IPBUS_INFO_SUCCESS;
  output.words = input->words;
  output.data.words = NULL;
  output.data.size = 0;
    333c:	10800000 	addk	r4, r0, r0
  ipbus_transaction_t output;
  output.id = input->id;
  output.type = input->type;
  output.info = IPBUS_INFO_SUCCESS;
  output.words = input->words;
  output.data.words = NULL;
    3340:	b810fef0 	brid	-272		// 3230
    3344:	12c40000 	addk	r22, r4, r0
  output.data.size = 0;
    3348:	10800000 	addk	r4, r0, r0
  ipbus_transaction_t output;
  output.id = input->id;
  output.type = input->type;
  output.info = IPBUS_INFO_SUCCESS;
  output.words = input->words;
  output.data.words = NULL;
    334c:	b810fee4 	brid	-284		// 3230
    3350:	12c40000 	addk	r22, r4, r0

00003354 <handle_IPBUS_READ>:
#include "handlers.h"

#include <inttypes.h>

// Read functions return a buffer of data
ipbus_payload_t handle_IPBUS_READ(uint8_t nwords, uint32_t base_address) {
    3354:	3021ffd0 	addik	r1, r1, -48
    3358:	fb010028 	swi	r24, r1, 40
  LOG_DEBUG("==> IPBUS_READ     nwords: %"PRIx8" @ addr: %"PRIx32, nwords, base_address);
  ipbus_payload_t output;
  output.size = nwords;
  output.words = malloc(nwords * sizeof(uint32_t));
    335c:	63060004 	muli	r24, r6, 4
#include "handlers.h"

#include <inttypes.h>

// Read functions return a buffer of data
ipbus_payload_t handle_IPBUS_READ(uint8_t nwords, uint32_t base_address) {
    3360:	fa61001c 	swi	r19, r1, 28
    3364:	12650000 	addk	r19, r5, r0
  LOG_DEBUG("==> IPBUS_READ     nwords: %"PRIx8" @ addr: %"PRIx32, nwords, base_address);
  ipbus_payload_t output;
  output.size = nwords;
  output.words = malloc(nwords * sizeof(uint32_t));
    3368:	10b80000 	addk	r5, r24, r0
#include "handlers.h"

#include <inttypes.h>

// Read functions return a buffer of data
ipbus_payload_t handle_IPBUS_READ(uint8_t nwords, uint32_t base_address) {
    336c:	f9e10000 	swi	r15, r1, 0
    3370:	fac10020 	swi	r22, r1, 32
    3374:	fae10024 	swi	r23, r1, 36
    3378:	fb21002c 	swi	r25, r1, 44
    337c:	12e60000 	addk	r23, r6, r0
  LOG_DEBUG("==> IPBUS_READ     nwords: %"PRIx8" @ addr: %"PRIx32, nwords, base_address);
  ipbus_payload_t output;
  output.size = nwords;
  output.words = malloc(nwords * sizeof(uint32_t));
    3380:	b0000000 	imm	0
    3384:	b9f41bb4 	brlid	r15, 7092	// 4f38 <malloc>
    3388:	13270000 	addk	r25, r7, r0
  memcpy(output.words, membase + base_address, nwords * sizeof(uint32_t));
    338c:	b0000000 	imm	0
    3390:	e8c0eae8 	lwi	r6, r0, -5400	// eae8 <membase>
// Read functions return a buffer of data
ipbus_payload_t handle_IPBUS_READ(uint8_t nwords, uint32_t base_address) {
  LOG_DEBUG("==> IPBUS_READ     nwords: %"PRIx8" @ addr: %"PRIx32, nwords, base_address);
  ipbus_payload_t output;
  output.size = nwords;
  output.words = malloc(nwords * sizeof(uint32_t));
    3394:	12c30000 	addk	r22, r3, r0
  memcpy(output.words, membase + base_address, nwords * sizeof(uint32_t));
    3398:	10f80000 	addk	r7, r24, r0
    339c:	10a30000 	addk	r5, r3, r0
    33a0:	b0000000 	imm	0
    33a4:	b9f42774 	brlid	r15, 10100	// 5b18 <memcpy>
    33a8:	10c6c800 	addk	r6, r6, r25
  /*  
  for (int i = 0; i < output.size; ++i) {
    LOG_DEBUG("Reading %016"PRIxPTR" => %08x", (uintptr_t)(membase + base_address  * sizeof(uint32_t) + i * sizeof(uint32_t)), output.words[i]);
  }
  */
  return output;
    33ac:	f2f30000 	sbi	r23, r19, 0
    33b0:	fad30004 	swi	r22, r19, 4
}
    33b4:	10730000 	addk	r3, r19, r0
    33b8:	e9e10000 	lwi	r15, r1, 0
    33bc:	ea61001c 	lwi	r19, r1, 28
    33c0:	eac10020 	lwi	r22, r1, 32
    33c4:	eae10024 	lwi	r23, r1, 36
    33c8:	eb010028 	lwi	r24, r1, 40
    33cc:	eb21002c 	lwi	r25, r1, 44
    33d0:	b60f0008 	rtsd	r15, 8
    33d4:	30210030 	addik	r1, r1, 48

000033d8 <handle_IPBUS_NIREAD>:

ipbus_payload_t handle_IPBUS_NIREAD(uint8_t nwords, uint32_t base_address) {
    33d8:	3021ffd8 	addik	r1, r1, -40
    33dc:	fa61001c 	swi	r19, r1, 28
    33e0:	12660000 	addk	r19, r6, r0
    33e4:	fac10020 	swi	r22, r1, 32
    33e8:	12c50000 	addk	r22, r5, r0
  LOG_DEBUG("==> IPBUS_NIREAD   nwords: %"PRIx8" @ addr: %"PRIx32, nwords, base_address);
  ipbus_payload_t output;
  output.size = nwords;
  output.words = malloc(nwords * sizeof(uint32_t));
    33ec:	60a60004 	muli	r5, r6, 4
  }
  */
  return output;
}

ipbus_payload_t handle_IPBUS_NIREAD(uint8_t nwords, uint32_t base_address) {
    33f0:	fae10024 	swi	r23, r1, 36
    33f4:	f9e10000 	swi	r15, r1, 0
  LOG_DEBUG("==> IPBUS_NIREAD   nwords: %"PRIx8" @ addr: %"PRIx32, nwords, base_address);
  ipbus_payload_t output;
  output.size = nwords;
  output.words = malloc(nwords * sizeof(uint32_t));
    33f8:	b0000000 	imm	0
    33fc:	b9f41b3c 	brlid	r15, 6972	// 4f38 <malloc>
    3400:	12e70000 	addk	r23, r7, r0
  // read the same place a bunch of times. think we need to fix this?
  for (int i = 0; i < nwords; ++i) {
    3404:	bc13002c 	beqi	r19, 44		// 3430
    3408:	b0000000 	imm	0
    340c:	e8e0eae8 	lwi	r7, r0, -5400	// eae8 <membase>
    3410:	10800000 	addk	r4, r0, r0
    3414:	10e7b800 	addk	r7, r7, r23
    output.words[i] = *((volatile uint32_t*) (membase + base_address));
    3418:	e9070000 	lwi	r8, r7, 0
    341c:	60c40004 	muli	r6, r4, 4
  LOG_DEBUG("==> IPBUS_NIREAD   nwords: %"PRIx8" @ addr: %"PRIx32, nwords, base_address);
  ipbus_payload_t output;
  output.size = nwords;
  output.words = malloc(nwords * sizeof(uint32_t));
  // read the same place a bunch of times. think we need to fix this?
  for (int i = 0; i < nwords; ++i) {
    3420:	30840001 	addik	r4, r4, 1
    output.words[i] = *((volatile uint32_t*) (membase + base_address));
    3424:	d9061800 	sw	r8, r6, r3
  LOG_DEBUG("==> IPBUS_NIREAD   nwords: %"PRIx8" @ addr: %"PRIx32, nwords, base_address);
  ipbus_payload_t output;
  output.size = nwords;
  output.words = malloc(nwords * sizeof(uint32_t));
  // read the same place a bunch of times. think we need to fix this?
  for (int i = 0; i < nwords; ++i) {
    3428:	14d32001 	cmp	r6, r19, r4
    342c:	bc46ffec 	blti	r6, -20		// 3418
    output.words[i] = *((volatile uint32_t*) (membase + base_address));
  }
  return output;
    3430:	f8760004 	swi	r3, r22, 4
    3434:	f2760000 	sbi	r19, r22, 0
}
    3438:	10760000 	addk	r3, r22, r0
    343c:	e9e10000 	lwi	r15, r1, 0
    3440:	ea61001c 	lwi	r19, r1, 28
    3444:	eac10020 	lwi	r22, r1, 32
    3448:	eae10024 	lwi	r23, r1, 36
    344c:	b60f0008 	rtsd	r15, 8
    3450:	30210028 	addik	r1, r1, 40

00003454 <handle_IPBUS_WRITE>:

// Write functions return no data - return value should indicate whether
// write was successful.  The write address is the first word of the data.
int handle_IPBUS_WRITE(uint8_t writesize, const ipbus_payload_t* data) {
    3454:	3021ffe4 	addik	r1, r1, -28
    3458:	f9e10000 	swi	r15, r1, 0
  LOG_DEBUG("==> IPBUS_WRITE    writesize: %"PRIx8" @ addr: %"PRIx32, writesize, data->words[0]);
  memcpy(membase + data->words[0], data->words + 1, writesize * sizeof(uint32_t));
    345c:	e8c60004 	lwi	r6, r6, 4
    3460:	60e50004 	muli	r7, r5, 4
    3464:	b0000000 	imm	0
    3468:	e8a0eae8 	lwi	r5, r0, -5400	// eae8 <membase>
    346c:	e8660000 	lwi	r3, r6, 0
    3470:	30c60004 	addik	r6, r6, 4
    3474:	b0000000 	imm	0
    3478:	b9f426a0 	brlid	r15, 9888	// 5b18 <memcpy>
    347c:	10a51800 	addk	r5, r5, r3
  for (int i = 1; i < data->size; ++i) {
    LOG_DEBUG("writing %016"PRIxPTR" <= %08x", (uintptr_t)(membase + data->words[0] * sizeof(uint32_t) + (i - 1)*sizeof(uint32_t)), data->words[i]);
  }
  */
  return 0;
}
    3480:	e9e10000 	lwi	r15, r1, 0
    3484:	10600000 	addk	r3, r0, r0
    3488:	b60f0008 	rtsd	r15, 8
    348c:	3021001c 	addik	r1, r1, 28

00003490 <handle_IPBUS_NIWRITE>:

int handle_IPBUS_NIWRITE(uint8_t writesize, const ipbus_payload_t* data) {
  LOG_DEBUG("==> IPBUS_NIWRITE  writesize: %"PRIx8" @ addr: %"PRIx32, writesize, data->words[0]);
  // write the same place a bunch of times. think we need to fix this?
  for (int i = 1; i < data->size; ++i) {
    3490:	e0860000 	lbui	r4, r6, 0
    3494:	30600001 	addik	r3, r0, 1
    3498:	14841801 	cmp	r4, r4, r3
    349c:	bea40034 	bgeid	r4, 52		// 34d0
    34a0:	60a30004 	muli	r5, r3, 4
    34a4:	b0000000 	imm	0
    34a8:	e8e0eae8 	lwi	r7, r0, -5400	// eae8 <membase>
    34ac:	e8860004 	lwi	r4, r6, 4
    *(uint32_t*)(membase + data->words[0]) = data->words[i];
    34b0:	c8a52000 	lw	r5, r5, r4
    34b4:	e9040000 	lwi	r8, r4, 0
}

int handle_IPBUS_NIWRITE(uint8_t writesize, const ipbus_payload_t* data) {
  LOG_DEBUG("==> IPBUS_NIWRITE  writesize: %"PRIx8" @ addr: %"PRIx32, writesize, data->words[0]);
  // write the same place a bunch of times. think we need to fix this?
  for (int i = 1; i < data->size; ++i) {
    34b8:	30630001 	addik	r3, r3, 1
    *(uint32_t*)(membase + data->words[0]) = data->words[i];
    34bc:	d8a83800 	sw	r5, r8, r7
}

int handle_IPBUS_NIWRITE(uint8_t writesize, const ipbus_payload_t* data) {
  LOG_DEBUG("==> IPBUS_NIWRITE  writesize: %"PRIx8" @ addr: %"PRIx32, writesize, data->words[0]);
  // write the same place a bunch of times. think we need to fix this?
  for (int i = 1; i < data->size; ++i) {
    34c0:	e0a60000 	lbui	r5, r6, 0
    34c4:	14a51801 	cmp	r5, r5, r3
    34c8:	be45ffe8 	bltid	r5, -24		// 34b0
    34cc:	60a30004 	muli	r5, r3, 4
    *(uint32_t*)(membase + data->words[0]) = data->words[i];
  }
  return 0;
}
    34d0:	b60f0008 	rtsd	r15, 8
    34d4:	10600000 	addk	r3, r0, r0

000034d8 <handle_IPBUS_RMW>:

// Read write modifies returns original contents at address
uint32_t handle_IPBUS_RMW(uint32_t base_address, uint32_t andterm, uint32_t orterm) {
  LOG_DEBUG("==> IPBUS_RMW      @ addr: %"PRIx32" - AND: %"PRIx32" OR: %"PRIx32, 
      base_address, andterm, orterm);
  uint32_t current = *(uint32_t*)(membase + base_address);
    34d8:	b0000000 	imm	0
    34dc:	e880eae8 	lwi	r4, r0, -5400	// eae8 <membase>
    34e0:	c8652000 	lw	r3, r5, r4
  *(uint32_t*)(membase + base_address) = (current & andterm) | orterm;
    34e4:	84c33000 	and	r6, r3, r6
    34e8:	80e63800 	or	r7, r6, r7
  return current;
}
    34ec:	b60f0008 	rtsd	r15, 8
    34f0:	d8e52000 	sw	r7, r5, r4

000034f4 <handle_IPBUS_RMWSUM>:

uint32_t handle_IPBUS_RMWSUM(uint32_t base_address, uint32_t addend) {
  LOG_DEBUG("==> IPBUS_RMWSUM   @ addr: %"PRIx32" - +: %"PRIx32, 
      base_address, addend);
  uint32_t current = *(uint32_t*)(membase + base_address);
    34f4:	b0000000 	imm	0
    34f8:	e880eae8 	lwi	r4, r0, -5400	// eae8 <membase>
    34fc:	c8652000 	lw	r3, r5, r4
  *(uint32_t*)(membase + base_address) = current + addend;
    3500:	10c33000 	addk	r6, r3, r6
  return current;
}
    3504:	b60f0008 	rtsd	r15, 8
    3508:	d8c52000 	sw	r6, r5, r4

0000350c <membase_init>:

unsigned char* membase=0;

int membase_init(void) { 
  return 1;
}
    350c:	b60f0008 	rtsd	r15, 8
    3510:	30600001 	addik	r3, r0, 1

00003514 <membase_close>:

int membase_close(void) {
  return 1;
}
    3514:	b60f0008 	rtsd	r15, 8
    3518:	30600001 	addik	r3, r0, 1

0000351c <write>:
    351c:	3021ffd8 	addik	r1, r1, -40
    3520:	fac10020 	swi	r22, r1, 32
    3524:	fae10024 	swi	r23, r1, 36
    3528:	f9e10000 	swi	r15, r1, 0
    352c:	fa61001c 	swi	r19, r1, 28
    3530:	12e70000 	addk	r23, r7, r0
    3534:	be670060 	bleid	r7, 96		// 3594
    3538:	12c60000 	addk	r22, r6, r0
    353c:	b8100020 	brid	32		// 355c
    3540:	12600000 	addk	r19, r0, r0
    3544:	b0000000 	imm	0
    3548:	b9f40864 	brlid	r15, 2148	// 3dac <outbyte>
    354c:	32730001 	addik	r19, r19, 1
    3550:	14979801 	cmp	r4, r23, r19
    3554:	bea40044 	bgeid	r4, 68		// 3598
    3558:	10770000 	addk	r3, r23, r0
    355c:	c0b3b000 	lbu	r5, r19, r22
    3560:	90a50060 	sext8	r5, r5
    3564:	a885000a 	xori	r4, r5, 10
    3568:	bc24ffdc 	bnei	r4, -36		// 3544
    356c:	b0000000 	imm	0
    3570:	b9f4083c 	brlid	r15, 2108	// 3dac <outbyte>
    3574:	30a0000d 	addik	r5, r0, 13
    3578:	c0b3b000 	lbu	r5, r19, r22
    357c:	32730001 	addik	r19, r19, 1
    3580:	b0000000 	imm	0
    3584:	b9f40828 	brlid	r15, 2088	// 3dac <outbyte>
    3588:	90a50060 	sext8	r5, r5
    358c:	14979801 	cmp	r4, r23, r19
    3590:	bc44ffcc 	blti	r4, -52		// 355c
    3594:	10770000 	addk	r3, r23, r0
    3598:	e9e10000 	lwi	r15, r1, 0
    359c:	ea61001c 	lwi	r19, r1, 28
    35a0:	eac10020 	lwi	r22, r1, 32
    35a4:	eae10024 	lwi	r23, r1, 36
    35a8:	b60f0008 	rtsd	r15, 8
    35ac:	30210028 	addik	r1, r1, 40

000035b0 <read>:
    35b0:	3021ffd8 	addik	r1, r1, -40
    35b4:	fac10020 	swi	r22, r1, 32
    35b8:	fae10024 	swi	r23, r1, 36
    35bc:	f9e10000 	swi	r15, r1, 0
    35c0:	fa61001c 	swi	r19, r1, 28
    35c4:	12c70000 	addk	r22, r7, r0
    35c8:	12e60000 	addk	r23, r6, r0
    35cc:	be670058 	bleid	r7, 88		// 3624
    35d0:	30600001 	addik	r3, r0, 1
    35d4:	b8100020 	brid	32		// 35f4
    35d8:	12600000 	addk	r19, r0, r0
    35dc:	be440048 	bltid	r4, 72		// 3624
    35e0:	30730001 	addik	r3, r19, 1
    35e4:	32730001 	addik	r19, r19, 1
    35e8:	14769801 	cmp	r3, r22, r19
    35ec:	bea30038 	bgeid	r3, 56		// 3624
    35f0:	30730001 	addik	r3, r19, 1
    35f4:	b0000000 	imm	0
    35f8:	b9f40758 	brlid	r15, 1880	// 3d50 <inbyte>
    35fc:	80000000 	or	r0, r0, r0
    3600:	a8a3000d 	xori	r5, r3, 13
    3604:	a883000a 	xori	r4, r3, 10
    3608:	a4a500ff 	andi	r5, r5, 255
    360c:	a48400ff 	andi	r4, r4, 255
    3610:	d073b800 	sb	r3, r19, r23
    3614:	3065ffff 	addik	r3, r5, -1
    3618:	bea3ffc4 	bgeid	r3, -60		// 35dc
    361c:	3084ffff 	addik	r4, r4, -1
    3620:	30730001 	addik	r3, r19, 1
    3624:	e9e10000 	lwi	r15, r1, 0
    3628:	ea61001c 	lwi	r19, r1, 28
    362c:	eac10020 	lwi	r22, r1, 32
    3630:	eae10024 	lwi	r23, r1, 36
    3634:	b60f0008 	rtsd	r15, 8
    3638:	30210028 	addik	r1, r1, 40

0000363c <time>:
    363c:	b60f0008 	rtsd	r15, 8
    3640:	10600000 	addk	r3, r0, r0

00003644 <padding>:
    3644:	3021ffdc 	addik	r1, r1, -36
    3648:	14650000 	rsubk	r3, r5, r0
    364c:	fa61001c 	swi	r19, r1, 28
    3650:	f9e10000 	swi	r15, r1, 0
    3654:	fac10020 	swi	r22, r1, 32
    3658:	80a32800 	or	r5, r3, r5
    365c:	bea5004c 	bgeid	r5, 76		// 36a8
    3660:	12660000 	addk	r19, r6, r0
    3664:	e8660010 	lwi	r3, r6, 16
    3668:	14830000 	rsubk	r4, r3, r0
    366c:	80641800 	or	r3, r4, r3
    3670:	bea3003c 	bgeid	r3, 60		// 36ac
    3674:	e9e10000 	lwi	r15, r1, 0
    3678:	eac60000 	lwi	r22, r6, 0
    367c:	e8660004 	lwi	r3, r6, 4
    3680:	1463b001 	cmp	r3, r3, r22
    3684:	bca30028 	bgei	r3, 40		// 36ac
    3688:	e0b3000c 	lbui	r5, r19, 12
    368c:	32d60001 	addik	r22, r22, 1
    3690:	b0000000 	imm	0
    3694:	b9f40718 	brlid	r15, 1816	// 3dac <outbyte>
    3698:	90a50060 	sext8	r5, r5
    369c:	e8730004 	lwi	r3, r19, 4
    36a0:	1463b001 	cmp	r3, r3, r22
    36a4:	bc43ffe4 	blti	r3, -28		// 3688
    36a8:	e9e10000 	lwi	r15, r1, 0
    36ac:	ea61001c 	lwi	r19, r1, 28
    36b0:	eac10020 	lwi	r22, r1, 32
    36b4:	b60f0008 	rtsd	r15, 8
    36b8:	30210024 	addik	r1, r1, 36

000036bc <outnum>:
    36bc:	3021ff90 	addik	r1, r1, -112
    36c0:	a866000a 	xori	r3, r6, 10
    36c4:	fae1005c 	swi	r23, r1, 92
    36c8:	12e60000 	addk	r23, r6, r0
    36cc:	b0000000 	imm	0
    36d0:	e8c0d784 	lwi	r6, r0, -10364
    36d4:	14830000 	rsubk	r4, r3, r0
    36d8:	fb410068 	swi	r26, r1, 104
    36dc:	f8c1001c 	swi	r6, r1, 28
    36e0:	b0000000 	imm	0
    36e4:	e8c0d788 	lwi	r6, r0, -10360
    36e8:	f9e10000 	swi	r15, r1, 0
    36ec:	fa610054 	swi	r19, r1, 84
    36f0:	f8c10020 	swi	r6, r1, 32
    36f4:	b0000000 	imm	0
    36f8:	e8c0d78c 	lwi	r6, r0, -10356
    36fc:	fac10058 	swi	r22, r1, 88
    3700:	fb010060 	swi	r24, r1, 96
    3704:	f8c10024 	swi	r6, r1, 36
    3708:	b0000000 	imm	0
    370c:	e8c0d790 	lwi	r6, r0, -10352
    3710:	fb210064 	swi	r25, r1, 100
    3714:	fb61006c 	swi	r27, r1, 108
    3718:	f8c10028 	swi	r6, r1, 40
    371c:	b0000000 	imm	0
    3720:	e0c0d794 	lbui	r6, r0, -10348
    3724:	80641800 	or	r3, r4, r3
    3728:	13470000 	addk	r26, r7, r0
    372c:	be43000c 	bltid	r3, 12		// 3738
    3730:	f0c1002c 	sbi	r6, r1, 44
    3734:	bc450174 	blti	r5, 372		// 38a8
    3738:	12650000 	addk	r19, r5, r0
    373c:	13600000 	addk	r27, r0, r0
    3740:	33210030 	addik	r25, r1, 48
    3744:	b810000c 	brid	12		// 3750
    3748:	12d90000 	addk	r22, r25, r0
    374c:	12d80000 	addk	r22, r24, r0
    3750:	10b30000 	addk	r5, r19, r0
    3754:	10d70000 	addk	r6, r23, r0
    3758:	b0000000 	imm	0
    375c:	b9f49a20 	brlid	r15, -26080	// d17c <__umodsi3>
    3760:	33160001 	addik	r24, r22, 1
    3764:	10611800 	addk	r3, r1, r3
    3768:	e063001c 	lbui	r3, r3, 28
    376c:	10b30000 	addk	r5, r19, r0
    3770:	10d70000 	addk	r6, r23, r0
    3774:	b0000000 	imm	0
    3778:	b9f4995c 	brlid	r15, -26276	// d0d4 <__udivsi3>
    377c:	f0760000 	sbi	r3, r22, 0
    3780:	be23ffcc 	bneid	r3, -52		// 374c
    3784:	12630000 	addk	r19, r3, r0
    3788:	be1b0014 	beqid	r27, 20		// 379c
    378c:	10b90000 	addk	r5, r25, r0
    3790:	3060002d 	addik	r3, r0, 45
    3794:	f0760001 	sbi	r3, r22, 1
    3798:	33160002 	addik	r24, r22, 2
    379c:	f0180000 	sbi	r0, r24, 0
    37a0:	b0000000 	imm	0
    37a4:	b9f450e4 	brlid	r15, 20708	// 8888 <strlen>
    37a8:	3278ffff 	addik	r19, r24, -1
    37ac:	e89a0014 	lwi	r4, r26, 20
    37b0:	f87a0000 	swi	r3, r26, 0
    37b4:	10da0000 	addk	r6, r26, r0
    37b8:	14a40000 	rsubk	r5, r4, r0
    37bc:	80a52000 	or	r5, r5, r4
    37c0:	a8a5ffff 	xori	r5, r5, -1
    37c4:	10602800 	addk	r3, r0, r5
    37c8:	90650041 	srl	r3, r5
    37cc:	90630041 	srl	r3, r3
    37d0:	90630041 	srl	r3, r3
    37d4:	90630041 	srl	r3, r3
    37d8:	90630041 	srl	r3, r3
    37dc:	90630041 	srl	r3, r3
    37e0:	90630041 	srl	r3, r3
    37e4:	90630041 	srl	r3, r3
    37e8:	90630041 	srl	r3, r3
    37ec:	90630041 	srl	r3, r3
    37f0:	90630041 	srl	r3, r3
    37f4:	90630041 	srl	r3, r3
    37f8:	90630041 	srl	r3, r3
    37fc:	90630041 	srl	r3, r3
    3800:	90630041 	srl	r3, r3
    3804:	90630041 	srl	r3, r3
    3808:	90630041 	srl	r3, r3
    380c:	90630041 	srl	r3, r3
    3810:	90630041 	srl	r3, r3
    3814:	90630041 	srl	r3, r3
    3818:	90630041 	srl	r3, r3
    381c:	90630041 	srl	r3, r3
    3820:	90630041 	srl	r3, r3
    3824:	90630041 	srl	r3, r3
    3828:	90630041 	srl	r3, r3
    382c:	90630041 	srl	r3, r3
    3830:	90630041 	srl	r3, r3
    3834:	90630041 	srl	r3, r3
    3838:	90630041 	srl	r3, r3
    383c:	90630041 	srl	r3, r3
    3840:	90630041 	srl	r3, r3
    3844:	10a30000 	addk	r5, r3, r0
    3848:	b9f4fdfc 	brlid	r15, -516	// 3644 <padding>
    384c:	f8610050 	swi	r3, r1, 80
    3850:	14799803 	cmpu	r3, r25, r19
    3854:	bc430020 	blti	r3, 32		// 3874
    3858:	e0b30000 	lbui	r5, r19, 0
    385c:	3273ffff 	addik	r19, r19, -1
    3860:	b0000000 	imm	0
    3864:	b9f40548 	brlid	r15, 1352	// 3dac <outbyte>
    3868:	90a50060 	sext8	r5, r5
    386c:	14799803 	cmpu	r3, r25, r19
    3870:	bca3ffe8 	bgei	r3, -24		// 3858
    3874:	e8ba0014 	lwi	r5, r26, 20
    3878:	b9f4fdcc 	brlid	r15, -564	// 3644 <padding>
    387c:	10da0000 	addk	r6, r26, r0
    3880:	e9e10000 	lwi	r15, r1, 0
    3884:	ea610054 	lwi	r19, r1, 84
    3888:	eac10058 	lwi	r22, r1, 88
    388c:	eae1005c 	lwi	r23, r1, 92
    3890:	eb010060 	lwi	r24, r1, 96
    3894:	eb210064 	lwi	r25, r1, 100
    3898:	eb410068 	lwi	r26, r1, 104
    389c:	eb61006c 	lwi	r27, r1, 108
    38a0:	b60f0008 	rtsd	r15, 8
    38a4:	30210070 	addik	r1, r1, 112
    38a8:	16650000 	rsubk	r19, r5, r0
    38ac:	b810fe94 	brid	-364		// 3740
    38b0:	33600001 	addik	r27, r0, 1

000038b4 <xil_printf>:
    38b4:	f8a10004 	swi	r5, r1, 4
    38b8:	f8c10008 	swi	r6, r1, 8
    38bc:	f8e1000c 	swi	r7, r1, 12
    38c0:	f9010010 	swi	r8, r1, 16
    38c4:	f9210014 	swi	r9, r1, 20
    38c8:	f9410018 	swi	r10, r1, 24
    38cc:	3021ffac 	addik	r1, r1, -84
    38d0:	fac1003c 	swi	r22, r1, 60
    38d4:	fb010044 	swi	r24, r1, 68
    38d8:	f9e10000 	swi	r15, r1, 0
    38dc:	fa610038 	swi	r19, r1, 56
    38e0:	fae10040 	swi	r23, r1, 64
    38e4:	fb210048 	swi	r25, r1, 72
    38e8:	fb41004c 	swi	r26, r1, 76
    38ec:	fb610050 	swi	r27, r1, 80
    38f0:	12c50000 	addk	r22, r5, r0
    38f4:	e0a50000 	lbui	r5, r5, 0
    38f8:	90a50060 	sext8	r5, r5
    38fc:	be050120 	beqid	r5, 288		// 3a1c
    3900:	3301005c 	addik	r24, r1, 92
    3904:	33400053 	addik	r26, r0, 83
    3908:	b8100024 	brid	36		// 392c
    390c:	33600068 	addik	r27, r0, 104
    3910:	b0000000 	imm	0
    3914:	b9f40498 	brlid	r15, 1176	// 3dac <outbyte>
    3918:	12760000 	addk	r19, r22, r0
    391c:	e0b30001 	lbui	r5, r19, 1
    3920:	90a50060 	sext8	r5, r5
    3924:	be0500f8 	beqid	r5, 248		// 3a1c
    3928:	32d30001 	addik	r22, r19, 1
    392c:	a8650025 	xori	r3, r5, 37
    3930:	be23ffe0 	bneid	r3, -32		// 3910
    3934:	12e30000 	addk	r23, r3, r0
    3938:	e0b60001 	lbui	r5, r22, 1
    393c:	b0000000 	imm	0
    3940:	e880e50c 	lwi	r4, r0, -6900	// e50c <__ctype_ptr__>
    3944:	f861002c 	swi	r3, r1, 44
    3948:	f8610030 	swi	r3, r1, 48
    394c:	30600020 	addik	r3, r0, 32	// 20 <_vector_hw_exception>
    3950:	90a50060 	sext8	r5, r5
    3954:	f0610028 	sbi	r3, r1, 40
    3958:	30607fff 	addik	r3, r0, 32767
    395c:	f8610024 	swi	r3, r1, 36
    3960:	10642800 	addk	r3, r4, r5
    3964:	e0630001 	lbui	r3, r3, 1
    3968:	a4c30004 	andi	r6, r3, 4
    396c:	be06005c 	beqid	r6, 92		// 39c8
    3970:	32760001 	addik	r19, r22, 1
    3974:	be1702b0 	beqid	r23, 688		// 3c24
    3978:	a8650030 	xori	r3, r5, 48
    397c:	10c00000 	addk	r6, r0, r0
    3980:	e0730001 	lbui	r3, r19, 1
    3984:	3105ffd0 	addik	r8, r5, -48
    3988:	61260004 	muli	r9, r6, 4
    398c:	90a30060 	sext8	r5, r3
    3990:	10642800 	addk	r3, r4, r5
    3994:	e0e30001 	lbui	r7, r3, 1
    3998:	10c93000 	addk	r6, r9, r6
    399c:	10c63000 	addk	r6, r6, r6
    39a0:	a4e70004 	andi	r7, r7, 4
    39a4:	10c64000 	addk	r6, r6, r8
    39a8:	be27ffd8 	bneid	r7, -40		// 3980
    39ac:	32730001 	addik	r19, r19, 1
    39b0:	f8c10024 	swi	r6, r1, 36
    39b4:	32d3ffff 	addik	r22, r19, -1
    39b8:	e0630001 	lbui	r3, r3, 1
    39bc:	a4c30004 	andi	r6, r3, 4
    39c0:	be26ffb4 	bneid	r6, -76		// 3974
    39c4:	32760001 	addik	r19, r22, 1
    39c8:	a4630003 	andi	r3, r3, 3
    39cc:	a8c30001 	xori	r6, r3, 1
    39d0:	be0602c4 	beqid	r6, 708		// 3c94
    39d4:	10650000 	addk	r3, r5, r0
    39d8:	3063ffdb 	addik	r3, r3, -37
    39dc:	14c3d003 	cmpu	r6, r3, r26
    39e0:	be46ff3c 	bltid	r6, -196		// 391c
    39e4:	60630004 	muli	r3, r3, 4
    39e8:	b0000000 	imm	0
    39ec:	3063d798 	addik	r3, r3, -10344
    39f0:	e8630000 	lwi	r3, r3, 0
    39f4:	98081800 	bra	r3
    39f8:	e8b80000 	lwi	r5, r24, 0
    39fc:	30c00010 	addik	r6, r0, 16	// 10 <_vector_interrupt>
    3a00:	30e1001c 	addik	r7, r1, 28
    3a04:	b9f4fcb8 	brlid	r15, -840	// 36bc <outnum>
    3a08:	33180004 	addik	r24, r24, 4
    3a0c:	e0b30001 	lbui	r5, r19, 1
    3a10:	90a50060 	sext8	r5, r5
    3a14:	be25ff18 	bneid	r5, -232		// 392c
    3a18:	32d30001 	addik	r22, r19, 1
    3a1c:	e9e10000 	lwi	r15, r1, 0
    3a20:	ea610038 	lwi	r19, r1, 56
    3a24:	eac1003c 	lwi	r22, r1, 60
    3a28:	eae10040 	lwi	r23, r1, 64
    3a2c:	eb010044 	lwi	r24, r1, 68
    3a30:	eb210048 	lwi	r25, r1, 72
    3a34:	eb41004c 	lwi	r26, r1, 76
    3a38:	eb610050 	lwi	r27, r1, 80
    3a3c:	b60f0008 	rtsd	r15, 8
    3a40:	30210054 	addik	r1, r1, 84
    3a44:	ead80000 	lwi	r22, r24, 0
    3a48:	33180004 	addik	r24, r24, 4
    3a4c:	b0000000 	imm	0
    3a50:	b9f44e38 	brlid	r15, 20024	// 8888 <strlen>
    3a54:	10b60000 	addk	r5, r22, r0
    3a58:	e8810030 	lwi	r4, r1, 48
    3a5c:	f861001c 	swi	r3, r1, 28
    3a60:	30c1001c 	addik	r6, r1, 28
    3a64:	14a40000 	rsubk	r5, r4, r0
    3a68:	80a52000 	or	r5, r5, r4
    3a6c:	a8a5ffff 	xori	r5, r5, -1
    3a70:	10602800 	addk	r3, r0, r5
    3a74:	90650041 	srl	r3, r5
    3a78:	90630041 	srl	r3, r3
    3a7c:	90630041 	srl	r3, r3
    3a80:	90630041 	srl	r3, r3
    3a84:	90630041 	srl	r3, r3
    3a88:	90630041 	srl	r3, r3
    3a8c:	90630041 	srl	r3, r3
    3a90:	90630041 	srl	r3, r3
    3a94:	90630041 	srl	r3, r3
    3a98:	90630041 	srl	r3, r3
    3a9c:	90630041 	srl	r3, r3
    3aa0:	90630041 	srl	r3, r3
    3aa4:	90630041 	srl	r3, r3
    3aa8:	90630041 	srl	r3, r3
    3aac:	90630041 	srl	r3, r3
    3ab0:	90630041 	srl	r3, r3
    3ab4:	90630041 	srl	r3, r3
    3ab8:	90630041 	srl	r3, r3
    3abc:	90630041 	srl	r3, r3
    3ac0:	90630041 	srl	r3, r3
    3ac4:	90630041 	srl	r3, r3
    3ac8:	90630041 	srl	r3, r3
    3acc:	90630041 	srl	r3, r3
    3ad0:	90630041 	srl	r3, r3
    3ad4:	90630041 	srl	r3, r3
    3ad8:	90630041 	srl	r3, r3
    3adc:	90630041 	srl	r3, r3
    3ae0:	90630041 	srl	r3, r3
    3ae4:	90630041 	srl	r3, r3
    3ae8:	90630041 	srl	r3, r3
    3aec:	90630041 	srl	r3, r3
    3af0:	10a30000 	addk	r5, r3, r0
    3af4:	b9f4fb50 	brlid	r15, -1200	// 3644 <padding>
    3af8:	f8610034 	swi	r3, r1, 52
    3afc:	e0760000 	lbui	r3, r22, 0
    3b00:	be03004c 	beqid	r3, 76		// 3b4c
    3b04:	e8610024 	lwi	r3, r1, 36
    3b08:	3083ffff 	addik	r4, r3, -1
    3b0c:	be230020 	bneid	r3, 32		// 3b2c
    3b10:	f8810024 	swi	r4, r1, 36
    3b14:	b810003c 	brid	60		// 3b50
    3b18:	e8a10030 	lwi	r5, r1, 48
    3b1c:	3083ffff 	addik	r4, r3, -1
    3b20:	be03002c 	beqid	r3, 44		// 3b4c
    3b24:	f8810024 	swi	r4, r1, 36
    3b28:	12d70000 	addk	r22, r23, r0
    3b2c:	e0b60000 	lbui	r5, r22, 0
    3b30:	32f60001 	addik	r23, r22, 1
    3b34:	b0000000 	imm	0
    3b38:	b9f40274 	brlid	r15, 628	// 3dac <outbyte>
    3b3c:	90a50060 	sext8	r5, r5
    3b40:	e0760001 	lbui	r3, r22, 1
    3b44:	be23ffd8 	bneid	r3, -40		// 3b1c
    3b48:	e8610024 	lwi	r3, r1, 36
    3b4c:	e8a10030 	lwi	r5, r1, 48
    3b50:	b9f4faf4 	brlid	r15, -1292	// 3644 <padding>
    3b54:	30c1001c 	addik	r6, r1, 28
    3b58:	b810fdc8 	brid	-568		// 3920
    3b5c:	e0b30001 	lbui	r5, r19, 1
    3b60:	e0b60002 	lbui	r5, r22, 2
    3b64:	12d30000 	addk	r22, r19, r0
    3b68:	90a50060 	sext8	r5, r5
    3b6c:	b810fdf8 	brid	-520		// 3964
    3b70:	10642800 	addk	r3, r4, r5
    3b74:	e8b80000 	lwi	r5, r24, 0
    3b78:	30c0000a 	addik	r6, r0, 10
    3b7c:	30e1001c 	addik	r7, r1, 28
    3b80:	b9f4fb3c 	brlid	r15, -1220	// 36bc <outnum>
    3b84:	33180004 	addik	r24, r24, 4
    3b88:	b810fe88 	brid	-376		// 3a10
    3b8c:	e0b30001 	lbui	r5, r19, 1
    3b90:	e8b80000 	lwi	r5, r24, 0
    3b94:	33180004 	addik	r24, r24, 4
    3b98:	b0000000 	imm	0
    3b9c:	b9f40210 	brlid	r15, 528	// 3dac <outbyte>
    3ba0:	90a50060 	sext8	r5, r5
    3ba4:	b810fd7c 	brid	-644		// 3920
    3ba8:	e0b30001 	lbui	r5, r19, 1
    3bac:	a8650068 	xori	r3, r5, 104
    3bb0:	bc230124 	bnei	r3, 292		// 3cd4
    3bb4:	b0000000 	imm	0
    3bb8:	b9f401f4 	brlid	r15, 500	// 3dac <outbyte>
    3bbc:	30a00008 	addik	r5, r0, 8	// 8 <_vector_sw_exception>
    3bc0:	e0b60003 	lbui	r5, r22, 3
    3bc4:	b0000000 	imm	0
    3bc8:	e880e50c 	lwi	r4, r0, -6900	// e50c <__ctype_ptr__>
    3bcc:	32d60002 	addik	r22, r22, 2
    3bd0:	90a50060 	sext8	r5, r5
    3bd4:	b810fd90 	brid	-624		// 3964
    3bd8:	10642800 	addk	r3, r4, r5
    3bdc:	e0b60002 	lbui	r5, r22, 2
    3be0:	32e00001 	addik	r23, r0, 1
    3be4:	12d30000 	addk	r22, r19, r0
    3be8:	90a50060 	sext8	r5, r5
    3bec:	b810fd78 	brid	-648		// 3964
    3bf0:	10642800 	addk	r3, r4, r5
    3bf4:	e0b60002 	lbui	r5, r22, 2
    3bf8:	30600001 	addik	r3, r0, 1
    3bfc:	f8610030 	swi	r3, r1, 48
    3c00:	90a50060 	sext8	r5, r5
    3c04:	12d30000 	addk	r22, r19, r0
    3c08:	b810fd5c 	brid	-676		// 3964
    3c0c:	10642800 	addk	r3, r4, r5
    3c10:	b0000000 	imm	0
    3c14:	b9f40198 	brlid	r15, 408	// 3dac <outbyte>
    3c18:	30a00025 	addik	r5, r0, 37
    3c1c:	b810fd04 	brid	-764		// 3920
    3c20:	e0b30001 	lbui	r5, r19, 1
    3c24:	be030078 	beqid	r3, 120		// 3c9c
    3c28:	30600030 	addik	r3, r0, 48
    3c2c:	e0760001 	lbui	r3, r22, 1
    3c30:	90630060 	sext8	r3, r3
    3c34:	10c41800 	addk	r6, r4, r3
    3c38:	e0c60001 	lbui	r6, r6, 1
    3c3c:	a4c60004 	andi	r6, r6, 4
    3c40:	bc060078 	beqi	r6, 120		// 3cb8
    3c44:	10c00000 	addk	r6, r0, r0
    3c48:	e0b30001 	lbui	r5, r19, 1
    3c4c:	30e3ffd0 	addik	r7, r3, -48
    3c50:	61060004 	muli	r8, r6, 4
    3c54:	90650060 	sext8	r3, r5
    3c58:	10a41800 	addk	r5, r4, r3
    3c5c:	e0a50001 	lbui	r5, r5, 1
    3c60:	10c83000 	addk	r6, r8, r6
    3c64:	10c63000 	addk	r6, r6, r6
    3c68:	a4a50004 	andi	r5, r5, 4
    3c6c:	10c63800 	addk	r6, r6, r7
    3c70:	be25ffd8 	bneid	r5, -40		// 3c48
    3c74:	32730001 	addik	r19, r19, 1
    3c78:	10a30000 	addk	r5, r3, r0
    3c7c:	30600001 	addik	r3, r0, 1
    3c80:	f861002c 	swi	r3, r1, 44
    3c84:	f8c10020 	swi	r6, r1, 32
    3c88:	10642800 	addk	r3, r4, r5
    3c8c:	b810fd2c 	brid	-724		// 39b8
    3c90:	32d3ffff 	addik	r22, r19, -1
    3c94:	b810fd44 	brid	-700		// 39d8
    3c98:	30650020 	addik	r3, r5, 32
    3c9c:	f0610028 	sbi	r3, r1, 40
    3ca0:	e0760001 	lbui	r3, r22, 1
    3ca4:	90630060 	sext8	r3, r3
    3ca8:	10c41800 	addk	r6, r4, r3
    3cac:	e0c60001 	lbui	r6, r6, 1
    3cb0:	a4c60004 	andi	r6, r6, 4
    3cb4:	bc26ff90 	bnei	r6, -112		// 3c44
    3cb8:	10650000 	addk	r3, r5, r0
    3cbc:	f8c10020 	swi	r6, r1, 32
    3cc0:	10a30000 	addk	r5, r3, r0
    3cc4:	30600001 	addik	r3, r0, 1
    3cc8:	f861002c 	swi	r3, r1, 44
    3ccc:	b810ffc0 	brid	-64		// 3c8c
    3cd0:	10642800 	addk	r3, r4, r5
    3cd4:	1465d801 	cmp	r3, r5, r27
    3cd8:	be430020 	bltid	r3, 32		// 3cf8
    3cdc:	a8650061 	xori	r3, r5, 97
    3ce0:	bc230028 	bnei	r3, 40		// 3d08
    3ce4:	b0000000 	imm	0
    3ce8:	b9f400c4 	brlid	r15, 196	// 3dac <outbyte>
    3cec:	30a00007 	addik	r5, r0, 7
    3cf0:	b810fed4 	brid	-300		// 3bc4
    3cf4:	e0b60003 	lbui	r5, r22, 3
    3cf8:	a865006e 	xori	r3, r5, 110
    3cfc:	bc030034 	beqi	r3, 52		// 3d30
    3d00:	a8650072 	xori	r3, r5, 114
    3d04:	bc030018 	beqi	r3, 24		// 3d1c
    3d08:	b0000000 	imm	0
    3d0c:	b9f400a0 	brlid	r15, 160	// 3dac <outbyte>
    3d10:	80000000 	or	r0, r0, r0
    3d14:	b810feb0 	brid	-336		// 3bc4
    3d18:	e0b60003 	lbui	r5, r22, 3
    3d1c:	b0000000 	imm	0
    3d20:	b9f4008c 	brlid	r15, 140	// 3dac <outbyte>
    3d24:	30a0000d 	addik	r5, r0, 13
    3d28:	b810fe9c 	brid	-356		// 3bc4
    3d2c:	e0b60003 	lbui	r5, r22, 3
    3d30:	b0000000 	imm	0
    3d34:	b9f40078 	brlid	r15, 120	// 3dac <outbyte>
    3d38:	30a0000d 	addik	r5, r0, 13
    3d3c:	b0000000 	imm	0
    3d40:	b9f4006c 	brlid	r15, 108	// 3dac <outbyte>
    3d44:	30a0000a 	addik	r5, r0, 10
    3d48:	b810fe7c 	brid	-388		// 3bc4
    3d4c:	e0b60003 	lbui	r5, r22, 3

00003d50 <inbyte>:
#ifdef __cplusplus
}
#endif 

char inbyte(void) {
	 return XUartLite_RecvByte(STDIN_BASEADDRESS);
    3d50:	b0005000 	imm	20480
    3d54:	30a00000 	addik	r5, r0, 0
char inbyte(void);
#ifdef __cplusplus
}
#endif 

char inbyte(void) {
    3d58:	3021ffe4 	addik	r1, r1, -28
    3d5c:	f9e10000 	swi	r15, r1, 0
	 return XUartLite_RecvByte(STDIN_BASEADDRESS);
    3d60:	b0000000 	imm	0
    3d64:	b9f40560 	brlid	r15, 1376	// 42c4 <XUartLite_RecvByte>
    3d68:	80000000 	or	r0, r0, r0
}
    3d6c:	e9e10000 	lwi	r15, r1, 0
    3d70:	90630060 	sext8	r3, r3
    3d74:	b60f0008 	rtsd	r15, 8
    3d78:	3021001c 	addik	r1, r1, 28

00003d7c <microblaze_enable_dcache>:
	.globl	microblaze_enable_dcache
	.ent	microblaze_enable_dcache
	.align	2
microblaze_enable_dcache:	
	#Make space on stack for a temporary
	addi	r1, r1, -4
    3d7c:	2021fffc 	addi	r1, r1, -4
	#Read the MSR register
	mfs	r8, rmsr
    3d80:	95008001 	mfs	r8, rmsr
	#Set the interrupt enable bit
	ori	r8, r8, 128
    3d84:	a1080080 	ori	r8, r8, 128
	#Save the MSR register
	mts	rmsr, r8
    3d88:	9408c001 	mts	rmsr, r8
	#Return
	rtsd	r15, 8
    3d8c:	b60f0008 	rtsd	r15, 8
	#Update stack in the delay slot
	addi	r1, r1, 4
    3d90:	20210004 	addi	r1, r1, 4

00003d94 <microblaze_enable_icache>:
	.globl	microblaze_enable_icache
	.ent	microblaze_enable_icache
	.align	2
microblaze_enable_icache:	
	#Make space on stack for a temporary
	addi	r1, r1, -4
    3d94:	2021fffc 	addi	r1, r1, -4
	#Read the MSR register
	mfs	r8, rmsr
    3d98:	95008001 	mfs	r8, rmsr
	#Set the interrupt enable bit
	ori	r8, r8, 32
    3d9c:	a1080020 	ori	r8, r8, 32
	#Save the MSR register
	mts	rmsr, r8
    3da0:	9408c001 	mts	rmsr, r8
	#Return
	rtsd	r15, 8
    3da4:	b60f0008 	rtsd	r15, 8
	#Update stack in the delay slot
	addi	r1, r1, 4
    3da8:	20210004 	addi	r1, r1, 4

00003dac <outbyte>:
#ifdef __cplusplus
}
#endif 

void outbyte(char c) {
	 XUartLite_SendByte(STDOUT_BASEADDRESS, c);
    3dac:	a4c500ff 	andi	r6, r5, 255
    3db0:	b0005000 	imm	20480
    3db4:	30a00000 	addik	r5, r0, 0

#ifdef __cplusplus
}
#endif 

void outbyte(char c) {
    3db8:	3021ffe4 	addik	r1, r1, -28
    3dbc:	f9e10000 	swi	r15, r1, 0
	 XUartLite_SendByte(STDOUT_BASEADDRESS, c);
    3dc0:	b0000000 	imm	0
    3dc4:	b9f404e4 	brlid	r15, 1252	// 42a8 <XUartLite_SendByte>
    3dc8:	80000000 	or	r0, r0, r0
}
    3dcc:	e9e10000 	lwi	r15, r1, 0
    3dd0:	b60f0008 	rtsd	r15, 8
    3dd4:	3021001c 	addik	r1, r1, 28

00003dd8 <Xil_DCacheDisable>:
*
* @return   None.
*
****************************************************************************/
void Xil_DCacheDisable(void)
{
    3dd8:	3021ffe4 	addik	r1, r1, -28
    3ddc:	f9e10000 	swi	r15, r1, 0
        microblaze_flush_dcache();
    3de0:	b0000000 	imm	0
    3de4:	b9f40f44 	brlid	r15, 3908	// 4d28 <microblaze_flush_dcache>
    3de8:	80000000 	or	r0, r0, r0
	microblaze_invalidate_dcache();
    3dec:	b0000000 	imm	0
    3df0:	b9f40f60 	brlid	r15, 3936	// 4d50 <microblaze_invalidate_dcache>
    3df4:	80000000 	or	r0, r0, r0
	microblaze_disable_dcache();
    3df8:	b0000000 	imm	0
    3dfc:	b9f40e94 	brlid	r15, 3732	// 4c90 <microblaze_disable_dcache>
    3e00:	80000000 	or	r0, r0, r0
}
    3e04:	e9e10000 	lwi	r15, r1, 0
    3e08:	b60f0008 	rtsd	r15, 8
    3e0c:	3021001c 	addik	r1, r1, 28

00003e10 <Xil_ICacheDisable>:
* @note     
*
*
****************************************************************************/
void Xil_ICacheDisable(void)
{
    3e10:	3021ffe4 	addik	r1, r1, -28
    3e14:	f9e10000 	swi	r15, r1, 0
	microblaze_invalidate_icache();
    3e18:	b0000000 	imm	0
    3e1c:	b9f40f5c 	brlid	r15, 3932	// 4d78 <microblaze_invalidate_icache>
    3e20:	80000000 	or	r0, r0, r0
	microblaze_disable_icache();
    3e24:	b0000000 	imm	0
    3e28:	b9f40e94 	brlid	r15, 3732	// 4cbc <microblaze_disable_icache>
    3e2c:	80000000 	or	r0, r0, r0
}
    3e30:	e9e10000 	lwi	r15, r1, 0
    3e34:	b60f0008 	rtsd	r15, 8
    3e38:	3021001c 	addik	r1, r1, 28

00003e3c <Xil_ExceptionNullHandler>:
 *
 *****************************************************************************/
static void Xil_ExceptionNullHandler(void *Data)
{
	(void) Data;
}
    3e3c:	b60f0008 	rtsd	r15, 8
    3e40:	80000000 	or	r0, r0, r0

00003e44 <Xil_ExceptionInit>:
{
	/*
	 * there is no need to setup the exception table here
	 */

}
    3e44:	b60f0008 	rtsd	r15, 8
    3e48:	80000000 	or	r0, r0, r0

00003e4c <Xil_ExceptionEnable>:
*
* @note     None.
*
******************************************************************************/
void Xil_ExceptionEnable(void)
{
    3e4c:	3021ffe4 	addik	r1, r1, -28
    3e50:	f9e10000 	swi	r15, r1, 0
#ifdef MICROBLAZE_EXCEPTIONS_ENABLED
	microblaze_enable_exceptions();
    3e54:	b0000000 	imm	0
    3e58:	b9f40e9c 	brlid	r15, 3740	// 4cf4 <microblaze_enable_exceptions>
    3e5c:	80000000 	or	r0, r0, r0
#endif
	microblaze_enable_interrupts();
    3e60:	b0000000 	imm	0
    3e64:	b9f40ea4 	brlid	r15, 3748	// 4d08 <microblaze_enable_interrupts>
    3e68:	80000000 	or	r0, r0, r0
}
    3e6c:	e9e10000 	lwi	r15, r1, 0
    3e70:	b60f0008 	rtsd	r15, 8
    3e74:	3021001c 	addik	r1, r1, 28

00003e78 <Xil_ExceptionDisable>:
*
* @note     None.
*
******************************************************************************/
void Xil_ExceptionDisable(void)
{
    3e78:	3021ffe4 	addik	r1, r1, -28
    3e7c:	f9e10000 	swi	r15, r1, 0
#ifdef MICROBLAZE_EXCEPTIONS_ENABLED
	microblaze_disable_exceptions();
    3e80:	b0000000 	imm	0
    3e84:	b9f40e24 	brlid	r15, 3620	// 4ca8 <microblaze_disable_exceptions>
    3e88:	80000000 	or	r0, r0, r0
#endif
	microblaze_disable_interrupts();
    3e8c:	b0000000 	imm	0
    3e90:	b9f40e44 	brlid	r15, 3652	// 4cd4 <microblaze_disable_interrupts>
    3e94:	80000000 	or	r0, r0, r0
}
    3e98:	e9e10000 	lwi	r15, r1, 0
    3e9c:	b60f0008 	rtsd	r15, 8
    3ea0:	3021001c 	addik	r1, r1, 28

00003ea4 <Xil_ExceptionRegisterHandler>:
*
****************************************************************************/
void Xil_ExceptionRegisterHandler(u32 Id, Xil_ExceptionHandler Handler,
				  void *Data)
{
	if (Id == XIL_EXCEPTION_ID_INT) {
    3ea4:	a8650010 	xori	r3, r5, 16
    3ea8:	be03001c 	beqid	r3, 28		// 3ec4
    3eac:	60a50008 	muli	r5, r5, 8
		MB_InterruptVectorTable.Handler = Handler;
		MB_InterruptVectorTable.CallBackRef = Data;
	}
	else {
#ifdef MICROBLAZE_EXCEPTIONS_ENABLED
		MB_ExceptionVectorTable[Id].Handler = Handler;
    3eb0:	b0000000 	imm	0
    3eb4:	30a5e358 	addik	r5, r5, -7336
    3eb8:	f8c50000 	swi	r6, r5, 0
		MB_ExceptionVectorTable[Id].CallBackRef = Data;
    3ebc:	b60f0008 	rtsd	r15, 8
    3ec0:	f8e50004 	swi	r7, r5, 4
****************************************************************************/
void Xil_ExceptionRegisterHandler(u32 Id, Xil_ExceptionHandler Handler,
				  void *Data)
{
	if (Id == XIL_EXCEPTION_ID_INT) {
		MB_InterruptVectorTable.Handler = Handler;
    3ec4:	b0000000 	imm	0
    3ec8:	f8c0e398 	swi	r6, r0, -7272	// e398 <MB_InterruptVectorTable>
		MB_InterruptVectorTable.CallBackRef = Data;
    3ecc:	b0000000 	imm	0
    3ed0:	f8e0e39c 	swi	r7, r0, -7268
    3ed4:	b60f0008 	rtsd	r15, 8
    3ed8:	80000000 	or	r0, r0, r0

00003edc <Xil_ExceptionRemoveHandler>:
* None.
*
****************************************************************************/
void Xil_ExceptionRemoveHandler(u32 Id)
{
	if (Id == XIL_EXCEPTION_ID_INT) {
    3edc:	a8650010 	xori	r3, r5, 16
    3ee0:	be030024 	beqid	r3, 36		// 3f04
    3ee4:	60a50008 	muli	r5, r5, 8
		MB_InterruptVectorTable.CallBackRef = NULL;
	}
	else {

#ifdef MICROBLAZE_EXCEPTIONS_ENABLED
		MB_ExceptionVectorTable[Id].Handler =
    3ee8:	b0000000 	imm	0
    3eec:	30603e3c 	addik	r3, r0, 15932	// 3e3c <Xil_ExceptionNullHandler>
    3ef0:	b0000000 	imm	0
    3ef4:	30a5e358 	addik	r5, r5, -7336
    3ef8:	f8650000 	swi	r3, r5, 0
			Xil_ExceptionNullHandler;
		MB_ExceptionVectorTable[Id].CallBackRef = NULL;
    3efc:	b60f0008 	rtsd	r15, 8
    3f00:	f8050004 	swi	r0, r5, 4
*
****************************************************************************/
void Xil_ExceptionRemoveHandler(u32 Id)
{
	if (Id == XIL_EXCEPTION_ID_INT) {
		MB_InterruptVectorTable.Handler = Xil_ExceptionNullHandler;
    3f04:	b0000000 	imm	0
    3f08:	30803e3c 	addik	r4, r0, 15932	// 3e3c <Xil_ExceptionNullHandler>
		MB_InterruptVectorTable.CallBackRef = NULL;
    3f0c:	b0000000 	imm	0
    3f10:	f860e39c 	swi	r3, r0, -7268
*
****************************************************************************/
void Xil_ExceptionRemoveHandler(u32 Id)
{
	if (Id == XIL_EXCEPTION_ID_INT) {
		MB_InterruptVectorTable.Handler = Xil_ExceptionNullHandler;
    3f14:	b0000000 	imm	0
    3f18:	f880e398 	swi	r4, r0, -7272	// e398 <MB_InterruptVectorTable>
    3f1c:	b60f0008 	rtsd	r15, 8
    3f20:	80000000 	or	r0, r0, r0

00003f24 <XUartLite_SetRecvHandler>:
*		know what it is (nor should it)
*
*****************************************************************************/
void XUartLite_SetRecvHandler(XUartLite *InstancePtr,
				XUartLite_Handler FuncPtr, void *CallBackRef)
{
    3f24:	3021ffe4 	addik	r1, r1, -28
	/*
	 * Assert validates the input arguments
	 * CallBackRef not checked, no way to know what is valid
	 */
	Xil_AssertVoid(InstancePtr != NULL);
    3f28:	be050064 	beqid	r5, 100		// 3f8c
    3f2c:	f9e10000 	swi	r15, r1, 0
    3f30:	b0000000 	imm	0
    3f34:	f800ec58 	swi	r0, r0, -5032	// ec58 <Xil_AssertStatus>
	Xil_AssertVoid(FuncPtr != NULL);
    3f38:	bc06007c 	beqi	r6, 124		// 3fb4
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    3f3c:	e8650020 	lwi	r3, r5, 32
    3f40:	b0001111 	imm	4369
    3f44:	a8631111 	xori	r3, r3, 4369
    3f48:	bc030030 	beqi	r3, 48		// 3f78
    3f4c:	b0000000 	imm	0
    3f50:	30a0d8e8 	addik	r5, r0, -10008
    3f54:	b000ffff 	imm	-1
    3f58:	b9f4d2e8 	brlid	r15, -11544	// 1240 <Xil_Assert>
    3f5c:	30c00072 	addik	r6, r0, 114
    3f60:	30600001 	addik	r3, r0, 1
    3f64:	b0000000 	imm	0
    3f68:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>

	InstancePtr->RecvHandler = FuncPtr;
	InstancePtr->RecvCallBackRef = CallBackRef;
}
    3f6c:	e9e10000 	lwi	r15, r1, 0
    3f70:	b60f0008 	rtsd	r15, 8
    3f74:	3021001c 	addik	r1, r1, 28
	 */
	Xil_AssertVoid(InstancePtr != NULL);
	Xil_AssertVoid(FuncPtr != NULL);
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

	InstancePtr->RecvHandler = FuncPtr;
    3f78:	f8c5003c 	swi	r6, r5, 60
	InstancePtr->RecvCallBackRef = CallBackRef;
    3f7c:	f8e50040 	swi	r7, r5, 64
}
    3f80:	e9e10000 	lwi	r15, r1, 0
    3f84:	b60f0008 	rtsd	r15, 8
    3f88:	3021001c 	addik	r1, r1, 28
{
	/*
	 * Assert validates the input arguments
	 * CallBackRef not checked, no way to know what is valid
	 */
	Xil_AssertVoid(InstancePtr != NULL);
    3f8c:	b0000000 	imm	0
    3f90:	30a0d8e8 	addik	r5, r0, -10008
    3f94:	b000ffff 	imm	-1
    3f98:	b9f4d2a8 	brlid	r15, -11608	// 1240 <Xil_Assert>
    3f9c:	30c00070 	addik	r6, r0, 112
    3fa0:	30600001 	addik	r3, r0, 1
    3fa4:	b0000000 	imm	0
    3fa8:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
    3fac:	b810ffc4 	brid	-60		// 3f70
    3fb0:	e9e10000 	lwi	r15, r1, 0
	Xil_AssertVoid(FuncPtr != NULL);
    3fb4:	b0000000 	imm	0
    3fb8:	30a0d8e8 	addik	r5, r0, -10008
    3fbc:	b000ffff 	imm	-1
    3fc0:	b9f4d280 	brlid	r15, -11648	// 1240 <Xil_Assert>
    3fc4:	30c00071 	addik	r6, r0, 113
    3fc8:	30600001 	addik	r3, r0, 1
    3fcc:	b0000000 	imm	0
    3fd0:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
    3fd4:	b810ff9c 	brid	-100		// 3f70
    3fd8:	e9e10000 	lwi	r15, r1, 0

00003fdc <XUartLite_SetSendHandler>:
*		know what it is (nor should it)
*
*****************************************************************************/
void XUartLite_SetSendHandler(XUartLite *InstancePtr,
				XUartLite_Handler FuncPtr, void *CallBackRef)
{
    3fdc:	3021ffe4 	addik	r1, r1, -28
	/*
	 * Assert validates the input arguments
	 * CallBackRef not checked, no way to know what is valid
	 */
	Xil_AssertVoid(InstancePtr != NULL);
    3fe0:	be050064 	beqid	r5, 100		// 4044
    3fe4:	f9e10000 	swi	r15, r1, 0
    3fe8:	b0000000 	imm	0
    3fec:	f800ec58 	swi	r0, r0, -5032	// ec58 <Xil_AssertStatus>
	Xil_AssertVoid(FuncPtr != NULL);
    3ff0:	bc06007c 	beqi	r6, 124		// 406c
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    3ff4:	e8650020 	lwi	r3, r5, 32
    3ff8:	b0001111 	imm	4369
    3ffc:	a8631111 	xori	r3, r3, 4369
    4000:	bc030030 	beqi	r3, 48		// 4030
    4004:	b0000000 	imm	0
    4008:	30a0d8e8 	addik	r5, r0, -10008
    400c:	b000ffff 	imm	-1
    4010:	b9f4d230 	brlid	r15, -11728	// 1240 <Xil_Assert>
    4014:	30c00093 	addik	r6, r0, 147
    4018:	30600001 	addik	r3, r0, 1
    401c:	b0000000 	imm	0
    4020:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>

	InstancePtr->SendHandler = FuncPtr;
	InstancePtr->SendCallBackRef = CallBackRef;
}
    4024:	e9e10000 	lwi	r15, r1, 0
    4028:	b60f0008 	rtsd	r15, 8
    402c:	3021001c 	addik	r1, r1, 28
	 */
	Xil_AssertVoid(InstancePtr != NULL);
	Xil_AssertVoid(FuncPtr != NULL);
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

	InstancePtr->SendHandler = FuncPtr;
    4030:	f8c50044 	swi	r6, r5, 68
	InstancePtr->SendCallBackRef = CallBackRef;
    4034:	f8e50048 	swi	r7, r5, 72
}
    4038:	e9e10000 	lwi	r15, r1, 0
    403c:	b60f0008 	rtsd	r15, 8
    4040:	3021001c 	addik	r1, r1, 28
{
	/*
	 * Assert validates the input arguments
	 * CallBackRef not checked, no way to know what is valid
	 */
	Xil_AssertVoid(InstancePtr != NULL);
    4044:	b0000000 	imm	0
    4048:	30a0d8e8 	addik	r5, r0, -10008
    404c:	b000ffff 	imm	-1
    4050:	b9f4d1f0 	brlid	r15, -11792	// 1240 <Xil_Assert>
    4054:	30c00091 	addik	r6, r0, 145
    4058:	30600001 	addik	r3, r0, 1
    405c:	b0000000 	imm	0
    4060:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
    4064:	b810ffc4 	brid	-60		// 4028
    4068:	e9e10000 	lwi	r15, r1, 0
	Xil_AssertVoid(FuncPtr != NULL);
    406c:	b0000000 	imm	0
    4070:	30a0d8e8 	addik	r5, r0, -10008
    4074:	b000ffff 	imm	-1
    4078:	b9f4d1c8 	brlid	r15, -11832	// 1240 <Xil_Assert>
    407c:	30c00092 	addik	r6, r0, 146
    4080:	30600001 	addik	r3, r0, 1
    4084:	b0000000 	imm	0
    4088:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
    408c:	b810ff9c 	brid	-100		// 4028
    4090:	e9e10000 	lwi	r15, r1, 0

00004094 <XUartLite_InterruptHandler>:
*
* @note		None.
*
******************************************************************************/
void XUartLite_InterruptHandler(XUartLite *InstancePtr)
{
    4094:	3021ffdc 	addik	r1, r1, -36
    4098:	fa61001c 	swi	r19, r1, 28
    409c:	f9e10000 	swi	r15, r1, 0
    40a0:	fac10020 	swi	r22, r1, 32
	u32 IsrStatus;

	Xil_AssertVoid(InstancePtr != NULL);
    40a4:	be0500c0 	beqid	r5, 192		// 4164
    40a8:	12650000 	addk	r19, r5, r0

	/*
	 * Read the status register to determine which, coulb be both
	 * interrupt is active
	 */
	IsrStatus = XUartLite_ReadReg(InstancePtr->RegBaseAddress,
    40ac:	e865001c 	lwi	r3, r5, 28
******************************************************************************/
void XUartLite_InterruptHandler(XUartLite *InstancePtr)
{
	u32 IsrStatus;

	Xil_AssertVoid(InstancePtr != NULL);
    40b0:	b0000000 	imm	0
    40b4:	f800ec58 	swi	r0, r0, -5032	// ec58 <Xil_AssertStatus>

	/*
	 * Read the status register to determine which, coulb be both
	 * interrupt is active
	 */
	IsrStatus = XUartLite_ReadReg(InstancePtr->RegBaseAddress,
    40b8:	eac30008 	lwi	r22, r3, 8
					XUL_STATUS_REG_OFFSET);

	if ((IsrStatus & (XUL_SR_RX_FIFO_FULL |
    40bc:	a4760003 	andi	r3, r22, 3
    40c0:	bc030028 	beqi	r3, 40		// 40e8
{
	/*
	 * If there are bytes still to be received in the specified buffer
	 * go ahead and receive them
	 */
	if (InstancePtr->ReceiveBuffer.RemainingBytes != 0) {
    40c4:	e8650038 	lwi	r3, r5, 56
    40c8:	bc230080 	bnei	r3, 128		// 4148
	 * handler, this code should not use an else from the previous check of
	 * the number of bytes to receive because the call to receive the buffer
	 * updates the bytes to receive
	 */
	if (InstancePtr->ReceiveBuffer.RemainingBytes == 0) {
		InstancePtr->RecvHandler(InstancePtr->RecvCallBackRef,
    40cc:	e873003c 	lwi	r3, r19, 60
    40d0:	e8b30040 	lwi	r5, r19, 64
    40d4:	99fc1800 	brald	r15, r3
    40d8:	e8d30034 	lwi	r6, r19, 52
	}

	/*
	 * Update the receive stats to reflect the receive interrupt
	 */
	InstancePtr->Stats.ReceiveInterrupts++;
    40dc:	e8730004 	lwi	r3, r19, 4
    40e0:	30630001 	addik	r3, r3, 1
    40e4:	f8730004 	swi	r3, r19, 4
	if ((IsrStatus & (XUL_SR_RX_FIFO_FULL |
		XUL_SR_RX_FIFO_VALID_DATA)) != 0) {
		ReceiveDataHandler(InstancePtr);
	}

	if (((IsrStatus & XUL_SR_TX_FIFO_EMPTY) != 0) &&
    40e8:	a6d60004 	andi	r22, r22, 4
    40ec:	be160034 	beqid	r22, 52		// 4120
    40f0:	e9e10000 	lwi	r15, r1, 0
		(InstancePtr->SendBuffer.RequestedBytes > 0)) {
    40f4:	e8d30028 	lwi	r6, r19, 40
	if ((IsrStatus & (XUL_SR_RX_FIFO_FULL |
		XUL_SR_RX_FIFO_VALID_DATA)) != 0) {
		ReceiveDataHandler(InstancePtr);
	}

	if (((IsrStatus & XUL_SR_TX_FIFO_EMPTY) != 0) &&
    40f8:	bc060028 	beqi	r6, 40		// 4120
{
	/*
	 * If there are not bytes to be sent from the specified buffer,
	 * call the callback function
	 */
	if (InstancePtr->SendBuffer.RemainingBytes == 0) {
    40fc:	e873002c 	lwi	r3, r19, 44
    4100:	bc030030 	beqi	r3, 48		// 4130
	/*
	 * Otherwise there is still more data to send in the specified buffer
	 * so go ahead and send it
	 */
	else {
		XUartLite_SendBuffer(InstancePtr);
    4104:	b0000000 	imm	0
    4108:	b9f403b4 	brlid	r15, 948	// 44bc <XUartLite_SendBuffer>
    410c:	10b30000 	addk	r5, r19, r0
	}

	/*
	 * Update the transmit stats to reflect the transmit interrupt
	 */
	InstancePtr->Stats.TransmitInterrupts++;
    4110:	e8730000 	lwi	r3, r19, 0
    4114:	30630001 	addik	r3, r3, 1
    4118:	f8730000 	swi	r3, r19, 0

	if (((IsrStatus & XUL_SR_TX_FIFO_EMPTY) != 0) &&
		(InstancePtr->SendBuffer.RequestedBytes > 0)) {
		SendDataHandler(InstancePtr);
	}
}
    411c:	e9e10000 	lwi	r15, r1, 0
    4120:	ea61001c 	lwi	r19, r1, 28
    4124:	eac10020 	lwi	r22, r1, 32
    4128:	b60f0008 	rtsd	r15, 8
    412c:	30210024 	addik	r1, r1, 36

		/*
		 * Call the application handler to indicate
		 * the data has been sent
		 */
		InstancePtr->SendHandler(InstancePtr->SendCallBackRef, SaveReq);
    4130:	e8930044 	lwi	r4, r19, 68
    4134:	e8b30048 	lwi	r5, r19, 72
    4138:	99fc2000 	brald	r15, r4
    413c:	f8730028 	swi	r3, r19, 40
	}

	/*
	 * Update the transmit stats to reflect the transmit interrupt
	 */
	InstancePtr->Stats.TransmitInterrupts++;
    4140:	b810ffd4 	brid	-44		// 4114
    4144:	e8730000 	lwi	r3, r19, 0
	/*
	 * If there are bytes still to be received in the specified buffer
	 * go ahead and receive them
	 */
	if (InstancePtr->ReceiveBuffer.RemainingBytes != 0) {
		XUartLite_ReceiveBuffer(InstancePtr);
    4148:	b0000000 	imm	0
    414c:	b9f40564 	brlid	r15, 1380	// 46b0 <XUartLite_ReceiveBuffer>
    4150:	80000000 	or	r0, r0, r0
	 * If the last byte of a message was received then call the application
	 * handler, this code should not use an else from the previous check of
	 * the number of bytes to receive because the call to receive the buffer
	 * updates the bytes to receive
	 */
	if (InstancePtr->ReceiveBuffer.RemainingBytes == 0) {
    4154:	e8730038 	lwi	r3, r19, 56
    4158:	bc23ff84 	bnei	r3, -124		// 40dc
		InstancePtr->RecvHandler(InstancePtr->RecvCallBackRef,
    415c:	b810ff74 	brid	-140		// 40d0
    4160:	e873003c 	lwi	r3, r19, 60
******************************************************************************/
void XUartLite_InterruptHandler(XUartLite *InstancePtr)
{
	u32 IsrStatus;

	Xil_AssertVoid(InstancePtr != NULL);
    4164:	b0000000 	imm	0
    4168:	30a0d8e8 	addik	r5, r0, -10008
    416c:	b000ffff 	imm	-1
    4170:	b9f4d0d0 	brlid	r15, -12080	// 1240 <Xil_Assert>
    4174:	30c000ae 	addik	r6, r0, 174
    4178:	30600001 	addik	r3, r0, 1
    417c:	b0000000 	imm	0
    4180:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
    4184:	b810ff9c 	brid	-100		// 4120
    4188:	e9e10000 	lwi	r15, r1, 0

0000418c <XUartLite_DisableInterrupt>:
*
* @note		None.
*
*****************************************************************************/
void XUartLite_DisableInterrupt(XUartLite *InstancePtr)
{
    418c:	3021ffe4 	addik	r1, r1, -28
	Xil_AssertVoid(InstancePtr != NULL);
    4190:	be050060 	beqid	r5, 96		// 41f0
    4194:	f9e10000 	swi	r15, r1, 0
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    4198:	e8650020 	lwi	r3, r5, 32
* @note		None.
*
*****************************************************************************/
void XUartLite_DisableInterrupt(XUartLite *InstancePtr)
{
	Xil_AssertVoid(InstancePtr != NULL);
    419c:	b0000000 	imm	0
    41a0:	f800ec58 	swi	r0, r0, -5032	// ec58 <Xil_AssertStatus>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    41a4:	b0001111 	imm	4369
    41a8:	a8631111 	xori	r3, r3, 4369
    41ac:	bc030030 	beqi	r3, 48		// 41dc
    41b0:	b0000000 	imm	0
    41b4:	30a0d8e8 	addik	r5, r0, -10008
    41b8:	b000ffff 	imm	-1
    41bc:	b9f4d084 	brlid	r15, -12156	// 1240 <Xil_Assert>
    41c0:	30c0012e 	addik	r6, r0, 302
    41c4:	30600001 	addik	r3, r0, 1
    41c8:	b0000000 	imm	0
    41cc:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
	 * other bits in this register are the FIFO reset bits such that
	 * writing them to zero will not affect them.
	 */
	XUartLite_WriteReg(InstancePtr->RegBaseAddress,
				XUL_CONTROL_REG_OFFSET, 0);
}
    41d0:	e9e10000 	lwi	r15, r1, 0
    41d4:	b60f0008 	rtsd	r15, 8
    41d8:	3021001c 	addik	r1, r1, 28
	/*
	 * Write to the control register to disable the interrupts, the only
	 * other bits in this register are the FIFO reset bits such that
	 * writing them to zero will not affect them.
	 */
	XUartLite_WriteReg(InstancePtr->RegBaseAddress,
    41dc:	e885001c 	lwi	r4, r5, 28
    41e0:	f864000c 	swi	r3, r4, 12
				XUL_CONTROL_REG_OFFSET, 0);
}
    41e4:	e9e10000 	lwi	r15, r1, 0
    41e8:	b60f0008 	rtsd	r15, 8
    41ec:	3021001c 	addik	r1, r1, 28
* @note		None.
*
*****************************************************************************/
void XUartLite_DisableInterrupt(XUartLite *InstancePtr)
{
	Xil_AssertVoid(InstancePtr != NULL);
    41f0:	b0000000 	imm	0
    41f4:	30a0d8e8 	addik	r5, r0, -10008
    41f8:	b000ffff 	imm	-1
    41fc:	b9f4d044 	brlid	r15, -12220	// 1240 <Xil_Assert>
    4200:	30c0012d 	addik	r6, r0, 301
    4204:	30600001 	addik	r3, r0, 1
    4208:	b0000000 	imm	0
    420c:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
    4210:	b810ffc4 	brid	-60		// 41d4
    4214:	e9e10000 	lwi	r15, r1, 0

00004218 <XUartLite_EnableInterrupt>:
*
* @note		None.
*
*****************************************************************************/
void XUartLite_EnableInterrupt(XUartLite *InstancePtr)
{
    4218:	3021ffe4 	addik	r1, r1, -28
	Xil_AssertVoid(InstancePtr != NULL);
    421c:	be050064 	beqid	r5, 100		// 4280
    4220:	f9e10000 	swi	r15, r1, 0
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    4224:	e8650020 	lwi	r3, r5, 32
* @note		None.
*
*****************************************************************************/
void XUartLite_EnableInterrupt(XUartLite *InstancePtr)
{
	Xil_AssertVoid(InstancePtr != NULL);
    4228:	b0000000 	imm	0
    422c:	f800ec58 	swi	r0, r0, -5032	// ec58 <Xil_AssertStatus>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    4230:	b0001111 	imm	4369
    4234:	a8631111 	xori	r3, r3, 4369
    4238:	be030034 	beqid	r3, 52		// 426c
    423c:	30800010 	addik	r4, r0, 16	// 10 <_vector_interrupt>
    4240:	b0000000 	imm	0
    4244:	30a0d8e8 	addik	r5, r0, -10008
    4248:	b000ffff 	imm	-1
    424c:	b9f4cff4 	brlid	r15, -12300	// 1240 <Xil_Assert>
    4250:	30c0014c 	addik	r6, r0, 332
    4254:	30600001 	addik	r3, r0, 1
    4258:	b0000000 	imm	0
    425c:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
	 * other bits in this register are the FIFO reset bits such that
	 * writing them to zero will not affect them.
	 */
	XUartLite_WriteReg(InstancePtr->RegBaseAddress,
				XUL_CONTROL_REG_OFFSET, XUL_CR_ENABLE_INTR);
}
    4260:	e9e10000 	lwi	r15, r1, 0
    4264:	b60f0008 	rtsd	r15, 8
    4268:	3021001c 	addik	r1, r1, 28
	/*
	 * Write to the control register to enable the interrupts, the only
	 * other bits in this register are the FIFO reset bits such that
	 * writing them to zero will not affect them.
	 */
	XUartLite_WriteReg(InstancePtr->RegBaseAddress,
    426c:	e865001c 	lwi	r3, r5, 28
    4270:	f883000c 	swi	r4, r3, 12
				XUL_CONTROL_REG_OFFSET, XUL_CR_ENABLE_INTR);
}
    4274:	e9e10000 	lwi	r15, r1, 0
    4278:	b60f0008 	rtsd	r15, 8
    427c:	3021001c 	addik	r1, r1, 28
* @note		None.
*
*****************************************************************************/
void XUartLite_EnableInterrupt(XUartLite *InstancePtr)
{
	Xil_AssertVoid(InstancePtr != NULL);
    4280:	b0000000 	imm	0
    4284:	30a0d8e8 	addik	r5, r0, -10008
    4288:	b000ffff 	imm	-1
    428c:	b9f4cfb4 	brlid	r15, -12364	// 1240 <Xil_Assert>
    4290:	30c0014b 	addik	r6, r0, 331
    4294:	30600001 	addik	r3, r0, 1
    4298:	b0000000 	imm	0
    429c:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
    42a0:	b810ffc4 	brid	-60		// 4264
    42a4:	e9e10000 	lwi	r15, r1, 0

000042a8 <XUartLite_SendByte>:
*
* @note		None.
*
******************************************************************************/
void XUartLite_SendByte(u32 BaseAddress, u8 Data)
{
    42a8:	30850008 	addik	r4, r5, 8
	while (XUartLite_IsTransmitFull(BaseAddress));
    42ac:	e8640000 	lwi	r3, r4, 0
    42b0:	a4630008 	andi	r3, r3, 8
    42b4:	bc23fff8 	bnei	r3, -8		// 42ac

	XUartLite_WriteReg(BaseAddress, XUL_TX_FIFO_OFFSET, Data);
    42b8:	f8c50004 	swi	r6, r5, 4
}
    42bc:	b60f0008 	rtsd	r15, 8
    42c0:	80000000 	or	r0, r0, r0

000042c4 <XUartLite_RecvByte>:
*
* @note		None.
*
******************************************************************************/
u8 XUartLite_RecvByte(u32 BaseAddress)
{
    42c4:	30850008 	addik	r4, r5, 8
	while (XUartLite_IsReceiveEmpty(BaseAddress));
    42c8:	e8640000 	lwi	r3, r4, 0
    42cc:	a4630001 	andi	r3, r3, 1
    42d0:	bc03fff8 	beqi	r3, -8		// 42c8

	return (u8)XUartLite_ReadReg(BaseAddress, XUL_RX_FIFO_OFFSET);
    42d4:	e8650000 	lwi	r3, r5, 0
}
    42d8:	b60f0008 	rtsd	r15, 8
    42dc:	a46300ff 	andi	r3, r3, 255

000042e0 <StubHandler>:
static void StubHandler(void *CallBackRef, unsigned int ByteCount)
{
	/*
	 * Assert occurs always since this is a stub and should never be called
	 */
	Xil_AssertVoidAlways();
    42e0:	b0000000 	imm	0
    42e4:	30a0d8fc 	addik	r5, r0, -9988
*
* @note		None.
*
*****************************************************************************/
static void StubHandler(void *CallBackRef, unsigned int ByteCount)
{
    42e8:	3021ffe4 	addik	r1, r1, -28
    42ec:	f9e10000 	swi	r15, r1, 0
	/*
	 * Assert occurs always since this is a stub and should never be called
	 */
	Xil_AssertVoidAlways();
    42f0:	b000ffff 	imm	-1
    42f4:	b9f4cf4c 	brlid	r15, -12468	// 1240 <Xil_Assert>
    42f8:	30c001bc 	addik	r6, r0, 444
}
    42fc:	e9e10000 	lwi	r15, r1, 0
static void StubHandler(void *CallBackRef, unsigned int ByteCount)
{
	/*
	 * Assert occurs always since this is a stub and should never be called
	 */
	Xil_AssertVoidAlways();
    4300:	30600001 	addik	r3, r0, 1
    4304:	b0000000 	imm	0
    4308:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
}
    430c:	b60f0008 	rtsd	r15, 8
    4310:	3021001c 	addik	r1, r1, 28

00004314 <XUartLite_CfgInitialize>:
*		with other drivers.
*
*****************************************************************************/
int XUartLite_CfgInitialize(XUartLite *InstancePtr, XUartLite_Config *Config,
				u32 EffectiveAddr)
{
    4314:	3021ffe4 	addik	r1, r1, -28
	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
    4318:	be050068 	beqid	r5, 104		// 4380
    431c:	f9e10000 	swi	r15, r1, 0

	InstancePtr->ReceiveBuffer.NextBytePtr = NULL;
	InstancePtr->ReceiveBuffer.RemainingBytes = 0;
	InstancePtr->ReceiveBuffer.RequestedBytes = 0;

	InstancePtr->IsReady = XIL_COMPONENT_IS_READY;
    4320:	b0001111 	imm	4369
    4324:	30801111 	addik	r4, r0, 4369

	/*
	 * Set some default values, including setting the callback
	 * handlers to stubs.
	 */
	InstancePtr->SendBuffer.NextBytePtr = NULL;
    4328:	f8050024 	swi	r0, r5, 36
	InstancePtr->SendBuffer.RemainingBytes = 0;
    432c:	f805002c 	swi	r0, r5, 44

	InstancePtr->ReceiveBuffer.NextBytePtr = NULL;
	InstancePtr->ReceiveBuffer.RemainingBytes = 0;
	InstancePtr->ReceiveBuffer.RequestedBytes = 0;

	InstancePtr->IsReady = XIL_COMPONENT_IS_READY;
    4330:	f8850020 	swi	r4, r5, 32
	InstancePtr->RegBaseAddress = ((EffectiveAddr >> 2)) & 0xFFF;
#else
	InstancePtr->RegBaseAddress = EffectiveAddr;
#endif

	InstancePtr->RecvHandler = StubHandler;
    4334:	b0000000 	imm	0
    4338:	308042e0 	addik	r4, r0, 17120	// 42e0 <StubHandler>
	 * Set some default values, including setting the callback
	 * handlers to stubs.
	 */
	InstancePtr->SendBuffer.NextBytePtr = NULL;
	InstancePtr->SendBuffer.RemainingBytes = 0;
	InstancePtr->SendBuffer.RequestedBytes = 0;
    433c:	f8050028 	swi	r0, r5, 40

	InstancePtr->ReceiveBuffer.NextBytePtr = NULL;
    4340:	f8050030 	swi	r0, r5, 48
	InstancePtr->RegBaseAddress = ((EffectiveAddr >> 2)) & 0xFFF;
#else
	InstancePtr->RegBaseAddress = EffectiveAddr;
#endif

	InstancePtr->RecvHandler = StubHandler;
    4344:	f885003c 	swi	r4, r5, 60
	InstancePtr->SendHandler = StubHandler;
    4348:	f8850044 	swi	r4, r5, 68
	InstancePtr->SendBuffer.NextBytePtr = NULL;
	InstancePtr->SendBuffer.RemainingBytes = 0;
	InstancePtr->SendBuffer.RequestedBytes = 0;

	InstancePtr->ReceiveBuffer.NextBytePtr = NULL;
	InstancePtr->ReceiveBuffer.RemainingBytes = 0;
    434c:	f8050038 	swi	r0, r5, 56
	InstancePtr->ReceiveBuffer.RequestedBytes = 0;
    4350:	f8050034 	swi	r0, r5, 52
	InstancePtr->IsReady = XIL_COMPONENT_IS_READY;

#if (XPAR_XUARTLITE_USE_DCR_BRIDGE != 0)
	InstancePtr->RegBaseAddress = ((EffectiveAddr >> 2)) & 0xFFF;
#else
	InstancePtr->RegBaseAddress = EffectiveAddr;
    4354:	f8e5001c 	swi	r7, r5, 28
				u32 EffectiveAddr)
{
	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
    4358:	b0000000 	imm	0
    435c:	f800ec58 	swi	r0, r0, -5032	// ec58 <Xil_AssertStatus>
	InstancePtr->SendHandler = StubHandler;

	/* Write to the control register to disable the interrupts, don't
	 * reset the FIFOs are the user may want the data that's present
	 */
	XUartLite_WriteReg(InstancePtr->RegBaseAddress,
    4360:	f807000c 	swi	r0, r7, 12
				XUL_CONTROL_REG_OFFSET, 0);

	/*
	 * Clear the statistics for this driver
	 */
	XUartLite_ClearStats(InstancePtr);
    4364:	b0000000 	imm	0
    4368:	b9f4080c 	brlid	r15, 2060	// 4b74 <XUartLite_ClearStats>
    436c:	80000000 	or	r0, r0, r0

	return XST_SUCCESS;
}
    4370:	e9e10000 	lwi	r15, r1, 0
    4374:	10600000 	addk	r3, r0, r0
    4378:	b60f0008 	rtsd	r15, 8
    437c:	3021001c 	addik	r1, r1, 28
				u32 EffectiveAddr)
{
	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
    4380:	b0000000 	imm	0
    4384:	30a0d8fc 	addik	r5, r0, -9988
    4388:	b000ffff 	imm	-1
    438c:	b9f4ceb4 	brlid	r15, -12620	// 1240 <Xil_Assert>
    4390:	30c0008e 	addik	r6, r0, 142
	 * Clear the statistics for this driver
	 */
	XUartLite_ClearStats(InstancePtr);

	return XST_SUCCESS;
}
    4394:	e9e10000 	lwi	r15, r1, 0
				u32 EffectiveAddr)
{
	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
    4398:	30600001 	addik	r3, r0, 1
    439c:	b0000000 	imm	0
    43a0:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
	 * Clear the statistics for this driver
	 */
	XUartLite_ClearStats(InstancePtr);

	return XST_SUCCESS;
}
    43a4:	10600000 	addk	r3, r0, r0
    43a8:	b60f0008 	rtsd	r15, 8
    43ac:	3021001c 	addik	r1, r1, 28

000043b0 <XUartLite_ResetFifos>:
*
* @note		None.
*
*****************************************************************************/
void XUartLite_ResetFifos(XUartLite *InstancePtr)
{
    43b0:	3021ffe4 	addik	r1, r1, -28
	u32 Register;

	Xil_AssertVoid(InstancePtr != NULL);
    43b4:	be05006c 	beqid	r5, 108		// 4420
    43b8:	f9e10000 	swi	r15, r1, 0
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    43bc:	e8650020 	lwi	r3, r5, 32
*****************************************************************************/
void XUartLite_ResetFifos(XUartLite *InstancePtr)
{
	u32 Register;

	Xil_AssertVoid(InstancePtr != NULL);
    43c0:	b0000000 	imm	0
    43c4:	f800ec58 	swi	r0, r0, -5032	// ec58 <Xil_AssertStatus>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    43c8:	b0001111 	imm	4369
    43cc:	a8631111 	xori	r3, r3, 4369
    43d0:	bc030030 	beqi	r3, 48		// 4400
    43d4:	b0000000 	imm	0
    43d8:	30a0d8fc 	addik	r5, r0, -9988
    43dc:	b000ffff 	imm	-1
    43e0:	b9f4ce60 	brlid	r15, -12704	// 1240 <Xil_Assert>
    43e4:	30c0016e 	addik	r6, r0, 366
    43e8:	30600001 	addik	r3, r0, 1
    43ec:	b0000000 	imm	0
    43f0:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
	 * Write to the control register to reset both FIFOs, these bits are
	 * self-clearing such that there's no need to clear them
	 */
	XUartLite_WriteReg(InstancePtr->RegBaseAddress, XUL_CONTROL_REG_OFFSET,
			Register | XUL_CR_FIFO_TX_RESET | XUL_CR_FIFO_RX_RESET);
}
    43f4:	e9e10000 	lwi	r15, r1, 0
    43f8:	b60f0008 	rtsd	r15, 8
    43fc:	3021001c 	addik	r1, r1, 28

	/*
	 * Read the status register 1st such that the next write to the control
	 * register won't destroy the state of the interrupt enable bit
	 */
	Register = XUartLite_ReadReg(InstancePtr->RegBaseAddress,
    4400:	e865001c 	lwi	r3, r5, 28
    4404:	e8830008 	lwi	r4, r3, 8
					XUL_STATUS_REG_OFFSET);

	/*
	 * Mask off the interrupt enable bit to maintain it's state.
	 */
	Register &= XUL_SR_INTR_ENABLED;
    4408:	a4840010 	andi	r4, r4, 16

	/*
	 * Write to the control register to reset both FIFOs, these bits are
	 * self-clearing such that there's no need to clear them
	 */
	XUartLite_WriteReg(InstancePtr->RegBaseAddress, XUL_CONTROL_REG_OFFSET,
    440c:	a0840003 	ori	r4, r4, 3
    4410:	f883000c 	swi	r4, r3, 12
			Register | XUL_CR_FIFO_TX_RESET | XUL_CR_FIFO_RX_RESET);
}
    4414:	e9e10000 	lwi	r15, r1, 0
    4418:	b60f0008 	rtsd	r15, 8
    441c:	3021001c 	addik	r1, r1, 28
*****************************************************************************/
void XUartLite_ResetFifos(XUartLite *InstancePtr)
{
	u32 Register;

	Xil_AssertVoid(InstancePtr != NULL);
    4420:	b0000000 	imm	0
    4424:	30a0d8fc 	addik	r5, r0, -9988
    4428:	b000ffff 	imm	-1
    442c:	b9f4ce14 	brlid	r15, -12780	// 1240 <Xil_Assert>
    4430:	30c0016d 	addik	r6, r0, 365
    4434:	30600001 	addik	r3, r0, 1
    4438:	b0000000 	imm	0
    443c:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
    4440:	b810ffb8 	brid	-72		// 43f8
    4444:	e9e10000 	lwi	r15, r1, 0

00004448 <XUartLite_IsSending>:
*
* @note		None.
*
*****************************************************************************/
int XUartLite_IsSending(XUartLite *InstancePtr)
{
    4448:	3021ffe0 	addik	r1, r1, -32
    444c:	fa61001c 	swi	r19, r1, 28
    4450:	f9e10000 	swi	r15, r1, 0
	u32 StatusRegister;

	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
    4454:	be050034 	beqid	r5, 52		// 4488
    4458:	12650000 	addk	r19, r5, r0

	/*
	 * Read the status register to determine if the transmitter is empty
	 */
	StatusRegister = XUartLite_ReadReg(InstancePtr->RegBaseAddress,
    445c:	e865001c 	lwi	r3, r5, 28
	/*
	 * If the transmitter is not empty then indicate that the UART is still
	 * sending some data
	 */
	return ((StatusRegister & XUL_SR_TX_FIFO_EMPTY) == 0);
}
    4460:	e9e10000 	lwi	r15, r1, 0
    4464:	ea61001c 	lwi	r19, r1, 28
	Xil_AssertNonvoid(InstancePtr != NULL);

	/*
	 * Read the status register to determine if the transmitter is empty
	 */
	StatusRegister = XUartLite_ReadReg(InstancePtr->RegBaseAddress,
    4468:	e8630008 	lwi	r3, r3, 8

	/*
	 * If the transmitter is not empty then indicate that the UART is still
	 * sending some data
	 */
	return ((StatusRegister & XUL_SR_TX_FIFO_EMPTY) == 0);
    446c:	10800000 	addk	r4, r0, r0
	u32 StatusRegister;

	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
    4470:	b0000000 	imm	0
    4474:	f800ec58 	swi	r0, r0, -5032	// ec58 <Xil_AssertStatus>

	/*
	 * If the transmitter is not empty then indicate that the UART is still
	 * sending some data
	 */
	return ((StatusRegister & XUL_SR_TX_FIFO_EMPTY) == 0);
    4478:	a4630004 	andi	r3, r3, 4
    447c:	88632400 	pcmpeq	r3, r3, r4
}
    4480:	b60f0008 	rtsd	r15, 8
    4484:	30210020 	addik	r1, r1, 32
	u32 StatusRegister;

	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
    4488:	b0000000 	imm	0
    448c:	30a0d8fc 	addik	r5, r0, -9988
    4490:	b000ffff 	imm	-1
    4494:	b9f4cdac 	brlid	r15, -12884	// 1240 <Xil_Assert>
    4498:	30c00198 	addik	r6, r0, 408
    449c:	30600001 	addik	r3, r0, 1
    44a0:	b0000000 	imm	0
    44a4:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
	/*
	 * If the transmitter is not empty then indicate that the UART is still
	 * sending some data
	 */
	return ((StatusRegister & XUL_SR_TX_FIFO_EMPTY) == 0);
}
    44a8:	e9e10000 	lwi	r15, r1, 0
	u32 StatusRegister;

	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
    44ac:	10730000 	addk	r3, r19, r0
	/*
	 * If the transmitter is not empty then indicate that the UART is still
	 * sending some data
	 */
	return ((StatusRegister & XUL_SR_TX_FIFO_EMPTY) == 0);
}
    44b0:	ea61001c 	lwi	r19, r1, 28
    44b4:	b60f0008 	rtsd	r15, 8
    44b8:	30210020 	addik	r1, r1, 32

000044bc <XUartLite_SendBuffer>:
	u8 IntrEnableStatus;

	/*
	 * Read the status register to determine if the transmitter is full
	 */
	StatusRegister = XUartLite_GetStatusReg(InstancePtr->RegBaseAddress);
    44bc:	e865001c 	lwi	r3, r5, 28
    44c0:	e8830008 	lwi	r4, r3, 8

	/*
	 * Enter a critical region by disabling all the UART interrupts to allow
	 * this call to stop a previous operation that may be interrupt driven
	 */
	StatusRegister = XUartLite_GetStatusReg(InstancePtr->RegBaseAddress);
    44c4:	e9430008 	lwi	r10, r3, 8
	XUartLite_WriteReg(InstancePtr->RegBaseAddress,
    44c8:	f803000c 	swi	r0, r3, 12

	/*
	 * Enter a critical region by disabling all the UART interrupts to allow
	 * this call to stop a previous operation that may be interrupt driven
	 */
	StatusRegister = XUartLite_GetStatusReg(InstancePtr->RegBaseAddress);
    44cc:	a54a00ff 	andi	r10, r10, 255

	/*
	 * Fill the FIFO from the the buffer that was specified
	 */

	while (((StatusRegister & XUL_SR_TX_FIFO_FULL) == 0) &&
    44d0:	a46a0008 	andi	r3, r10, 8
    44d4:	bc23006c 	bnei	r3, 108		// 4540
		(SentCount < InstancePtr->SendBuffer.RemainingBytes)) {
    44d8:	e905002c 	lwi	r8, r5, 44

	/*
	 * Fill the FIFO from the the buffer that was specified
	 */

	while (((StatusRegister & XUL_SR_TX_FIFO_FULL) == 0) &&
    44dc:	bc080078 	beqi	r8, 120		// 4554
    44e0:	e885001c 	lwi	r4, r5, 28
    44e4:	b810000c 	brid	12		// 44f0
    44e8:	e9250024 	lwi	r9, r5, 36
    44ec:	bca70024 	bgei	r7, 36		// 4510
		(SentCount < InstancePtr->SendBuffer.RemainingBytes)) {
		XUartLite_WriteReg(InstancePtr->RegBaseAddress,
    44f0:	c0c34800 	lbu	r6, r3, r9
					XUL_TX_FIFO_OFFSET,
					InstancePtr->SendBuffer.NextBytePtr[
					SentCount]);

		SentCount++;
    44f4:	30630001 	addik	r3, r3, 1

	/*
	 * Fill the FIFO from the the buffer that was specified
	 */

	while (((StatusRegister & XUL_SR_TX_FIFO_FULL) == 0) &&
    44f8:	14e81803 	cmpu	r7, r8, r3
		(SentCount < InstancePtr->SendBuffer.RemainingBytes)) {
		XUartLite_WriteReg(InstancePtr->RegBaseAddress,
    44fc:	f8c40004 	swi	r6, r4, 4
					SentCount]);

		SentCount++;

		StatusRegister =
			XUartLite_GetStatusReg(InstancePtr->RegBaseAddress);
    4500:	e885001c 	lwi	r4, r5, 28
    4504:	e8c40008 	lwi	r6, r4, 8

	/*
	 * Fill the FIFO from the the buffer that was specified
	 */

	while (((StatusRegister & XUL_SR_TX_FIFO_FULL) == 0) &&
    4508:	a4c60008 	andi	r6, r6, 8
    450c:	bc06ffe0 	beqi	r6, -32		// 44ec
	InstancePtr->SendBuffer.RemainingBytes -= SentCount;

	/*
	 * Increment associated counters
	 */
	 InstancePtr->Stats.CharactersTransmitted += SentCount;
    4510:	e8c50008 	lwi	r6, r5, 8
	}

	/*
	 * Update the buffer to reflect the bytes that were sent from it
	 */
	InstancePtr->SendBuffer.NextBytePtr += SentCount;
    4514:	11291800 	addk	r9, r9, r3
	InstancePtr->SendBuffer.RemainingBytes -= SentCount;
    4518:	15034000 	rsubk	r8, r3, r8

	/*
	 * Increment associated counters
	 */
	 InstancePtr->Stats.CharactersTransmitted += SentCount;
    451c:	10c61800 	addk	r6, r6, r3

	/*
	 * Restore the interrupt enable register to it's previous value such
	 * that the critical region is exited
	 */
	IntrEnableStatus &= XUL_CR_ENABLE_INTR;
    4520:	a54a0010 	andi	r10, r10, 16
	}

	/*
	 * Update the buffer to reflect the bytes that were sent from it
	 */
	InstancePtr->SendBuffer.NextBytePtr += SentCount;
    4524:	f9250024 	swi	r9, r5, 36
	InstancePtr->SendBuffer.RemainingBytes -= SentCount;
    4528:	f905002c 	swi	r8, r5, 44

	/*
	 * Increment associated counters
	 */
	 InstancePtr->Stats.CharactersTransmitted += SentCount;
    452c:	f8c50008 	swi	r6, r5, 8
	/*
	 * Restore the interrupt enable register to it's previous value such
	 * that the critical region is exited
	 */
	IntrEnableStatus &= XUL_CR_ENABLE_INTR;
	XUartLite_WriteReg(InstancePtr->RegBaseAddress, XUL_CONTROL_REG_OFFSET,
    4530:	a54a00ff 	andi	r10, r10, 255
    4534:	f944000c 	swi	r10, r4, 12
	/*
	 * Return the number of bytes that were sent, althought they really were
	 * only put into the FIFO, not completely sent yet
	 */
	return SentCount;
}
    4538:	b60f0008 	rtsd	r15, 8
    453c:	80000000 	or	r0, r0, r0

	/*
	 * Fill the FIFO from the the buffer that was specified
	 */

	while (((StatusRegister & XUL_SR_TX_FIFO_FULL) == 0) &&
    4540:	e9250024 	lwi	r9, r5, 36
    4544:	e905002c 	lwi	r8, r5, 44
    4548:	e885001c 	lwi	r4, r5, 28
* @note		None.
*
*****************************************************************************/
unsigned int XUartLite_SendBuffer(XUartLite *InstancePtr)
{
	unsigned int SentCount = 0;
    454c:	b810ffc4 	brid	-60		// 4510
    4550:	10600000 	addk	r3, r0, r0

	/*
	 * Fill the FIFO from the the buffer that was specified
	 */

	while (((StatusRegister & XUL_SR_TX_FIFO_FULL) == 0) &&
    4554:	e9250024 	lwi	r9, r5, 36
    4558:	e885001c 	lwi	r4, r5, 28
* @note		None.
*
*****************************************************************************/
unsigned int XUartLite_SendBuffer(XUartLite *InstancePtr)
{
	unsigned int SentCount = 0;
    455c:	b810ffb4 	brid	-76		// 4510
    4560:	10680000 	addk	r3, r8, r0

00004564 <XUartLite_Send>:
*		already in progress.
*
******************************************************************************/
unsigned int XUartLite_Send(XUartLite *InstancePtr, u8 *DataBufferPtr,
				unsigned int NumBytes)
{
    4564:	3021ffd8 	addik	r1, r1, -40
    4568:	fa61001c 	swi	r19, r1, 28
    456c:	fac10020 	swi	r22, r1, 32
    4570:	f9e10000 	swi	r15, r1, 0
    4574:	fae10024 	swi	r23, r1, 36
    4578:	12650000 	addk	r19, r5, r0
	u32 StatusRegister;

	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
    457c:	be0500e4 	beqid	r5, 228		// 4660
    4580:	12c60000 	addk	r22, r6, r0
    4584:	b0000000 	imm	0
    4588:	f800ec58 	swi	r0, r0, -5032	// ec58 <Xil_AssertStatus>
	Xil_AssertNonvoid(DataBufferPtr != NULL);
    458c:	bc0600fc 	beqi	r6, 252		// 4688
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    4590:	eae50020 	lwi	r23, r5, 32
    4594:	b0001111 	imm	4369
    4598:	aaf71111 	xori	r23, r23, 4369
    459c:	bc370088 	bnei	r23, 136		// 4624
	Xil_AssertNonvoid(((signed)NumBytes) >= 0);
    45a0:	bc470048 	blti	r7, 72		// 45e8

	/*
	 * Enter a critical region by disabling the UART interrupts to allow
	 * this call to stop a previous operation that may be interrupt driven.
	 */
	StatusRegister = XUartLite_GetStatusReg(InstancePtr->RegBaseAddress);
    45a4:	e865001c 	lwi	r3, r5, 28
    45a8:	e8830008 	lwi	r4, r3, 8

	XUartLite_WriteReg(InstancePtr->RegBaseAddress,
    45ac:	fae3000c 	swi	r23, r3, 12
	 * disabled since there is only one interrupt and the receive could
	 * be filling up while interrupts are blocked.
	 */

	StatusRegister &= XUL_CR_ENABLE_INTR;
	XUartLite_WriteReg(InstancePtr->RegBaseAddress,
    45b0:	e865001c 	lwi	r3, r5, 28

	/*
	 * Setup the specified buffer to be sent by setting the instance
	 * variables so it can be sent with polled or interrupt mode
	 */
	InstancePtr->SendBuffer.RequestedBytes = NumBytes;
    45b4:	f8e50028 	swi	r7, r5, 40
	InstancePtr->SendBuffer.RemainingBytes = NumBytes;
    45b8:	f8e5002c 	swi	r7, r5, 44
	InstancePtr->SendBuffer.NextBytePtr = DataBufferPtr;
    45bc:	f8d30024 	swi	r6, r19, 36
	 * This is done here to minimize the amount of time the interrupt is
	 * disabled since there is only one interrupt and the receive could
	 * be filling up while interrupts are blocked.
	 */

	StatusRegister &= XUL_CR_ENABLE_INTR;
    45c0:	a4840010 	andi	r4, r4, 16
	XUartLite_WriteReg(InstancePtr->RegBaseAddress,
    45c4:	f883000c 	swi	r4, r3, 12
				XUL_CONTROL_REG_OFFSET, StatusRegister);

	/*
	 * Send the buffer using the UART and return the number of bytes sent
	 */
	BytesSent = XUartLite_SendBuffer(InstancePtr);
    45c8:	b9f4fef4 	brlid	r15, -268	// 44bc <XUartLite_SendBuffer>
    45cc:	80000000 	or	r0, r0, r0

	return BytesSent;
}
    45d0:	e9e10000 	lwi	r15, r1, 0
    45d4:	ea61001c 	lwi	r19, r1, 28
    45d8:	eac10020 	lwi	r22, r1, 32
    45dc:	eae10024 	lwi	r23, r1, 36
    45e0:	b60f0008 	rtsd	r15, 8
    45e4:	30210028 	addik	r1, r1, 40
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
	Xil_AssertNonvoid(DataBufferPtr != NULL);
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
	Xil_AssertNonvoid(((signed)NumBytes) >= 0);
    45e8:	b0000000 	imm	0
    45ec:	30a0d8fc 	addik	r5, r0, -9988
    45f0:	b000ffff 	imm	-1
    45f4:	b9f4cc4c 	brlid	r15, -13236	// 1240 <Xil_Assert>
    45f8:	30c000e0 	addik	r6, r0, 224
    45fc:	30600001 	addik	r3, r0, 1
    4600:	b0000000 	imm	0
    4604:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
	 * Send the buffer using the UART and return the number of bytes sent
	 */
	BytesSent = XUartLite_SendBuffer(InstancePtr);

	return BytesSent;
}
    4608:	e9e10000 	lwi	r15, r1, 0
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
	Xil_AssertNonvoid(DataBufferPtr != NULL);
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
	Xil_AssertNonvoid(((signed)NumBytes) >= 0);
    460c:	10770000 	addk	r3, r23, r0
	 * Send the buffer using the UART and return the number of bytes sent
	 */
	BytesSent = XUartLite_SendBuffer(InstancePtr);

	return BytesSent;
}
    4610:	ea61001c 	lwi	r19, r1, 28
    4614:	eac10020 	lwi	r22, r1, 32
    4618:	eae10024 	lwi	r23, r1, 36
    461c:	b60f0008 	rtsd	r15, 8
    4620:	30210028 	addik	r1, r1, 40
	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
	Xil_AssertNonvoid(DataBufferPtr != NULL);
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    4624:	b0000000 	imm	0
    4628:	30a0d8fc 	addik	r5, r0, -9988
    462c:	b000ffff 	imm	-1
    4630:	b9f4cc10 	brlid	r15, -13296	// 1240 <Xil_Assert>
    4634:	30c000df 	addik	r6, r0, 223
	 * Send the buffer using the UART and return the number of bytes sent
	 */
	BytesSent = XUartLite_SendBuffer(InstancePtr);

	return BytesSent;
}
    4638:	e9e10000 	lwi	r15, r1, 0
    463c:	ea61001c 	lwi	r19, r1, 28
    4640:	eac10020 	lwi	r22, r1, 32
    4644:	eae10024 	lwi	r23, r1, 36
	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
	Xil_AssertNonvoid(DataBufferPtr != NULL);
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    4648:	30600001 	addik	r3, r0, 1
    464c:	b0000000 	imm	0
    4650:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
    4654:	10600000 	addk	r3, r0, r0
	 * Send the buffer using the UART and return the number of bytes sent
	 */
	BytesSent = XUartLite_SendBuffer(InstancePtr);

	return BytesSent;
}
    4658:	b60f0008 	rtsd	r15, 8
    465c:	30210028 	addik	r1, r1, 40
	u32 StatusRegister;

	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
    4660:	b0000000 	imm	0
    4664:	30a0d8fc 	addik	r5, r0, -9988
    4668:	b000ffff 	imm	-1
    466c:	b9f4cbd4 	brlid	r15, -13356	// 1240 <Xil_Assert>
    4670:	30c000dd 	addik	r6, r0, 221
    4674:	30600001 	addik	r3, r0, 1
    4678:	b0000000 	imm	0
    467c:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
    4680:	b810ff50 	brid	-176		// 45d0
    4684:	10730000 	addk	r3, r19, r0
	Xil_AssertNonvoid(DataBufferPtr != NULL);
    4688:	b0000000 	imm	0
    468c:	30a0d8fc 	addik	r5, r0, -9988
    4690:	b000ffff 	imm	-1
    4694:	b9f4cbac 	brlid	r15, -13396	// 1240 <Xil_Assert>
    4698:	30c000de 	addik	r6, r0, 222
    469c:	30600001 	addik	r3, r0, 1
    46a0:	b0000000 	imm	0
    46a4:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
    46a8:	b810ff28 	brid	-216		// 45d0
    46ac:	10760000 	addk	r3, r22, r0

000046b0 <XUartLite_ReceiveBuffer>:
*
*****************************************************************************/
unsigned int XUartLite_ReceiveBuffer(XUartLite *InstancePtr)
{
	u8 StatusRegister;
	unsigned int ReceivedCount = 0;
    46b0:	10600000 	addk	r3, r0, r0
	/*
	 * Loop until there is not more data buffered by the UART or the
	 * specified number of bytes is received
	 */

	while (ReceivedCount < InstancePtr->ReceiveBuffer.RemainingBytes) {
    46b4:	e8e50038 	lwi	r7, r5, 56
    46b8:	14871803 	cmpu	r4, r7, r3
    46bc:	bea4006c 	bgeid	r4, 108		// 4728
    46c0:	e8c5001c 	lwi	r6, r5, 28
		/*
		 * Read the Status Register to determine if there is any data in
		 * the receiver/FIFO
		 */
		StatusRegister =
			XUartLite_GetStatusReg(InstancePtr->RegBaseAddress);
    46c4:	e8860008 	lwi	r4, r6, 8
    46c8:	31660008 	addik	r11, r6, 8
	while (ReceivedCount < InstancePtr->ReceiveBuffer.RemainingBytes) {
		/*
		 * Read the Status Register to determine if there is any data in
		 * the receiver/FIFO
		 */
		StatusRegister =
    46cc:	a48400ff 	andi	r4, r4, 255
		/*
		 * If there is data ready to be removed, then put the next byte
		 * received into the specified buffer and update the stats to
		 * reflect any receive errors for the byte
		 */
		if (StatusRegister & XUL_SR_RX_FIFO_VALID_DATA) {
    46d0:	a5040001 	andi	r8, r4, 1
			InstancePtr->ReceiveBuffer.NextBytePtr[ReceivedCount++]=
				XUartLite_ReadReg(InstancePtr->RegBaseAddress,
							XUL_RX_FIFO_OFFSET);

			XUartLite_UpdateStats(InstancePtr, StatusRegister);
    46d4:	a5440020 	andi	r10, r4, 32
    46d8:	91240060 	sext8	r9, r4
		/*
		 * If there is data ready to be removed, then put the next byte
		 * received into the specified buffer and update the stats to
		 * reflect any receive errors for the byte
		 */
		if (StatusRegister & XUL_SR_RX_FIFO_VALID_DATA) {
    46dc:	be080050 	beqid	r8, 80		// 472c
    46e0:	a4840040 	andi	r4, r4, 64
			InstancePtr->ReceiveBuffer.NextBytePtr[ReceivedCount++]=
				XUartLite_ReadReg(InstancePtr->RegBaseAddress,
    46e4:	e8c60000 	lwi	r6, r6, 0
		 * If there is data ready to be removed, then put the next byte
		 * received into the specified buffer and update the stats to
		 * reflect any receive errors for the byte
		 */
		if (StatusRegister & XUL_SR_RX_FIFO_VALID_DATA) {
			InstancePtr->ReceiveBuffer.NextBytePtr[ReceivedCount++]=
    46e8:	e8e50030 	lwi	r7, r5, 48
    46ec:	d0c33800 	sb	r6, r3, r7
				XUartLite_ReadReg(InstancePtr->RegBaseAddress,
							XUL_RX_FIFO_OFFSET);

			XUartLite_UpdateStats(InstancePtr, StatusRegister);
    46f0:	be0a0014 	beqid	r10, 20		// 4704
    46f4:	30630001 	addik	r3, r3, 1
    46f8:	e8c50010 	lwi	r6, r5, 16
    46fc:	30c60001 	addik	r6, r6, 1
    4700:	f8c50010 	swi	r6, r5, 16
    4704:	bc490068 	blti	r9, 104		// 476c
    4708:	bc04ffac 	beqi	r4, -84		// 46b4
    470c:	e8850018 	lwi	r4, r5, 24
	/*
	 * Loop until there is not more data buffered by the UART or the
	 * specified number of bytes is received
	 */

	while (ReceivedCount < InstancePtr->ReceiveBuffer.RemainingBytes) {
    4710:	e8e50038 	lwi	r7, r5, 56
		/*
		 * Read the Status Register to determine if there is any data in
		 * the receiver/FIFO
		 */
		StatusRegister =
			XUartLite_GetStatusReg(InstancePtr->RegBaseAddress);
    4714:	e8c5001c 	lwi	r6, r5, 28
		if (StatusRegister & XUL_SR_RX_FIFO_VALID_DATA) {
			InstancePtr->ReceiveBuffer.NextBytePtr[ReceivedCount++]=
				XUartLite_ReadReg(InstancePtr->RegBaseAddress,
							XUL_RX_FIFO_OFFSET);

			XUartLite_UpdateStats(InstancePtr, StatusRegister);
    4718:	30840001 	addik	r4, r4, 1
    471c:	f8850018 	swi	r4, r5, 24
	/*
	 * Loop until there is not more data buffered by the UART or the
	 * specified number of bytes is received
	 */

	while (ReceivedCount < InstancePtr->ReceiveBuffer.RemainingBytes) {
    4720:	14871803 	cmpu	r4, r7, r3
    4724:	bc44ffa0 	blti	r4, -96		// 46c4
    4728:	31660008 	addik	r11, r6, 8

	/*
	 * Enter a critical region by disabling all the UART interrupts to allow
	 * this call to stop a previous operation that may be interrupt driven
	 */
	StatusRegister = XUartLite_GetStatusReg(InstancePtr->RegBaseAddress);
    472c:	e94b0000 	lwi	r10, r11, 0
	XUartLite_WriteReg(InstancePtr->RegBaseAddress,
    4730:	f806000c 	swi	r0, r6, 12

	/*
	 * Update the receive buffer to reflect the number of bytes that was
	 * received
	 */
	InstancePtr->ReceiveBuffer.NextBytePtr += ReceivedCount;
    4734:	e9250030 	lwi	r9, r5, 48
	InstancePtr->ReceiveBuffer.RemainingBytes -= ReceivedCount;

	/*
	 * Increment associated counters in the statistics
	 */
	InstancePtr->Stats.CharactersReceived += ReceivedCount;
    4738:	e905000c 	lwi	r8, r5, 12
	/*
	 * Restore the interrupt enable register to it's previous value such
	 * that the critical region is exited
	 */
	StatusRegister &= XUL_CR_ENABLE_INTR;
	XUartLite_WriteReg(InstancePtr->RegBaseAddress,
    473c:	e885001c 	lwi	r4, r5, 28

	/*
	 * Update the receive buffer to reflect the number of bytes that was
	 * received
	 */
	InstancePtr->ReceiveBuffer.NextBytePtr += ReceivedCount;
    4740:	11291800 	addk	r9, r9, r3
	InstancePtr->ReceiveBuffer.RemainingBytes -= ReceivedCount;
    4744:	14e33800 	rsubk	r7, r3, r7

	/*
	 * Increment associated counters in the statistics
	 */
	InstancePtr->Stats.CharactersReceived += ReceivedCount;
    4748:	11081800 	addk	r8, r8, r3

	/*
	 * Restore the interrupt enable register to it's previous value such
	 * that the critical region is exited
	 */
	StatusRegister &= XUL_CR_ENABLE_INTR;
    474c:	a4ca0010 	andi	r6, r10, 16

	/*
	 * Update the receive buffer to reflect the number of bytes that was
	 * received
	 */
	InstancePtr->ReceiveBuffer.NextBytePtr += ReceivedCount;
    4750:	f9250030 	swi	r9, r5, 48
	InstancePtr->ReceiveBuffer.RemainingBytes -= ReceivedCount;
    4754:	f8e50038 	swi	r7, r5, 56

	/*
	 * Increment associated counters in the statistics
	 */
	InstancePtr->Stats.CharactersReceived += ReceivedCount;
    4758:	f905000c 	swi	r8, r5, 12
	/*
	 * Restore the interrupt enable register to it's previous value such
	 * that the critical region is exited
	 */
	StatusRegister &= XUL_CR_ENABLE_INTR;
	XUartLite_WriteReg(InstancePtr->RegBaseAddress,
    475c:	a4a600ff 	andi	r5, r6, 255
    4760:	f8a4000c 	swi	r5, r4, 12
				XUL_CONTROL_REG_OFFSET, StatusRegister);

	return ReceivedCount;
}
    4764:	b60f0008 	rtsd	r15, 8
    4768:	80000000 	or	r0, r0, r0
		if (StatusRegister & XUL_SR_RX_FIFO_VALID_DATA) {
			InstancePtr->ReceiveBuffer.NextBytePtr[ReceivedCount++]=
				XUartLite_ReadReg(InstancePtr->RegBaseAddress,
							XUL_RX_FIFO_OFFSET);

			XUartLite_UpdateStats(InstancePtr, StatusRegister);
    476c:	e8c50014 	lwi	r6, r5, 20
    4770:	30c60001 	addik	r6, r6, 1
    4774:	b810ff94 	brid	-108		// 4708
    4778:	f8c50014 	swi	r6, r5, 20

0000477c <XUartLite_Recv>:
*		that is already in progress.
*
*****************************************************************************/
unsigned int XUartLite_Recv(XUartLite *InstancePtr, u8 *DataBufferPtr,
				unsigned int NumBytes)
{
    477c:	3021ffd8 	addik	r1, r1, -40
    4780:	fa61001c 	swi	r19, r1, 28
    4784:	fac10020 	swi	r22, r1, 32
    4788:	f9e10000 	swi	r15, r1, 0
    478c:	fae10024 	swi	r23, r1, 36
    4790:	12650000 	addk	r19, r5, r0
	u32 StatusRegister;

	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
    4794:	be0500e4 	beqid	r5, 228		// 4878
    4798:	12c60000 	addk	r22, r6, r0
    479c:	b0000000 	imm	0
    47a0:	f800ec58 	swi	r0, r0, -5032	// ec58 <Xil_AssertStatus>
	Xil_AssertNonvoid(DataBufferPtr != NULL);
    47a4:	bc0600fc 	beqi	r6, 252		// 48a0
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    47a8:	eae50020 	lwi	r23, r5, 32
    47ac:	b0001111 	imm	4369
    47b0:	aaf71111 	xori	r23, r23, 4369
    47b4:	bc370088 	bnei	r23, 136		// 483c
	Xil_AssertNonvoid(((signed)NumBytes) >= 0);
    47b8:	bc470048 	blti	r7, 72		// 4800

	/*
	 * Enter a critical region by disabling all the UART interrupts to allow
	 * this call to stop a previous operation that may be interrupt driven
	 */
	StatusRegister = XUartLite_GetStatusReg(InstancePtr->RegBaseAddress);
    47bc:	e865001c 	lwi	r3, r5, 28
    47c0:	e8830008 	lwi	r4, r3, 8
	XUartLite_WriteReg(InstancePtr->RegBaseAddress,
    47c4:	fae3000c 	swi	r23, r3, 12
	/*
	 * Restore the interrupt enable register to it's previous value such
	 * that the critical region is exited
	 */
	StatusRegister &= XUL_CR_ENABLE_INTR;
	XUartLite_WriteReg(InstancePtr->RegBaseAddress,
    47c8:	e865001c 	lwi	r3, r5, 28

	/*
	 * Setup the specified buffer to be received by setting the instance
	 * variables so it can be received with polled or interrupt mode
	 */
	InstancePtr->ReceiveBuffer.RequestedBytes = NumBytes;
    47cc:	f8e50034 	swi	r7, r5, 52
	InstancePtr->ReceiveBuffer.RemainingBytes = NumBytes;
    47d0:	f8e50038 	swi	r7, r5, 56
	InstancePtr->ReceiveBuffer.NextBytePtr = DataBufferPtr;
    47d4:	f8d30030 	swi	r6, r19, 48

	/*
	 * Restore the interrupt enable register to it's previous value such
	 * that the critical region is exited
	 */
	StatusRegister &= XUL_CR_ENABLE_INTR;
    47d8:	a4840010 	andi	r4, r4, 16
	XUartLite_WriteReg(InstancePtr->RegBaseAddress,
    47dc:	f883000c 	swi	r4, r3, 12
	 * received
	 * This is done here to minimize the amount of time the interrupt is
	 * disabled since there is only one interrupt and the transmit could
	 * be emptying out while interrupts are blocked.
	 */
	ReceivedCount = XUartLite_ReceiveBuffer(InstancePtr);
    47e0:	b9f4fed0 	brlid	r15, -304	// 46b0 <XUartLite_ReceiveBuffer>
    47e4:	80000000 	or	r0, r0, r0

	return ReceivedCount;

}
    47e8:	e9e10000 	lwi	r15, r1, 0
    47ec:	ea61001c 	lwi	r19, r1, 28
    47f0:	eac10020 	lwi	r22, r1, 32
    47f4:	eae10024 	lwi	r23, r1, 36
    47f8:	b60f0008 	rtsd	r15, 8
    47fc:	30210028 	addik	r1, r1, 40
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
	Xil_AssertNonvoid(DataBufferPtr != NULL);
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
	Xil_AssertNonvoid(((signed)NumBytes) >= 0);
    4800:	b0000000 	imm	0
    4804:	30a0d8fc 	addik	r5, r0, -9988
    4808:	b000ffff 	imm	-1
    480c:	b9f4ca34 	brlid	r15, -13772	// 1240 <Xil_Assert>
    4810:	30c00133 	addik	r6, r0, 307
    4814:	30600001 	addik	r3, r0, 1
    4818:	b0000000 	imm	0
    481c:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
	 */
	ReceivedCount = XUartLite_ReceiveBuffer(InstancePtr);

	return ReceivedCount;

}
    4820:	e9e10000 	lwi	r15, r1, 0
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
	Xil_AssertNonvoid(DataBufferPtr != NULL);
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
	Xil_AssertNonvoid(((signed)NumBytes) >= 0);
    4824:	10770000 	addk	r3, r23, r0
	 */
	ReceivedCount = XUartLite_ReceiveBuffer(InstancePtr);

	return ReceivedCount;

}
    4828:	ea61001c 	lwi	r19, r1, 28
    482c:	eac10020 	lwi	r22, r1, 32
    4830:	eae10024 	lwi	r23, r1, 36
    4834:	b60f0008 	rtsd	r15, 8
    4838:	30210028 	addik	r1, r1, 40
	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
	Xil_AssertNonvoid(DataBufferPtr != NULL);
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    483c:	b0000000 	imm	0
    4840:	30a0d8fc 	addik	r5, r0, -9988
    4844:	b000ffff 	imm	-1
    4848:	b9f4c9f8 	brlid	r15, -13832	// 1240 <Xil_Assert>
    484c:	30c00132 	addik	r6, r0, 306
	 */
	ReceivedCount = XUartLite_ReceiveBuffer(InstancePtr);

	return ReceivedCount;

}
    4850:	e9e10000 	lwi	r15, r1, 0
    4854:	ea61001c 	lwi	r19, r1, 28
    4858:	eac10020 	lwi	r22, r1, 32
    485c:	eae10024 	lwi	r23, r1, 36
	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
	Xil_AssertNonvoid(DataBufferPtr != NULL);
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    4860:	30600001 	addik	r3, r0, 1
    4864:	b0000000 	imm	0
    4868:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
    486c:	10600000 	addk	r3, r0, r0
	 */
	ReceivedCount = XUartLite_ReceiveBuffer(InstancePtr);

	return ReceivedCount;

}
    4870:	b60f0008 	rtsd	r15, 8
    4874:	30210028 	addik	r1, r1, 40
	u32 StatusRegister;

	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
    4878:	b0000000 	imm	0
    487c:	30a0d8fc 	addik	r5, r0, -9988
    4880:	b000ffff 	imm	-1
    4884:	b9f4c9bc 	brlid	r15, -13892	// 1240 <Xil_Assert>
    4888:	30c00130 	addik	r6, r0, 304
    488c:	30600001 	addik	r3, r0, 1
    4890:	b0000000 	imm	0
    4894:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
    4898:	b810ff50 	brid	-176		// 47e8
    489c:	10730000 	addk	r3, r19, r0
	Xil_AssertNonvoid(DataBufferPtr != NULL);
    48a0:	b0000000 	imm	0
    48a4:	30a0d8fc 	addik	r5, r0, -9988
    48a8:	b000ffff 	imm	-1
    48ac:	b9f4c994 	brlid	r15, -13932	// 1240 <Xil_Assert>
    48b0:	30c00131 	addik	r6, r0, 305
    48b4:	30600001 	addik	r3, r0, 1
    48b8:	b0000000 	imm	0
    48bc:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
    48c0:	b810ff28 	brid	-216		// 47e8
    48c4:	10760000 	addk	r3, r22, r0

000048c8 <XUartLite_SelfTest>:
*
* @note		None.
*
******************************************************************************/
int XUartLite_SelfTest(XUartLite *InstancePtr)
{
    48c8:	3021ffe0 	addik	r1, r1, -32
    48cc:	fa61001c 	swi	r19, r1, 28
    48d0:	f9e10000 	swi	r15, r1, 0
	u32 StatusRegister;

	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
    48d4:	be050074 	beqid	r5, 116		// 4948
    48d8:	12650000 	addk	r19, r5, r0
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    48dc:	e8650020 	lwi	r3, r5, 32
	u32 StatusRegister;

	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
    48e0:	b0000000 	imm	0
    48e4:	f800ec58 	swi	r0, r0, -5032	// ec58 <Xil_AssertStatus>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    48e8:	b0001111 	imm	4369
    48ec:	a8631111 	xori	r3, r3, 4369
    48f0:	bc230024 	bnei	r3, 36		// 4914

	/*
	 * Read the Status register value to check if it is the correct value
	 * after a reset
	 */
	StatusRegister = XUartLite_ReadReg(InstancePtr->RegBaseAddress,
    48f4:	e865001c 	lwi	r3, r5, 28
    48f8:	ea630008 	lwi	r19, r3, 8
	u32 StatusRegister;

	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
    48fc:	30600004 	addik	r3, r0, 4
    4900:	8c731c00 	pcmpne	r3, r19, r3
	if (StatusRegister != XUL_SR_TX_FIFO_EMPTY) {
		return XST_FAILURE;
	}

	return XST_SUCCESS;
}
    4904:	e9e10000 	lwi	r15, r1, 0
    4908:	ea61001c 	lwi	r19, r1, 28
    490c:	b60f0008 	rtsd	r15, 8
    4910:	30210020 	addik	r1, r1, 32

	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    4914:	b0000000 	imm	0
    4918:	30a0d908 	addik	r5, r0, -9976
    491c:	b000ffff 	imm	-1
    4920:	b9f4c920 	brlid	r15, -14048	// 1240 <Xil_Assert>
    4924:	30c00072 	addik	r6, r0, 114
	if (StatusRegister != XUL_SR_TX_FIFO_EMPTY) {
		return XST_FAILURE;
	}

	return XST_SUCCESS;
}
    4928:	e9e10000 	lwi	r15, r1, 0
    492c:	ea61001c 	lwi	r19, r1, 28

	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    4930:	30600001 	addik	r3, r0, 1
    4934:	b0000000 	imm	0
    4938:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
    493c:	10600000 	addk	r3, r0, r0
	if (StatusRegister != XUL_SR_TX_FIFO_EMPTY) {
		return XST_FAILURE;
	}

	return XST_SUCCESS;
}
    4940:	b60f0008 	rtsd	r15, 8
    4944:	30210020 	addik	r1, r1, 32
	u32 StatusRegister;

	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
    4948:	b0000000 	imm	0
    494c:	30a0d908 	addik	r5, r0, -9976
    4950:	b000ffff 	imm	-1
    4954:	b9f4c8ec 	brlid	r15, -14100	// 1240 <Xil_Assert>
    4958:	30c00071 	addik	r6, r0, 113
    495c:	30600001 	addik	r3, r0, 1
    4960:	b0000000 	imm	0
    4964:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
    4968:	b810ff9c 	brid	-100		// 4904
    496c:	10730000 	addk	r3, r19, r0

00004970 <XUartLite_LookupConfig>:
{
	XUartLite_Config *CfgPtr = NULL;
	u32 Index;

	for (Index=0; Index < XPAR_XUARTLITE_NUM_INSTANCES; Index++) {
		if (XUartLite_ConfigTable[Index].DeviceId == DeviceId) {
    4970:	b0000000 	imm	0
    4974:	e460e4dc 	lhui	r3, r0, -6948	// e4dc <XUartLite_ConfigTable>
    4978:	88632800 	xor	r3, r3, r5
    497c:	be03003c 	beqid	r3, 60		// 49b8
    4980:	60630010 	muli	r3, r3, 16
    4984:	b0000000 	imm	0
    4988:	e460e4ec 	lhui	r3, r0, -6932
    498c:	88632800 	xor	r3, r3, r5
    4990:	be030024 	beqid	r3, 36		// 49b4
    4994:	30600001 	addik	r3, r0, 1
    4998:	b0000000 	imm	0
    499c:	e480e4fc 	lhui	r4, r0, -6916
    49a0:	88a42800 	xor	r5, r4, r5
    49a4:	be050024 	beqid	r5, 36		// 49c8
    49a8:	10600000 	addk	r3, r0, r0
			break;
		}
	}

	return CfgPtr;
}
    49ac:	b60f0008 	rtsd	r15, 8
    49b0:	80000000 	or	r0, r0, r0
	XUartLite_Config *CfgPtr = NULL;
	u32 Index;

	for (Index=0; Index < XPAR_XUARTLITE_NUM_INSTANCES; Index++) {
		if (XUartLite_ConfigTable[Index].DeviceId == DeviceId) {
			CfgPtr = &XUartLite_ConfigTable[Index];
    49b4:	60630010 	muli	r3, r3, 16
    49b8:	b0000000 	imm	0
    49bc:	3063e4dc 	addik	r3, r3, -6948
			break;
		}
	}

	return CfgPtr;
}
    49c0:	b60f0008 	rtsd	r15, 8
    49c4:	80000000 	or	r0, r0, r0
XUartLite_Config *XUartLite_LookupConfig(u16 DeviceId)
{
	XUartLite_Config *CfgPtr = NULL;
	u32 Index;

	for (Index=0; Index < XPAR_XUARTLITE_NUM_INSTANCES; Index++) {
    49c8:	b810ffec 	brid	-20		// 49b4
    49cc:	30600002 	addik	r3, r0, 2

000049d0 <XUartLite_Initialize>:
*
* @note		None.
*
*****************************************************************************/
int XUartLite_Initialize(XUartLite *InstancePtr, u16 DeviceId)
{
    49d0:	3021ffe0 	addik	r1, r1, -32
    49d4:	fa61001c 	swi	r19, r1, 28
    49d8:	f9e10000 	swi	r15, r1, 0
	XUartLite_Config *ConfigPtr;

	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
    49dc:	be050088 	beqid	r5, 136		// 4a64
    49e0:	12650000 	addk	r19, r5, r0
{
	XUartLite_Config *CfgPtr = NULL;
	u32 Index;

	for (Index=0; Index < XPAR_XUARTLITE_NUM_INSTANCES; Index++) {
		if (XUartLite_ConfigTable[Index].DeviceId == DeviceId) {
    49e4:	b0000000 	imm	0
    49e8:	e460e4dc 	lhui	r3, r0, -6948	// e4dc <XUartLite_ConfigTable>
	XUartLite_Config *ConfigPtr;

	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
    49ec:	b0000000 	imm	0
    49f0:	f800ec58 	swi	r0, r0, -5032	// ec58 <Xil_AssertStatus>
{
	XUartLite_Config *CfgPtr = NULL;
	u32 Index;

	for (Index=0; Index < XPAR_XUARTLITE_NUM_INSTANCES; Index++) {
		if (XUartLite_ConfigTable[Index].DeviceId == DeviceId) {
    49f4:	88633000 	xor	r3, r3, r6
    49f8:	be030044 	beqid	r3, 68		// 4a3c
    49fc:	60630010 	muli	r3, r3, 16
    4a00:	b0000000 	imm	0
    4a04:	e460e4ec 	lhui	r3, r0, -6932
    4a08:	88633000 	xor	r3, r3, r6
    4a0c:	be03002c 	beqid	r3, 44		// 4a38
    4a10:	30600001 	addik	r3, r0, 1
    4a14:	b0000000 	imm	0
    4a18:	e480e4fc 	lhui	r4, r0, -6916
    4a1c:	88c43000 	xor	r6, r4, r6
    4a20:	be060018 	beqid	r6, 24		// 4a38
    4a24:	30600002 	addik	r3, r0, 2
	if (ConfigPtr == (XUartLite_Config *)NULL) {
		return XST_DEVICE_NOT_FOUND;
	}
	return XUartLite_CfgInitialize(InstancePtr, ConfigPtr,
					ConfigPtr->RegBaseAddr);
}
    4a28:	e9e10000 	lwi	r15, r1, 0
    4a2c:	ea61001c 	lwi	r19, r1, 28
    4a30:	b60f0008 	rtsd	r15, 8
    4a34:	30210020 	addik	r1, r1, 32
	XUartLite_Config *CfgPtr = NULL;
	u32 Index;

	for (Index=0; Index < XPAR_XUARTLITE_NUM_INSTANCES; Index++) {
		if (XUartLite_ConfigTable[Index].DeviceId == DeviceId) {
			CfgPtr = &XUartLite_ConfigTable[Index];
    4a38:	60630010 	muli	r3, r3, 16
    4a3c:	b0000000 	imm	0
    4a40:	30c3e4dc 	addik	r6, r3, -6948
	ConfigPtr = XUartLite_LookupConfig(DeviceId);

	if (ConfigPtr == (XUartLite_Config *)NULL) {
		return XST_DEVICE_NOT_FOUND;
	}
	return XUartLite_CfgInitialize(InstancePtr, ConfigPtr,
    4a44:	10b30000 	addk	r5, r19, r0
    4a48:	b000ffff 	imm	-1
    4a4c:	b9f4f8c8 	brlid	r15, -1848	// 4314 <XUartLite_CfgInitialize>
    4a50:	e8e60004 	lwi	r7, r6, 4
					ConfigPtr->RegBaseAddr);
}
    4a54:	e9e10000 	lwi	r15, r1, 0
    4a58:	ea61001c 	lwi	r19, r1, 28
    4a5c:	b60f0008 	rtsd	r15, 8
    4a60:	30210020 	addik	r1, r1, 32
	XUartLite_Config *ConfigPtr;

	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
    4a64:	b0000000 	imm	0
    4a68:	30a0d920 	addik	r5, r0, -9952
    4a6c:	b000ffff 	imm	-1
    4a70:	b9f4c7d0 	brlid	r15, -14384	// 1240 <Xil_Assert>
    4a74:	30c0008d 	addik	r6, r0, 141
    4a78:	30600001 	addik	r3, r0, 1
    4a7c:	b0000000 	imm	0
    4a80:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
    4a84:	b810ffa4 	brid	-92		// 4a28
    4a88:	10730000 	addk	r3, r19, r0

00004a8c <XUartLite_GetStats>:
*
* @note		None.
*
*****************************************************************************/
void XUartLite_GetStats(XUartLite *InstancePtr, XUartLite_Stats *StatsPtr)
{
    4a8c:	3021ffe4 	addik	r1, r1, -28
	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
    4a90:	be050094 	beqid	r5, 148		// 4b24
    4a94:	f9e10000 	swi	r15, r1, 0
    4a98:	b0000000 	imm	0
    4a9c:	f800ec58 	swi	r0, r0, -5032	// ec58 <Xil_AssertStatus>
	Xil_AssertVoid(StatsPtr != NULL);
    4aa0:	bc0600ac 	beqi	r6, 172		// 4b4c
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    4aa4:	e8650020 	lwi	r3, r5, 32
    4aa8:	b0001111 	imm	4369
    4aac:	a8631111 	xori	r3, r3, 4369
    4ab0:	bc030030 	beqi	r3, 48		// 4ae0
    4ab4:	b0000000 	imm	0
    4ab8:	30a0d934 	addik	r5, r0, -9932
    4abc:	b000ffff 	imm	-1
    4ac0:	b9f4c780 	brlid	r15, -14464	// 1240 <Xil_Assert>
    4ac4:	30c0006a 	addik	r6, r0, 106
    4ac8:	30600001 	addik	r3, r0, 1
    4acc:	b0000000 	imm	0
    4ad0:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
	StatsPtr->ReceiveOverrunErrors =
			InstancePtr->Stats.ReceiveOverrunErrors;
	StatsPtr->ReceiveFramingErrors =
			InstancePtr->Stats.ReceiveFramingErrors;
	StatsPtr->ReceiveParityErrors = InstancePtr->Stats.ReceiveParityErrors;
}
    4ad4:	e9e10000 	lwi	r15, r1, 0
    4ad8:	b60f0008 	rtsd	r15, 8
    4adc:	3021001c 	addik	r1, r1, 28
	Xil_AssertVoid(StatsPtr != NULL);
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

	/* Copy the stats from the instance to the specified stats */

	StatsPtr->TransmitInterrupts = InstancePtr->Stats.TransmitInterrupts;
    4ae0:	e8650000 	lwi	r3, r5, 0
    4ae4:	f8660000 	swi	r3, r6, 0
	StatsPtr->ReceiveInterrupts = InstancePtr->Stats.ReceiveInterrupts;
    4ae8:	e8650004 	lwi	r3, r5, 4
    4aec:	f8660004 	swi	r3, r6, 4
	StatsPtr->CharactersTransmitted =
    4af0:	e8650008 	lwi	r3, r5, 8
    4af4:	f8660008 	swi	r3, r6, 8
			InstancePtr->Stats.CharactersTransmitted;
	StatsPtr->CharactersReceived = InstancePtr->Stats.CharactersReceived;
    4af8:	e865000c 	lwi	r3, r5, 12
    4afc:	f866000c 	swi	r3, r6, 12
	StatsPtr->ReceiveOverrunErrors =
    4b00:	e8650010 	lwi	r3, r5, 16
    4b04:	f8660010 	swi	r3, r6, 16
			InstancePtr->Stats.ReceiveOverrunErrors;
	StatsPtr->ReceiveFramingErrors =
    4b08:	e8650018 	lwi	r3, r5, 24
			InstancePtr->Stats.ReceiveFramingErrors;
	StatsPtr->ReceiveParityErrors = InstancePtr->Stats.ReceiveParityErrors;
    4b0c:	e8a50014 	lwi	r5, r5, 20
	StatsPtr->CharactersTransmitted =
			InstancePtr->Stats.CharactersTransmitted;
	StatsPtr->CharactersReceived = InstancePtr->Stats.CharactersReceived;
	StatsPtr->ReceiveOverrunErrors =
			InstancePtr->Stats.ReceiveOverrunErrors;
	StatsPtr->ReceiveFramingErrors =
    4b10:	f8660018 	swi	r3, r6, 24
			InstancePtr->Stats.ReceiveFramingErrors;
	StatsPtr->ReceiveParityErrors = InstancePtr->Stats.ReceiveParityErrors;
    4b14:	f8a60014 	swi	r5, r6, 20
}
    4b18:	e9e10000 	lwi	r15, r1, 0
    4b1c:	b60f0008 	rtsd	r15, 8
    4b20:	3021001c 	addik	r1, r1, 28
void XUartLite_GetStats(XUartLite *InstancePtr, XUartLite_Stats *StatsPtr)
{
	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
    4b24:	b0000000 	imm	0
    4b28:	30a0d934 	addik	r5, r0, -9932
    4b2c:	b000ffff 	imm	-1
    4b30:	b9f4c710 	brlid	r15, -14576	// 1240 <Xil_Assert>
    4b34:	30c00068 	addik	r6, r0, 104
    4b38:	30600001 	addik	r3, r0, 1
    4b3c:	b0000000 	imm	0
    4b40:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
    4b44:	b810ff94 	brid	-108		// 4ad8
    4b48:	e9e10000 	lwi	r15, r1, 0
	Xil_AssertVoid(StatsPtr != NULL);
    4b4c:	b0000000 	imm	0
    4b50:	30a0d934 	addik	r5, r0, -9932
    4b54:	b000ffff 	imm	-1
    4b58:	b9f4c6e8 	brlid	r15, -14616	// 1240 <Xil_Assert>
    4b5c:	30c00069 	addik	r6, r0, 105
    4b60:	30600001 	addik	r3, r0, 1
    4b64:	b0000000 	imm	0
    4b68:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
    4b6c:	b810ff6c 	brid	-148		// 4ad8
    4b70:	e9e10000 	lwi	r15, r1, 0

00004b74 <XUartLite_ClearStats>:
*
* @note		None.
*
*****************************************************************************/
void XUartLite_ClearStats(XUartLite *InstancePtr)
{
    4b74:	3021ffe4 	addik	r1, r1, -28
	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
    4b78:	be050074 	beqid	r5, 116		// 4bec
    4b7c:	f9e10000 	swi	r15, r1, 0
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    4b80:	e8650020 	lwi	r3, r5, 32
void XUartLite_ClearStats(XUartLite *InstancePtr)
{
	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
    4b84:	b0000000 	imm	0
    4b88:	f800ec58 	swi	r0, r0, -5032	// ec58 <Xil_AssertStatus>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    4b8c:	b0001111 	imm	4369
    4b90:	a8631111 	xori	r3, r3, 4369
    4b94:	bc030030 	beqi	r3, 48		// 4bc4
    4b98:	b0000000 	imm	0
    4b9c:	30a0d934 	addik	r5, r0, -9932
    4ba0:	b000ffff 	imm	-1
    4ba4:	b9f4c69c 	brlid	r15, -14692	// 1240 <Xil_Assert>
    4ba8:	30c0008c 	addik	r6, r0, 140
    4bac:	30600001 	addik	r3, r0, 1
    4bb0:	b0000000 	imm	0
    4bb4:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
	InstancePtr->Stats.CharactersReceived = 0;
	InstancePtr->Stats.ReceiveOverrunErrors = 0;
	InstancePtr->Stats.ReceiveFramingErrors = 0;
	InstancePtr->Stats.ReceiveParityErrors = 0;

}
    4bb8:	e9e10000 	lwi	r15, r1, 0
    4bbc:	b60f0008 	rtsd	r15, 8
    4bc0:	3021001c 	addik	r1, r1, 28
	 * Assert validates the input arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

	InstancePtr->Stats.TransmitInterrupts = 0;
    4bc4:	f8650000 	swi	r3, r5, 0
	InstancePtr->Stats.ReceiveInterrupts = 0;
    4bc8:	f8650004 	swi	r3, r5, 4
	InstancePtr->Stats.CharactersTransmitted = 0;
    4bcc:	f8650008 	swi	r3, r5, 8
	InstancePtr->Stats.CharactersReceived = 0;
    4bd0:	f865000c 	swi	r3, r5, 12
	InstancePtr->Stats.ReceiveOverrunErrors = 0;
    4bd4:	f8650010 	swi	r3, r5, 16
	InstancePtr->Stats.ReceiveFramingErrors = 0;
    4bd8:	f8650018 	swi	r3, r5, 24
	InstancePtr->Stats.ReceiveParityErrors = 0;
    4bdc:	f8650014 	swi	r3, r5, 20

}
    4be0:	e9e10000 	lwi	r15, r1, 0
    4be4:	b60f0008 	rtsd	r15, 8
    4be8:	3021001c 	addik	r1, r1, 28
void XUartLite_ClearStats(XUartLite *InstancePtr)
{
	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
    4bec:	b0000000 	imm	0
    4bf0:	30a0d934 	addik	r5, r0, -9932
    4bf4:	b000ffff 	imm	-1
    4bf8:	b9f4c648 	brlid	r15, -14776	// 1240 <Xil_Assert>
    4bfc:	30c0008b 	addik	r6, r0, 139
    4c00:	30600001 	addik	r3, r0, 1
    4c04:	b0000000 	imm	0
    4c08:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
    4c0c:	b810ffb0 	brid	-80		// 4bbc
    4c10:	e9e10000 	lwi	r15, r1, 0

00004c14 <XIntc_VoidInterruptHandler>:
* to be included in the driver compilation.
*
******************************************************************************/
#ifdef XPAR_INTC_SINGLE_DEVICE_ID
void XIntc_VoidInterruptHandler(void)
{
    4c14:	3021ffe4 	addik	r1, r1, -28
    4c18:	f9e10000 	swi	r15, r1, 0
	/* Use the single instance to call the main interrupt handler */
	XIntc_DeviceInterruptHandler((void *) XPAR_INTC_SINGLE_DEVICE_ID);
    4c1c:	b000ffff 	imm	-1
    4c20:	b9f4b7f4 	brlid	r15, -18444	// 414 <XIntc_DeviceInterruptHandler>
    4c24:	10a00000 	addk	r5, r0, r0
}
    4c28:	e9e10000 	lwi	r15, r1, 0
    4c2c:	b60f0008 	rtsd	r15, 8
    4c30:	3021001c 	addik	r1, r1, 28

00004c34 <XIntc_InterruptHandler>:
*
* @note		None.
*
******************************************************************************/
void XIntc_InterruptHandler(XIntc * InstancePtr)
{
    4c34:	3021ffe4 	addik	r1, r1, -28
	/* Assert that the pointer to the instance is valid
	 */
	Xil_AssertVoid(InstancePtr != NULL);
    4c38:	be05002c 	beqid	r5, 44		// 4c64
    4c3c:	f9e10000 	swi	r15, r1, 0

	/* Use the instance's device ID to call the main interrupt handler.
	 * (the casts are to avoid a compiler warning)
	 */
	XIntc_DeviceInterruptHandler((void *)
				     ((u32) (InstancePtr->CfgPtr->DeviceId)));
    4c40:	e8650010 	lwi	r3, r5, 16
******************************************************************************/
void XIntc_InterruptHandler(XIntc * InstancePtr)
{
	/* Assert that the pointer to the instance is valid
	 */
	Xil_AssertVoid(InstancePtr != NULL);
    4c44:	b0000000 	imm	0
    4c48:	f800ec58 	swi	r0, r0, -5032	// ec58 <Xil_AssertStatus>

	/* Use the instance's device ID to call the main interrupt handler.
	 * (the casts are to avoid a compiler warning)
	 */
	XIntc_DeviceInterruptHandler((void *)
    4c4c:	b000ffff 	imm	-1
    4c50:	b9f4b7c4 	brlid	r15, -18492	// 414 <XIntc_DeviceInterruptHandler>
    4c54:	e4a30000 	lhui	r5, r3, 0
				     ((u32) (InstancePtr->CfgPtr->DeviceId)));
}
    4c58:	e9e10000 	lwi	r15, r1, 0
    4c5c:	b60f0008 	rtsd	r15, 8
    4c60:	3021001c 	addik	r1, r1, 28
******************************************************************************/
void XIntc_InterruptHandler(XIntc * InstancePtr)
{
	/* Assert that the pointer to the instance is valid
	 */
	Xil_AssertVoid(InstancePtr != NULL);
    4c64:	b0000000 	imm	0
    4c68:	30a0d948 	addik	r5, r0, -9912
    4c6c:	b000ffff 	imm	-1
    4c70:	b9f4c5d0 	brlid	r15, -14896	// 1240 <Xil_Assert>
    4c74:	30c000af 	addik	r6, r0, 175
	/* Use the instance's device ID to call the main interrupt handler.
	 * (the casts are to avoid a compiler warning)
	 */
	XIntc_DeviceInterruptHandler((void *)
				     ((u32) (InstancePtr->CfgPtr->DeviceId)));
}
    4c78:	e9e10000 	lwi	r15, r1, 0
******************************************************************************/
void XIntc_InterruptHandler(XIntc * InstancePtr)
{
	/* Assert that the pointer to the instance is valid
	 */
	Xil_AssertVoid(InstancePtr != NULL);
    4c7c:	30600001 	addik	r3, r0, 1
    4c80:	b0000000 	imm	0
    4c84:	f860ec58 	swi	r3, r0, -5032	// ec58 <Xil_AssertStatus>
	/* Use the instance's device ID to call the main interrupt handler.
	 * (the casts are to avoid a compiler warning)
	 */
	XIntc_DeviceInterruptHandler((void *)
				     ((u32) (InstancePtr->CfgPtr->DeviceId)));
}
    4c88:	b60f0008 	rtsd	r15, 8
    4c8c:	3021001c 	addik	r1, r1, 28

00004c90 <microblaze_disable_dcache>:
	.globl	microblaze_disable_dcache
	.ent	microblaze_disable_dcache
	.align	2
microblaze_disable_dcache:

        addik   r1, r1, -28
    4c90:	3021ffe4 	addik	r1, r1, -28
#if XPAR_MICROBLAZE_DCACHE_USE_WRITEBACK != 0
        swi     r15, r1, 0
        brlid   r15, microblaze_flush_dcache
        nop
#endif
    	mfs	r11, rmsr
    4c94:	95608001 	mfs	r11, rmsr
	andi	r11, r11, ~128
    4c98:	a56bff7f 	andi	r11, r11, -129
	mts	rmsr, r11
    4c9c:	940bc001 	mts	rmsr, r11

#if XPAR_MICROBLAZE_DCACHE_USE_WRITEBACK != 0   
        lwi     r15, r1, 0
#endif

	rtsd	r15, 8
    4ca0:	b60f0008 	rtsd	r15, 8
	addi	r1, r1, 28
    4ca4:	2021001c 	addi	r1, r1, 28

00004ca8 <microblaze_disable_exceptions>:
.section .text
.globl	microblaze_disable_exceptions
.ent	microblaze_disable_exceptions
.align 2
microblaze_disable_exceptions:
        mfs     r4, rmsr;
    4ca8:	94808001 	mfs	r4, rmsr
        andi    r4, r4, ~(0x100);                       /* Turn OFF the EE bit */
    4cac:	a484feff 	andi	r4, r4, -257
        mts     rmsr, r4;
    4cb0:	9404c001 	mts	rmsr, r4
        rtsd    r15, 8;
    4cb4:	b60f0008 	rtsd	r15, 8
        nop;        
    4cb8:	80000000 	or	r0, r0, r0

00004cbc <microblaze_disable_icache>:
	.globl	microblaze_disable_icache
	.ent	microblaze_disable_icache
	.align	2
microblaze_disable_icache:	
	#Make space on stack for a temporary
	addi	r1, r1, -4
    4cbc:	2021fffc 	addi	r1, r1, -4
	#Read the MSR register
	mfs	r8, rmsr
    4cc0:	95008001 	mfs	r8, rmsr
	#Clear the icache enable bit
	andi	r8, r8, ~32
    4cc4:	a508ffdf 	andi	r8, r8, -33
	#Save the MSR register
	mts	rmsr, r8
    4cc8:	9408c001 	mts	rmsr, r8
	#Return
	rtsd	r15, 8
    4ccc:	b60f0008 	rtsd	r15, 8
	#Update stack in the delay slot
	addi	r1, r1, 4
    4cd0:	20210004 	addi	r1, r1, 4

00004cd4 <microblaze_disable_interrupts>:
	.globl	microblaze_disable_interrupts
	.ent	microblaze_disable_interrupts
	.align	2
microblaze_disable_interrupts:	
	#Make space on stack for a temporary
	addi	r1, r1, -4
    4cd4:	2021fffc 	addi	r1, r1, -4
	#Save register r12
	swi	r12, r1, 0
    4cd8:	f9810000 	swi	r12, r1, 0
	#Read the MSR register
	mfs	r12, rmsr
    4cdc:	95808001 	mfs	r12, rmsr
	#Clear the interrupt enable bit
	andi	r12, r12, ~2
    4ce0:	a58cfffd 	andi	r12, r12, -3
	#Save the MSR register
	mts	rmsr, r12
    4ce4:	940cc001 	mts	rmsr, r12
	#Load register r12
	lwi	r12, r1, 0
    4ce8:	e9810000 	lwi	r12, r1, 0
	#Return
	rtsd	r15, 8
    4cec:	b60f0008 	rtsd	r15, 8
	#Update stack in the delay slot
	addi	r1, r1, 4
    4cf0:	20210004 	addi	r1, r1, 4

00004cf4 <microblaze_enable_exceptions>:
.section .text
.globl	microblaze_enable_exceptions
.ent	microblaze_enable_exceptions
.align 2
microblaze_enable_exceptions:
        mfs     r4, rmsr;
    4cf4:	94808001 	mfs	r4, rmsr
        ori     r4, r4, 0x100;                  /* Turn ON the EE bit */
    4cf8:	a0840100 	ori	r4, r4, 256
        mts     rmsr, r4;
    4cfc:	9404c001 	mts	rmsr, r4
        rtsd    r15, 8;
    4d00:	b60f0008 	rtsd	r15, 8
        nop;        
    4d04:	80000000 	or	r0, r0, r0

00004d08 <microblaze_enable_interrupts>:
	.globl	microblaze_enable_interrupts
	.ent	microblaze_enable_interrupts
	.align	2
microblaze_enable_interrupts:	
	#Make space on stack for a temporary
	addi	r1, r1, -4
    4d08:	2021fffc 	addi	r1, r1, -4
	#Save register r12
	swi	r12, r1, 0
    4d0c:	f9810000 	swi	r12, r1, 0
	#Read the MSR register
	mfs	r12, rmsr
    4d10:	95808001 	mfs	r12, rmsr
	#Set the interrupt enable bit
	ori	r12, r12, 2
    4d14:	a18c0002 	ori	r12, r12, 2
	#Save the MSR register
	mts	rmsr, r12
    4d18:	940cc001 	mts	rmsr, r12
	#Load register r12
	lwi	r12, r1, 0
    4d1c:	e9810000 	lwi	r12, r1, 0
	#Return
	rtsd	r15, 8
    4d20:	b60f0008 	rtsd	r15, 8
	#Update stack in the delay slot
	addi	r1, r1, 4
    4d24:	20210004 	addi	r1, r1, 4

00004d28 <microblaze_flush_dcache>:
	.ent	microblaze_flush_dcache
	.align	2

microblaze_flush_dcache:

        andi    r5, r5, -(4 * XPAR_MICROBLAZE_DCACHE_LINE_LEN)  /* Align to cache line */
    4d28:	a4a5fff0 	andi	r5, r5, -16

    	addik	r6, r5, XPAR_MICROBLAZE_DCACHE_BYTE_SIZE        /* Compute end */
    4d2c:	30c52000 	addik	r6, r5, 8192
        andi    r6, r6, -(4 * XPAR_MICROBLAZE_DCACHE_LINE_LEN)  /* Align to cache line */
    4d30:	a4c6fff0 	andi	r6, r6, -16

00004d34 <L_start>:
    
L_start:
	wdc.flush r5, r0                                        /* Flush the Cache */
    4d34:	90050074 	wdc.flush	r5, r0
    
    	cmpu	r18, r5, r6                                     /* Are we at the end? */
    4d38:	16453003 	cmpu	r18, r5, r6
	blei	r18, L_done                                     
    4d3c:	bc72000c 	blei	r18, 12	// 4d48 <L_done>

     	brid	L_start                                         /* Branch to the beginning of the loop */
    4d40:	b810fff4 	brid	-12	// 4d34 <L_start>
	addik	r5, r5, (XPAR_MICROBLAZE_DCACHE_LINE_LEN * 4)   /* Increment the addrees by 4 (delay slot) */
    4d44:	30a50010 	addik	r5, r5, 16

00004d48 <L_done>:

L_done:	
	rtsd	r15, 8                                          /* Return */
    4d48:	b60f0008 	rtsd	r15, 8
        nop
    4d4c:	80000000 	or	r0, r0, r0

00004d50 <microblaze_invalidate_dcache>:
	mfs	r9, rmsr                                        
	andi	r10, r9, ~(MICROBLAZE_MSR_DCACHE_ENABLE | MICROBLAZE_MSR_INTR_ENABLE)
	mts	rmsr, r10
#endif
    
        andi    r5, r5, -(4 * XPAR_MICROBLAZE_DCACHE_LINE_LEN)  /* Align to cache line */
    4d50:	a4a5fff0 	andi	r5, r5, -16

    	addik	r6, r5, XPAR_MICROBLAZE_DCACHE_BYTE_SIZE        /* Compute end */
    4d54:	30c52000 	addik	r6, r5, 8192
        andi    r6, r6, -(4 * XPAR_MICROBLAZE_DCACHE_LINE_LEN)  /* Align to cache line */
    4d58:	a4c6fff0 	andi	r6, r6, -16

00004d5c <L_start>:
    
L_start:
	wdc	r5, r0                                          /* Invalidate the Cache */
    4d5c:	90050064 	wdc	r5, r0
    
    	cmpu	r18, r5, r6                                     /* Are we at the end? */
    4d60:	16453003 	cmpu	r18, r5, r6
	blei	r18, L_done                                     
    4d64:	bc72000c 	blei	r18, 12	// 4d70 <L_done>

     	brid	L_start                                         /* Branch to the beginning of the loop */
    4d68:	b810fff4 	brid	-12	// 4d5c <L_start>
	addik	r5, r5, (XPAR_MICROBLAZE_DCACHE_LINE_LEN * 4)   /* Increment the addrees by 4 (delay slot) */
    4d6c:	30a50010 	addik	r5, r5, 16

00004d70 <L_done>:

L_done:	
	rtsd	r15, 8                                          /* Return */
    4d70:	b60f0008 	rtsd	r15, 8
#ifdef MB_VERSION_LT_v720                                       /* restore MSR only for MB version < v7.20 */
	mts	rmsr, r9
#else
        nop
    4d74:	80000000 	or	r0, r0, r0

00004d78 <microblaze_invalidate_icache>:
#ifdef MB_VERSION_LT_v720                                       /* Disable Icache and interrupts before invalidating */        
	mfs	r9, rmsr
	andi	r10, r9, ~(MICROBLAZE_MSR_ICACHE_ENABLE | MICROBLAZE_MSR_INTR_ENABLE)
	mts	rmsr, r10
#endif
        andi    r5, r5, -(4 * XPAR_MICROBLAZE_ICACHE_LINE_LEN)  /* Align to cache line */
    4d78:	a4a5ffe0 	andi	r5, r5, -32

    	addik	r6, r5, XPAR_MICROBLAZE_CACHE_BYTE_SIZE         /* Compute end */
    4d7c:	30c52000 	addik	r6, r5, 8192
        andi    r6, r6, -(4 * XPAR_MICROBLAZE_ICACHE_LINE_LEN)  /* Align to cache line */
    4d80:	a4c6ffe0 	andi	r6, r6, -32

00004d84 <L_start>:
    
L_start:
	wic	r5, r0                                          /* Invalidate the Cache */
    4d84:	90050068 	wic	r5, r0
    
    	cmpu	r18, r5, r6                                     /* Are we at the end? */
    4d88:	16453003 	cmpu	r18, r5, r6
	blei	r18, L_done                                     
    4d8c:	bc72000c 	blei	r18, 12	// 4d98 <L_done>

     	brid	L_start                                         /* Branch to the beginning of the loop */
    4d90:	b810fff4 	brid	-12	// 4d84 <L_start>
	addik	r5, r5, (XPAR_MICROBLAZE_ICACHE_LINE_LEN * 4)   /* Increment the addrees by 4 (delay slot) */
    4d94:	30a50020 	addik	r5, r5, 32

00004d98 <L_done>:

L_done:	
	rtsd	r15, 8                                          /* Return */
    4d98:	b60f0008 	rtsd	r15, 8

#ifdef MB_VERSION_LT_v720                                       /* restore MSR only for MB version < v7.20 */
	mts	rmsr, r9
#else
        nop
    4d9c:	80000000 	or	r0, r0, r0

00004da0 <calloc>:
    4da0:	10650000 	addk	r3, r5, r0
    4da4:	10e60000 	addk	r7, r6, r0
    4da8:	b0000000 	imm	0
    4dac:	e8a0e3e8 	lwi	r5, r0, -7192	// e3e8 <_impure_ptr>
    4db0:	3021ffe4 	addik	r1, r1, -28
    4db4:	f9e10000 	swi	r15, r1, 0
    4db8:	b0000000 	imm	0
    4dbc:	b9f40014 	brlid	r15, 20	// 4dd0 <_calloc_r>
    4dc0:	10c30000 	addk	r6, r3, r0
    4dc4:	e9e10000 	lwi	r15, r1, 0
    4dc8:	b60f0008 	rtsd	r15, 8
    4dcc:	3021001c 	addik	r1, r1, 28

00004dd0 <_calloc_r>:
    4dd0:	3021ffe0 	addik	r1, r1, -32
    4dd4:	fa61001c 	swi	r19, r1, 28
    4dd8:	f9e10000 	swi	r15, r1, 0
    4ddc:	b0000000 	imm	0
    4de0:	b9f401b0 	brlid	r15, 432	// 4f90 <_malloc_r>
    4de4:	40c73000 	mul	r6, r7, r6
    4de8:	be030070 	beqid	r3, 112		// 4e58
    4dec:	12630000 	addk	r19, r3, r0
    4df0:	e8e3fffc 	lwi	r7, r3, -4
    4df4:	30600024 	addik	r3, r0, 36
    4df8:	a4e7fffc 	andi	r7, r7, -4
    4dfc:	30e7fffc 	addik	r7, r7, -4
    4e00:	14671803 	cmpu	r3, r7, r3
    4e04:	be430068 	bltid	r3, 104		// 4e6c
    4e08:	30800013 	addik	r4, r0, 19
    4e0c:	14872003 	cmpu	r4, r7, r4
    4e10:	bea4003c 	bgeid	r4, 60		// 4e4c
    4e14:	10730000 	addk	r3, r19, r0
    4e18:	3060001b 	addik	r3, r0, 27
    4e1c:	f8130000 	swi	r0, r19, 0
    4e20:	14671803 	cmpu	r3, r7, r3
    4e24:	bea3006c 	bgeid	r3, 108		// 4e90
    4e28:	f8130004 	swi	r0, r19, 4
    4e2c:	f8130008 	swi	r0, r19, 8
    4e30:	f813000c 	swi	r0, r19, 12
    4e34:	a8e70024 	xori	r7, r7, 36
    4e38:	be270014 	bneid	r7, 20		// 4e4c
    4e3c:	30730010 	addik	r3, r19, 16
    4e40:	f8f30010 	swi	r7, r19, 16
    4e44:	f8f30014 	swi	r7, r19, 20
    4e48:	30730018 	addik	r3, r19, 24
    4e4c:	f8030000 	swi	r0, r3, 0
    4e50:	f8030004 	swi	r0, r3, 4
    4e54:	f8030008 	swi	r0, r3, 8
    4e58:	10730000 	addk	r3, r19, r0
    4e5c:	e9e10000 	lwi	r15, r1, 0
    4e60:	ea61001c 	lwi	r19, r1, 28
    4e64:	b60f0008 	rtsd	r15, 8
    4e68:	30210020 	addik	r1, r1, 32
    4e6c:	10b30000 	addk	r5, r19, r0
    4e70:	b0000000 	imm	0
    4e74:	b9f41180 	brlid	r15, 4480	// 5ff4 <memset>
    4e78:	10c00000 	addk	r6, r0, r0
    4e7c:	10730000 	addk	r3, r19, r0
    4e80:	e9e10000 	lwi	r15, r1, 0
    4e84:	ea61001c 	lwi	r19, r1, 28
    4e88:	b60f0008 	rtsd	r15, 8
    4e8c:	30210020 	addik	r1, r1, 32
    4e90:	b810ffbc 	brid	-68		// 4e4c
    4e94:	30730008 	addik	r3, r19, 8

00004e98 <localtime>:
    4e98:	3021ffdc 	addik	r1, r1, -36
    4e9c:	fac10020 	swi	r22, r1, 32
    4ea0:	b0000000 	imm	0
    4ea4:	eac0e3e8 	lwi	r22, r0, -7192	// e3e8 <_impure_ptr>
    4ea8:	fa61001c 	swi	r19, r1, 28
    4eac:	f9e10000 	swi	r15, r1, 0
    4eb0:	e8d6003c 	lwi	r6, r22, 60
    4eb4:	be060028 	beqid	r6, 40		// 4edc
    4eb8:	12650000 	addk	r19, r5, r0
    4ebc:	b0000000 	imm	0
    4ec0:	b9f40058 	brlid	r15, 88	// 4f18 <localtime_r>
    4ec4:	10b30000 	addk	r5, r19, r0
    4ec8:	e9e10000 	lwi	r15, r1, 0
    4ecc:	ea61001c 	lwi	r19, r1, 28
    4ed0:	eac10020 	lwi	r22, r1, 32
    4ed4:	b60f0008 	rtsd	r15, 8
    4ed8:	30210024 	addik	r1, r1, 36
    4edc:	b0000000 	imm	0
    4ee0:	b9f40058 	brlid	r15, 88	// 4f38 <malloc>
    4ee4:	30a00024 	addik	r5, r0, 36
    4ee8:	f876003c 	swi	r3, r22, 60
    4eec:	b0000000 	imm	0
    4ef0:	e860e3e8 	lwi	r3, r0, -7192	// e3e8 <_impure_ptr>
    4ef4:	10b30000 	addk	r5, r19, r0
    4ef8:	b0000000 	imm	0
    4efc:	b9f4001c 	brlid	r15, 28	// 4f18 <localtime_r>
    4f00:	e8c3003c 	lwi	r6, r3, 60
    4f04:	e9e10000 	lwi	r15, r1, 0
    4f08:	ea61001c 	lwi	r19, r1, 28
    4f0c:	eac10020 	lwi	r22, r1, 32
    4f10:	b60f0008 	rtsd	r15, 8
    4f14:	30210024 	addik	r1, r1, 36

00004f18 <localtime_r>:
    4f18:	3021ffe4 	addik	r1, r1, -28
    4f1c:	f9e10000 	swi	r15, r1, 0
    4f20:	b0000000 	imm	0
    4f24:	b9f41678 	brlid	r15, 5752	// 659c <_mktm_r>
    4f28:	10e00000 	addk	r7, r0, r0
    4f2c:	e9e10000 	lwi	r15, r1, 0
    4f30:	b60f0008 	rtsd	r15, 8
    4f34:	3021001c 	addik	r1, r1, 28

00004f38 <malloc>:
    4f38:	10c50000 	addk	r6, r5, r0
    4f3c:	b0000000 	imm	0
    4f40:	e8a0e3e8 	lwi	r5, r0, -7192	// e3e8 <_impure_ptr>
    4f44:	3021ffe4 	addik	r1, r1, -28
    4f48:	f9e10000 	swi	r15, r1, 0
    4f4c:	b0000000 	imm	0
    4f50:	b9f40040 	brlid	r15, 64	// 4f90 <_malloc_r>
    4f54:	80000000 	or	r0, r0, r0
    4f58:	e9e10000 	lwi	r15, r1, 0
    4f5c:	b60f0008 	rtsd	r15, 8
    4f60:	3021001c 	addik	r1, r1, 28

00004f64 <free>:
    4f64:	10c50000 	addk	r6, r5, r0
    4f68:	b0000000 	imm	0
    4f6c:	e8a0e3e8 	lwi	r5, r0, -7192	// e3e8 <_impure_ptr>
    4f70:	3021ffe4 	addik	r1, r1, -28
    4f74:	f9e10000 	swi	r15, r1, 0
    4f78:	b0000000 	imm	0
    4f7c:	b9f43e60 	brlid	r15, 15968	// 8ddc <_free_r>
    4f80:	80000000 	or	r0, r0, r0
    4f84:	e9e10000 	lwi	r15, r1, 0
    4f88:	b60f0008 	rtsd	r15, 8
    4f8c:	3021001c 	addik	r1, r1, 28

00004f90 <_malloc_r>:
    4f90:	3021ffcc 	addik	r1, r1, -52
    4f94:	fac10020 	swi	r22, r1, 32
    4f98:	30600016 	addik	r3, r0, 22
    4f9c:	32c6000b 	addik	r22, r6, 11
    4fa0:	fae10024 	swi	r23, r1, 36
    4fa4:	f9e10000 	swi	r15, r1, 0
    4fa8:	fa61001c 	swi	r19, r1, 28
    4fac:	fb010028 	swi	r24, r1, 40
    4fb0:	fb21002c 	swi	r25, r1, 44
    4fb4:	fb410030 	swi	r26, r1, 48
    4fb8:	14761803 	cmpu	r3, r22, r3
    4fbc:	bea30138 	bgeid	r3, 312		// 50f4
    4fc0:	12e50000 	addk	r23, r5, r0
    4fc4:	a6d6fff8 	andi	r22, r22, -8
    4fc8:	14c6b003 	cmpu	r6, r6, r22
    4fcc:	1060b000 	addk	r3, r0, r22
    4fd0:	90760041 	srl	r3, r22
    4fd4:	90630041 	srl	r3, r3
    4fd8:	90630041 	srl	r3, r3
    4fdc:	90630041 	srl	r3, r3
    4fe0:	90630041 	srl	r3, r3
    4fe4:	90630041 	srl	r3, r3
    4fe8:	90630041 	srl	r3, r3
    4fec:	90630041 	srl	r3, r3
    4ff0:	90630041 	srl	r3, r3
    4ff4:	90630041 	srl	r3, r3
    4ff8:	90630041 	srl	r3, r3
    4ffc:	90630041 	srl	r3, r3
    5000:	90630041 	srl	r3, r3
    5004:	90630041 	srl	r3, r3
    5008:	90630041 	srl	r3, r3
    500c:	90630041 	srl	r3, r3
    5010:	90630041 	srl	r3, r3
    5014:	90630041 	srl	r3, r3
    5018:	90630041 	srl	r3, r3
    501c:	90630041 	srl	r3, r3
    5020:	90630041 	srl	r3, r3
    5024:	90630041 	srl	r3, r3
    5028:	90630041 	srl	r3, r3
    502c:	90630041 	srl	r3, r3
    5030:	90630041 	srl	r3, r3
    5034:	90630041 	srl	r3, r3
    5038:	90630041 	srl	r3, r3
    503c:	90630041 	srl	r3, r3
    5040:	90630041 	srl	r3, r3
    5044:	90630041 	srl	r3, r3
    5048:	90630041 	srl	r3, r3
    504c:	bc4600b8 	blti	r6, 184		// 5104
    5050:	be2300b8 	bneid	r3, 184		// 5108
    5054:	3060000c 	addik	r3, r0, 12
    5058:	b0000000 	imm	0
    505c:	b9f41b28 	brlid	r15, 6952	// 6b84 <__malloc_lock>
    5060:	10b70000 	addk	r5, r23, r0
    5064:	306001f7 	addik	r3, r0, 503
    5068:	14761803 	cmpu	r3, r22, r3
    506c:	bc4300a8 	blti	r3, 168		// 5114
    5070:	b0000000 	imm	0
    5074:	3076e518 	addik	r3, r22, -6888
    5078:	ea63000c 	lwi	r19, r3, 12
    507c:	10c0b000 	addk	r6, r0, r22
    5080:	90d60041 	srl	r6, r22
    5084:	90c60041 	srl	r6, r6
    5088:	90c60041 	srl	r6, r6
    508c:	88731800 	xor	r3, r19, r3
    5090:	be0305d0 	beqid	r3, 1488		// 5660
    5094:	30730008 	addik	r3, r19, 8
    5098:	e8730004 	lwi	r3, r19, 4
    509c:	e893000c 	lwi	r4, r19, 12
    50a0:	e8f30008 	lwi	r7, r19, 8
    50a4:	a463fffc 	andi	r3, r3, -4
    50a8:	10731800 	addk	r3, r19, r3
    50ac:	e8c30004 	lwi	r6, r3, 4
    50b0:	f887000c 	swi	r4, r7, 12
    50b4:	10b70000 	addk	r5, r23, r0
    50b8:	a0c60001 	ori	r6, r6, 1
    50bc:	f8e40008 	swi	r7, r4, 8
    50c0:	b0000000 	imm	0
    50c4:	b9f41ac8 	brlid	r15, 6856	// 6b8c <__malloc_unlock>
    50c8:	f8c30004 	swi	r6, r3, 4
    50cc:	30730008 	addik	r3, r19, 8
    50d0:	e9e10000 	lwi	r15, r1, 0
    50d4:	ea61001c 	lwi	r19, r1, 28
    50d8:	eac10020 	lwi	r22, r1, 32
    50dc:	eae10024 	lwi	r23, r1, 36
    50e0:	eb010028 	lwi	r24, r1, 40
    50e4:	eb21002c 	lwi	r25, r1, 44
    50e8:	eb410030 	lwi	r26, r1, 48
    50ec:	b60f0008 	rtsd	r15, 8
    50f0:	30210034 	addik	r1, r1, 52
    50f4:	32c00010 	addik	r22, r0, 16	// 10 <_vector_interrupt>
    50f8:	14c6b003 	cmpu	r6, r6, r22
    50fc:	bea6ff54 	bgeid	r6, -172		// 5050
    5100:	10600000 	addk	r3, r0, r0
    5104:	3060000c 	addik	r3, r0, 12
    5108:	f8770000 	swi	r3, r23, 0
    510c:	b810ffc4 	brid	-60		// 50d0
    5110:	10600000 	addk	r3, r0, r0
    5114:	1100b000 	addk	r8, r0, r22
    5118:	91160041 	srl	r8, r22
    511c:	91080041 	srl	r8, r8
    5120:	91080041 	srl	r8, r8
    5124:	91080041 	srl	r8, r8
    5128:	91080041 	srl	r8, r8
    512c:	91080041 	srl	r8, r8
    5130:	91080041 	srl	r8, r8
    5134:	91080041 	srl	r8, r8
    5138:	91080041 	srl	r8, r8
    513c:	be08026c 	beqid	r8, 620		// 53a8
    5140:	30600004 	addik	r3, r0, 4
    5144:	14681803 	cmpu	r3, r8, r3
    5148:	be430384 	bltid	r3, 900		// 54cc
    514c:	30600014 	addik	r3, r0, 20
    5150:	1100b000 	addk	r8, r0, r22
    5154:	91160041 	srl	r8, r22
    5158:	91080041 	srl	r8, r8
    515c:	91080041 	srl	r8, r8
    5160:	91080041 	srl	r8, r8
    5164:	91080041 	srl	r8, r8
    5168:	91080041 	srl	r8, r8
    516c:	31080038 	addik	r8, r8, 56
    5170:	60e80008 	muli	r7, r8, 8
    5174:	b0000000 	imm	0
    5178:	30e7e518 	addik	r7, r7, -6888
    517c:	ea67000c 	lwi	r19, r7, 12
    5180:	88679800 	xor	r3, r7, r19
    5184:	be03004c 	beqid	r3, 76		// 51d0
    5188:	30a0000f 	addik	r5, r0, 15
    518c:	e8730004 	lwi	r3, r19, 4
    5190:	a463fffc 	andi	r3, r3, -4
    5194:	14961800 	rsubk	r4, r22, r3
    5198:	14c42801 	cmp	r6, r4, r5
    519c:	bc460030 	blti	r6, 48		// 51cc
    51a0:	bea40220 	bgeid	r4, 544		// 53c0
    51a4:	10731800 	addk	r3, r19, r3
    51a8:	ea73000c 	lwi	r19, r19, 12
    51ac:	88679800 	xor	r3, r7, r19
    51b0:	be030024 	beqid	r3, 36		// 51d4
    51b4:	30c80001 	addik	r6, r8, 1
    51b8:	e8730004 	lwi	r3, r19, 4
    51bc:	a463fffc 	andi	r3, r3, -4
    51c0:	14961800 	rsubk	r4, r22, r3
    51c4:	14c42801 	cmp	r6, r4, r5
    51c8:	bca6ffd8 	bgei	r6, -40		// 51a0
    51cc:	3108ffff 	addik	r8, r8, -1
    51d0:	30c80001 	addik	r6, r8, 1
    51d4:	b0000000 	imm	0
    51d8:	30e0e528 	addik	r7, r0, -6872
    51dc:	b0000000 	imm	0
    51e0:	ea60e528 	lwi	r19, r0, -6872
    51e4:	3087fff8 	addik	r4, r7, -8
    51e8:	88732000 	xor	r3, r19, r4
    51ec:	be030414 	beqid	r3, 1044		// 5600
    51f0:	30a0000f 	addik	r5, r0, 15
    51f4:	e8730004 	lwi	r3, r19, 4
    51f8:	a463fffc 	andi	r3, r3, -4
    51fc:	15161800 	rsubk	r8, r22, r3
    5200:	14a82801 	cmp	r5, r8, r5
    5204:	bc4503bc 	blti	r5, 956		// 55c0
    5208:	f8870004 	swi	r4, r7, 4
    520c:	b0000000 	imm	0
    5210:	f880e528 	swi	r4, r0, -6872
    5214:	bea801dc 	bgeid	r8, 476		// 53f0
    5218:	308001ff 	addik	r4, r0, 511
    521c:	14832003 	cmpu	r4, r3, r4
    5220:	be440304 	bltid	r4, 772		// 5524
    5224:	30a00004 	addik	r5, r0, 4
    5228:	10a01800 	addk	r5, r0, r3
    522c:	90a30041 	srl	r5, r3
    5230:	90a50041 	srl	r5, r5
    5234:	90a50041 	srl	r5, r5
    5238:	31200001 	addik	r9, r0, 1
    523c:	60650008 	muli	r3, r5, 8
    5240:	b0000000 	imm	0
    5244:	3063e518 	addik	r3, r3, -6888
    5248:	11002800 	addk	r8, r0, r5
    524c:	91050001 	sra	r8, r5
    5250:	91080001 	sra	r8, r8
    5254:	a648001f 	andi	r18, r8, 31
    5258:	10a04800 	addk	r5, r0, r9
    525c:	be120014 	beqid	r18, 20		// 5270
    5260:	10a50000 	addk	r5, r5, r0
    5264:	3252ffff 	addik	r18, r18, -1
    5268:	be32fffc 	bneid	r18, -4		// 5264
    526c:	10a52800 	addk	r5, r5, r5
    5270:	b0000000 	imm	0
    5274:	e920e51c 	lwi	r9, r0, -6884
    5278:	e8830008 	lwi	r4, r3, 8
    527c:	f873000c 	swi	r3, r19, 12
    5280:	81254800 	or	r9, r5, r9
    5284:	f8930008 	swi	r4, r19, 8
    5288:	f927fff4 	swi	r9, r7, -12
    528c:	fa630008 	swi	r19, r3, 8
    5290:	fa64000c 	swi	r19, r4, 12
    5294:	10603000 	addk	r3, r0, r6
    5298:	90660001 	sra	r3, r6
    529c:	90630001 	sra	r3, r3
    52a0:	30a00001 	addik	r5, r0, 1
    52a4:	a643001f 	andi	r18, r3, 31
    52a8:	10802800 	addk	r4, r0, r5
    52ac:	be120014 	beqid	r18, 20		// 52c0
    52b0:	10840000 	addk	r4, r4, r0
    52b4:	3252ffff 	addik	r18, r18, -1
    52b8:	be32fffc 	bneid	r18, -4		// 52b4
    52bc:	10842000 	addk	r4, r4, r4
    52c0:	14644803 	cmpu	r3, r4, r9
    52c4:	be430150 	bltid	r3, 336		// 5414
    52c8:	84692000 	and	r3, r9, r4
    52cc:	be230030 	bneid	r3, 48		// 52fc
    52d0:	3140000f 	addik	r10, r0, 15
    52d4:	10842000 	addk	r4, r4, r4
    52d8:	a4c6fffc 	andi	r6, r6, -4
    52dc:	84692000 	and	r3, r9, r4
    52e0:	be23001c 	bneid	r3, 28		// 52fc
    52e4:	30c60004 	addik	r6, r6, 4
    52e8:	10842000 	addk	r4, r4, r4
    52ec:	84644800 	and	r3, r4, r9
    52f0:	be03fff8 	beqid	r3, -8		// 52e8
    52f4:	30c60004 	addik	r6, r6, 4
    52f8:	3140000f 	addik	r10, r0, 15
    52fc:	61860008 	muli	r12, r6, 8
    5300:	b0000000 	imm	0
    5304:	318ce518 	addik	r12, r12, -6888
    5308:	10ec0000 	addk	r7, r12, r0
    530c:	11660000 	addk	r11, r6, r0
    5310:	ea67000c 	lwi	r19, r7, 12
    5314:	88679800 	xor	r3, r7, r19
    5318:	bc230020 	bnei	r3, 32		// 5338
    531c:	b81002f4 	brid	756		// 5610
    5320:	316b0001 	addik	r11, r11, 1
    5324:	bea30354 	bgeid	r3, 852		// 5678
    5328:	10732800 	addk	r3, r19, r5
    532c:	ea73000c 	lwi	r19, r19, 12
    5330:	88679800 	xor	r3, r7, r19
    5334:	bc0302d8 	beqi	r3, 728		// 560c
    5338:	e8b30004 	lwi	r5, r19, 4
    533c:	a4a5fffc 	andi	r5, r5, -4
    5340:	14762800 	rsubk	r3, r22, r5
    5344:	15035001 	cmp	r8, r3, r10
    5348:	bca8ffdc 	bgei	r8, -36		// 5324
    534c:	e8b3000c 	lwi	r5, r19, 12
    5350:	e8d30008 	lwi	r6, r19, 8
    5354:	1093b000 	addk	r4, r19, r22
    5358:	a2d60001 	ori	r22, r22, 1
    535c:	f8a6000c 	swi	r5, r6, 12
    5360:	f8c50008 	swi	r6, r5, 8
    5364:	b0000000 	imm	0
    5368:	30a0e520 	addik	r5, r0, -6880
    536c:	b0000000 	imm	0
    5370:	f880e52c 	swi	r4, r0, -6868
    5374:	b0000000 	imm	0
    5378:	f880e528 	swi	r4, r0, -6872
    537c:	f8a4000c 	swi	r5, r4, 12
    5380:	f8a40008 	swi	r5, r4, 8
    5384:	10b70000 	addk	r5, r23, r0
    5388:	a0c30001 	ori	r6, r3, 1
    538c:	fad30004 	swi	r22, r19, 4
    5390:	d8632000 	sw	r3, r3, r4
    5394:	b0000000 	imm	0
    5398:	b9f417f4 	brlid	r15, 6132	// 6b8c <__malloc_unlock>
    539c:	f8c40004 	swi	r6, r4, 4
    53a0:	b810fd30 	brid	-720		// 50d0
    53a4:	30730008 	addik	r3, r19, 8
    53a8:	1100b000 	addk	r8, r0, r22
    53ac:	91160041 	srl	r8, r22
    53b0:	91080041 	srl	r8, r8
    53b4:	91080041 	srl	r8, r8
    53b8:	b810fdbc 	brid	-580		// 5174
    53bc:	60e80008 	muli	r7, r8, 8
    53c0:	e893000c 	lwi	r4, r19, 12
    53c4:	e8f30008 	lwi	r7, r19, 8
    53c8:	e8c30004 	lwi	r6, r3, 4
    53cc:	10b70000 	addk	r5, r23, r0
    53d0:	f887000c 	swi	r4, r7, 12
    53d4:	a0c60001 	ori	r6, r6, 1
    53d8:	f8e40008 	swi	r7, r4, 8
    53dc:	b0000000 	imm	0
    53e0:	b9f417ac 	brlid	r15, 6060	// 6b8c <__malloc_unlock>
    53e4:	f8c30004 	swi	r6, r3, 4
    53e8:	b810fce8 	brid	-792		// 50d0
    53ec:	30730008 	addik	r3, r19, 8
    53f0:	10731800 	addk	r3, r19, r3
    53f4:	e8830004 	lwi	r4, r3, 4
    53f8:	10b70000 	addk	r5, r23, r0
    53fc:	a0840001 	ori	r4, r4, 1
    5400:	b0000000 	imm	0
    5404:	b9f41788 	brlid	r15, 6024	// 6b8c <__malloc_unlock>
    5408:	f8830004 	swi	r4, r3, 4
    540c:	b810fcc4 	brid	-828		// 50d0
    5410:	30730008 	addik	r3, r19, 8
    5414:	b0000000 	imm	0
    5418:	ea60e520 	lwi	r19, r0, -6880
    541c:	3080000f 	addik	r4, r0, 15
    5420:	eb330004 	lwi	r25, r19, 4
    5424:	a739fffc 	andi	r25, r25, -4
    5428:	1476c800 	rsubk	r3, r22, r25
    542c:	14832001 	cmp	r4, r3, r4
    5430:	be440460 	bltid	r4, 1120		// 5890
    5434:	1496c803 	cmpu	r4, r22, r25
    5438:	b0000000 	imm	0
    543c:	e860e510 	lwi	r3, r0, -6896	// e510 <__malloc_sbrk_base>
    5440:	b0000000 	imm	0
    5444:	eb40eb1c 	lwi	r26, r0, -5348	// eb1c <__malloc_top_pad>
    5448:	a863ffff 	xori	r3, r3, -1
    544c:	be030290 	beqid	r3, 656		// 56dc
    5450:	1356d000 	addk	r26, r22, r26
    5454:	335a008f 	addik	r26, r26, 143
    5458:	a75aff80 	andi	r26, r26, -128
    545c:	10b70000 	addk	r5, r23, r0
    5460:	b0000000 	imm	0
    5464:	b9f41e58 	brlid	r15, 7768	// 72bc <_sbrk_r>
    5468:	10da0000 	addk	r6, r26, r0
    546c:	13030000 	addk	r24, r3, r0
    5470:	a863ffff 	xori	r3, r3, -1
    5474:	be030020 	beqid	r3, 32		// 5494
    5478:	1093c800 	addk	r4, r19, r25
    547c:	1464c003 	cmpu	r3, r4, r24
    5480:	bca3027c 	bgei	r3, 636		// 56fc
    5484:	b0000000 	imm	0
    5488:	3060e518 	addik	r3, r0, -6888	// e518 <__malloc_av_>
    548c:	88731800 	xor	r3, r19, r3
    5490:	bc03026c 	beqi	r3, 620		// 56fc
    5494:	b0000000 	imm	0
    5498:	ea60e520 	lwi	r19, r0, -6880
    549c:	e8930004 	lwi	r4, r19, 4
    54a0:	a484fffc 	andi	r4, r4, -4
    54a4:	14762000 	rsubk	r3, r22, r4
    54a8:	30a0000f 	addik	r5, r0, 15
    54ac:	14a32801 	cmp	r5, r3, r5
    54b0:	be45045c 	bltid	r5, 1116		// 590c
    54b4:	14962003 	cmpu	r4, r22, r4
    54b8:	b0000000 	imm	0
    54bc:	b9f416d0 	brlid	r15, 5840	// 6b8c <__malloc_unlock>
    54c0:	10b70000 	addk	r5, r23, r0
    54c4:	b810fc0c 	brid	-1012		// 50d0
    54c8:	10600000 	addk	r3, r0, r0
    54cc:	14681803 	cmpu	r3, r8, r3
    54d0:	bea301d8 	bgeid	r3, 472		// 56a8
    54d4:	30600054 	addik	r3, r0, 84
    54d8:	14681803 	cmpu	r3, r8, r3
    54dc:	be43035c 	bltid	r3, 860		// 5838
    54e0:	30600154 	addik	r3, r0, 340
    54e4:	1100b000 	addk	r8, r0, r22
    54e8:	91160041 	srl	r8, r22
    54ec:	91080041 	srl	r8, r8
    54f0:	91080041 	srl	r8, r8
    54f4:	91080041 	srl	r8, r8
    54f8:	91080041 	srl	r8, r8
    54fc:	91080041 	srl	r8, r8
    5500:	91080041 	srl	r8, r8
    5504:	91080041 	srl	r8, r8
    5508:	91080041 	srl	r8, r8
    550c:	91080041 	srl	r8, r8
    5510:	91080041 	srl	r8, r8
    5514:	91080041 	srl	r8, r8
    5518:	3108006e 	addik	r8, r8, 110
    551c:	b810fc58 	brid	-936		// 5174
    5520:	60e80008 	muli	r7, r8, 8
    5524:	10801800 	addk	r4, r0, r3
    5528:	90830041 	srl	r4, r3
    552c:	90840041 	srl	r4, r4
    5530:	90840041 	srl	r4, r4
    5534:	90840041 	srl	r4, r4
    5538:	90840041 	srl	r4, r4
    553c:	90840041 	srl	r4, r4
    5540:	90840041 	srl	r4, r4
    5544:	90840041 	srl	r4, r4
    5548:	90840041 	srl	r4, r4
    554c:	14a42803 	cmpu	r5, r4, r5
    5550:	bca50164 	bgei	r5, 356		// 56b4
    5554:	30a00014 	addik	r5, r0, 20
    5558:	14a42803 	cmpu	r5, r4, r5
    555c:	be450418 	bltid	r5, 1048		// 5974
    5560:	30a00054 	addik	r5, r0, 84
    5564:	30a4005b 	addik	r5, r4, 91
    5568:	60e50008 	muli	r7, r5, 8
    556c:	b0000000 	imm	0
    5570:	30e7e518 	addik	r7, r7, -6888
    5574:	e8870008 	lwi	r4, r7, 8
    5578:	89043800 	xor	r8, r4, r7
    557c:	bc280014 	bnei	r8, 20		// 5590
    5580:	b8000344 	bri	836		// 58c4
    5584:	e8840008 	lwi	r4, r4, 8
    5588:	88a72000 	xor	r5, r7, r4
    558c:	bc050014 	beqi	r5, 20		// 55a0
    5590:	e8a40004 	lwi	r5, r4, 4
    5594:	a4a5fffc 	andi	r5, r5, -4
    5598:	14a51803 	cmpu	r5, r5, r3
    559c:	bc45ffe8 	blti	r5, -24		// 5584
    55a0:	e864000c 	lwi	r3, r4, 12
    55a4:	b0000000 	imm	0
    55a8:	e920e51c 	lwi	r9, r0, -6884
    55ac:	f873000c 	swi	r3, r19, 12
    55b0:	f8930008 	swi	r4, r19, 8
    55b4:	fa630008 	swi	r19, r3, 8
    55b8:	b810fcdc 	brid	-804		// 5294
    55bc:	fa64000c 	swi	r19, r4, 12
    55c0:	1073b000 	addk	r3, r19, r22
    55c4:	10b70000 	addk	r5, r23, r0
    55c8:	a2d60001 	ori	r22, r22, 1
    55cc:	f8670004 	swi	r3, r7, 4
    55d0:	b0000000 	imm	0
    55d4:	f860e528 	swi	r3, r0, -6872
    55d8:	fad30004 	swi	r22, r19, 4
    55dc:	a0c80001 	ori	r6, r8, 1
    55e0:	f883000c 	swi	r4, r3, 12
    55e4:	f8830008 	swi	r4, r3, 8
    55e8:	f8c30004 	swi	r6, r3, 4
    55ec:	b0000000 	imm	0
    55f0:	b9f4159c 	brlid	r15, 5532	// 6b8c <__malloc_unlock>
    55f4:	d9081800 	sw	r8, r8, r3
    55f8:	b810fad8 	brid	-1320		// 50d0
    55fc:	30730008 	addik	r3, r19, 8
    5600:	b0000000 	imm	0
    5604:	e920e51c 	lwi	r9, r0, -6884
    5608:	b800fc8c 	bri	-884		// 5294
    560c:	316b0001 	addik	r11, r11, 1
    5610:	a46b0003 	andi	r3, r11, 3
    5614:	be23fcfc 	bneid	r3, -772		// 5310
    5618:	30e70008 	addik	r7, r7, 8
    561c:	106c0000 	addk	r3, r12, r0
    5620:	a4e60003 	andi	r7, r6, 3
    5624:	be0704d0 	beqid	r7, 1232		// 5af4
    5628:	30a3fff8 	addik	r5, r3, -8
    562c:	e8630000 	lwi	r3, r3, 0
    5630:	88a32800 	xor	r5, r3, r5
    5634:	be05ffec 	beqid	r5, -20		// 5620
    5638:	30c6ffff 	addik	r6, r6, -1
    563c:	10842000 	addk	r4, r4, r4
    5640:	14644803 	cmpu	r3, r4, r9
    5644:	bc43fdd0 	blti	r3, -560		// 5414
    5648:	be04fdcc 	beqid	r4, -564		// 5414
    564c:	84692000 	and	r3, r9, r4
    5650:	be030094 	beqid	r3, 148		// 56e4
    5654:	10cb0000 	addk	r6, r11, r0
    5658:	b810fca8 	brid	-856		// 5300
    565c:	61860008 	muli	r12, r6, 8
    5660:	ea730014 	lwi	r19, r19, 20
    5664:	88639800 	xor	r3, r3, r19
    5668:	be03fb6c 	beqid	r3, -1172		// 51d4
    566c:	30c60002 	addik	r6, r6, 2
    5670:	b810fa2c 	brid	-1492		// 509c
    5674:	e8730004 	lwi	r3, r19, 4
    5678:	e8e30004 	lwi	r7, r3, 4
    567c:	e893000c 	lwi	r4, r19, 12
    5680:	e8d30008 	lwi	r6, r19, 8
    5684:	10b70000 	addk	r5, r23, r0
    5688:	a0e70001 	ori	r7, r7, 1
    568c:	f8e30004 	swi	r7, r3, 4
    5690:	f886000c 	swi	r4, r6, 12
    5694:	b0000000 	imm	0
    5698:	b9f414f4 	brlid	r15, 5364	// 6b8c <__malloc_unlock>
    569c:	f8c40008 	swi	r6, r4, 8
    56a0:	b810fa30 	brid	-1488		// 50d0
    56a4:	30730008 	addik	r3, r19, 8
    56a8:	3108005b 	addik	r8, r8, 91
    56ac:	b810fac8 	brid	-1336		// 5174
    56b0:	60e80008 	muli	r7, r8, 8
    56b4:	10a01800 	addk	r5, r0, r3
    56b8:	90a30041 	srl	r5, r3
    56bc:	90a50041 	srl	r5, r5
    56c0:	90a50041 	srl	r5, r5
    56c4:	90a50041 	srl	r5, r5
    56c8:	90a50041 	srl	r5, r5
    56cc:	90a50041 	srl	r5, r5
    56d0:	30a50038 	addik	r5, r5, 56
    56d4:	b810fe98 	brid	-360		// 556c
    56d8:	60e50008 	muli	r7, r5, 8
    56dc:	b810fd80 	brid	-640		// 545c
    56e0:	335a0010 	addik	r26, r26, 16
    56e4:	10842000 	addk	r4, r4, r4
    56e8:	84644800 	and	r3, r4, r9
    56ec:	be03fff8 	beqid	r3, -8		// 56e4
    56f0:	316b0004 	addik	r11, r11, 4
    56f4:	b810fc08 	brid	-1016		// 52fc
    56f8:	10cb0000 	addk	r6, r11, r0
    56fc:	b0000000 	imm	0
    5700:	e860eaec 	lwi	r3, r0, -5396	// eaec <__malloc_current_mallinfo>
    5704:	88a4c000 	xor	r5, r4, r24
    5708:	107a1800 	addk	r3, r26, r3
    570c:	b0000000 	imm	0
    5710:	f860eaec 	swi	r3, r0, -5396	// eaec <__malloc_current_mallinfo>
    5714:	be050320 	beqid	r5, 800		// 5a34
    5718:	a4a4007f 	andi	r5, r4, 127
    571c:	b0000000 	imm	0
    5720:	e8a0e510 	lwi	r5, r0, -6896	// e510 <__malloc_sbrk_base>
    5724:	a8a5ffff 	xori	r5, r5, -1
    5728:	be050358 	beqid	r5, 856		// 5a80
    572c:	1484c000 	rsubk	r4, r4, r24
    5730:	10632000 	addk	r3, r3, r4
    5734:	b0000000 	imm	0
    5738:	f860eaec 	swi	r3, r0, -5396	// eaec <__malloc_current_mallinfo>
    573c:	a4780007 	andi	r3, r24, 7
    5740:	be03001c 	beqid	r3, 28		// 575c
    5744:	30800080 	addik	r4, r0, 128	// 80 <_exit>
    5748:	30e00008 	addik	r7, r0, 8	// 8 <_vector_sw_exception>
    574c:	14833800 	rsubk	r4, r3, r7
    5750:	30a00088 	addik	r5, r0, 136
    5754:	13182000 	addk	r24, r24, r4
    5758:	14832800 	rsubk	r4, r3, r5
    575c:	1358d000 	addk	r26, r24, r26
    5760:	a75a007f 	andi	r26, r26, 127
    5764:	175a2000 	rsubk	r26, r26, r4
    5768:	10b70000 	addk	r5, r23, r0
    576c:	b0000000 	imm	0
    5770:	b9f41b4c 	brlid	r15, 6988	// 72bc <_sbrk_r>
    5774:	10da0000 	addk	r6, r26, r0
    5778:	a883ffff 	xori	r4, r3, -1
    577c:	be0402f8 	beqid	r4, 760		// 5a74
    5780:	14781800 	rsubk	r3, r24, r3
    5784:	1083d000 	addk	r4, r3, r26
    5788:	a0840001 	ori	r4, r4, 1
    578c:	b0000000 	imm	0
    5790:	e860eaec 	lwi	r3, r0, -5396	// eaec <__malloc_current_mallinfo>
    5794:	f8980004 	swi	r4, r24, 4
    5798:	b0000000 	imm	0
    579c:	3080e518 	addik	r4, r0, -6888	// e518 <__malloc_av_>
    57a0:	107a1800 	addk	r3, r26, r3
    57a4:	b0000000 	imm	0
    57a8:	fb00e520 	swi	r24, r0, -6880
    57ac:	b0000000 	imm	0
    57b0:	f860eaec 	swi	r3, r0, -5396	// eaec <__malloc_current_mallinfo>
    57b4:	88932000 	xor	r4, r19, r4
    57b8:	be040040 	beqid	r4, 64		// 57f8
    57bc:	30a0000f 	addik	r5, r0, 15
    57c0:	14992803 	cmpu	r4, r25, r5
    57c4:	bea401f8 	bgeid	r4, 504		// 59bc
    57c8:	30e00005 	addik	r7, r0, 5
    57cc:	e8d30004 	lwi	r6, r19, 4
    57d0:	3099fff4 	addik	r4, r25, -12
    57d4:	a484fff8 	andi	r4, r4, -8
    57d8:	a4c60001 	andi	r6, r6, 1
    57dc:	80c43000 	or	r6, r4, r6
    57e0:	f8d30004 	swi	r6, r19, 4
    57e4:	10d32000 	addk	r6, r19, r4
    57e8:	f8e60004 	swi	r7, r6, 4
    57ec:	14842803 	cmpu	r4, r4, r5
    57f0:	be440260 	bltid	r4, 608		// 5a50
    57f4:	f8e60008 	swi	r7, r6, 8
    57f8:	b0000000 	imm	0
    57fc:	e880eb18 	lwi	r4, r0, -5352	// eb18 <__malloc_max_sbrked_mem>
    5800:	14832003 	cmpu	r4, r3, r4
    5804:	bca4000c 	bgei	r4, 12		// 5810
    5808:	b0000000 	imm	0
    580c:	f860eb18 	swi	r3, r0, -5352	// eb18 <__malloc_max_sbrked_mem>
    5810:	b0000000 	imm	0
    5814:	e880eb14 	lwi	r4, r0, -5356	// eb14 <__malloc_max_total_mem>
    5818:	14832003 	cmpu	r4, r3, r4
    581c:	bea40010 	bgeid	r4, 16		// 582c
    5820:	12780000 	addk	r19, r24, r0
    5824:	b0000000 	imm	0
    5828:	f860eb14 	swi	r3, r0, -5356	// eb14 <__malloc_max_total_mem>
    582c:	e8930004 	lwi	r4, r19, 4
    5830:	b810fc74 	brid	-908		// 54a4
    5834:	a484fffc 	andi	r4, r4, -4
    5838:	14681803 	cmpu	r3, r8, r3
    583c:	be4300d8 	bltid	r3, 216		// 5914
    5840:	30600554 	addik	r3, r0, 1364
    5844:	1100b000 	addk	r8, r0, r22
    5848:	91160041 	srl	r8, r22
    584c:	91080041 	srl	r8, r8
    5850:	91080041 	srl	r8, r8
    5854:	91080041 	srl	r8, r8
    5858:	91080041 	srl	r8, r8
    585c:	91080041 	srl	r8, r8
    5860:	91080041 	srl	r8, r8
    5864:	91080041 	srl	r8, r8
    5868:	91080041 	srl	r8, r8
    586c:	91080041 	srl	r8, r8
    5870:	91080041 	srl	r8, r8
    5874:	91080041 	srl	r8, r8
    5878:	91080041 	srl	r8, r8
    587c:	91080041 	srl	r8, r8
    5880:	91080041 	srl	r8, r8
    5884:	31080077 	addik	r8, r8, 119
    5888:	b810f8ec 	brid	-1812		// 5174
    588c:	60e80008 	muli	r7, r8, 8
    5890:	bc44fba8 	blti	r4, -1112		// 5438
    5894:	a0960001 	ori	r4, r22, 1
    5898:	a0630001 	ori	r3, r3, 1
    589c:	f8930004 	swi	r4, r19, 4
    58a0:	12d3b000 	addk	r22, r19, r22
    58a4:	f8760004 	swi	r3, r22, 4
    58a8:	b0000000 	imm	0
    58ac:	fac0e520 	swi	r22, r0, -6880
    58b0:	b0000000 	imm	0
    58b4:	b9f412d8 	brlid	r15, 4824	// 6b8c <__malloc_unlock>
    58b8:	10b70000 	addk	r5, r23, r0
    58bc:	b810f814 	brid	-2028		// 50d0
    58c0:	30730008 	addik	r3, r19, 8
    58c4:	b0000000 	imm	0
    58c8:	e920e51c 	lwi	r9, r0, -6884
    58cc:	10e02800 	addk	r7, r0, r5
    58d0:	90e50001 	sra	r7, r5
    58d4:	90e70001 	sra	r7, r7
    58d8:	30a00001 	addik	r5, r0, 1
    58dc:	a647001f 	andi	r18, r7, 31
    58e0:	10602800 	addk	r3, r0, r5
    58e4:	be120014 	beqid	r18, 20		// 58f8
    58e8:	10630000 	addk	r3, r3, r0
    58ec:	3252ffff 	addik	r18, r18, -1
    58f0:	be32fffc 	bneid	r18, -4		// 58ec
    58f4:	10631800 	addk	r3, r3, r3
    58f8:	81234800 	or	r9, r3, r9
    58fc:	b0000000 	imm	0
    5900:	f920e51c 	swi	r9, r0, -6884
    5904:	b810fca8 	brid	-856		// 55ac
    5908:	10640000 	addk	r3, r4, r0
    590c:	bca4ff88 	bgei	r4, -120		// 5894
    5910:	b800fba8 	bri	-1112		// 54b8
    5914:	15081803 	cmpu	r8, r8, r3
    5918:	bc4800b8 	blti	r8, 184		// 59d0
    591c:	1100b000 	addk	r8, r0, r22
    5920:	91160041 	srl	r8, r22
    5924:	91080041 	srl	r8, r8
    5928:	91080041 	srl	r8, r8
    592c:	91080041 	srl	r8, r8
    5930:	91080041 	srl	r8, r8
    5934:	91080041 	srl	r8, r8
    5938:	91080041 	srl	r8, r8
    593c:	91080041 	srl	r8, r8
    5940:	91080041 	srl	r8, r8
    5944:	91080041 	srl	r8, r8
    5948:	91080041 	srl	r8, r8
    594c:	91080041 	srl	r8, r8
    5950:	91080041 	srl	r8, r8
    5954:	91080041 	srl	r8, r8
    5958:	91080041 	srl	r8, r8
    595c:	91080041 	srl	r8, r8
    5960:	91080041 	srl	r8, r8
    5964:	91080041 	srl	r8, r8
    5968:	3108007c 	addik	r8, r8, 124
    596c:	b810f808 	brid	-2040		// 5174
    5970:	60e80008 	muli	r7, r8, 8
    5974:	14a42803 	cmpu	r5, r4, r5
    5978:	bc450064 	blti	r5, 100		// 59dc
    597c:	10a01800 	addk	r5, r0, r3
    5980:	90a30041 	srl	r5, r3
    5984:	90a50041 	srl	r5, r5
    5988:	90a50041 	srl	r5, r5
    598c:	90a50041 	srl	r5, r5
    5990:	90a50041 	srl	r5, r5
    5994:	90a50041 	srl	r5, r5
    5998:	90a50041 	srl	r5, r5
    599c:	90a50041 	srl	r5, r5
    59a0:	90a50041 	srl	r5, r5
    59a4:	90a50041 	srl	r5, r5
    59a8:	90a50041 	srl	r5, r5
    59ac:	90a50041 	srl	r5, r5
    59b0:	30a5006e 	addik	r5, r5, 110
    59b4:	b810fbb8 	brid	-1096		// 556c
    59b8:	60e50008 	muli	r7, r5, 8
    59bc:	30e00001 	addik	r7, r0, 1
    59c0:	f8f80004 	swi	r7, r24, 4
    59c4:	12780000 	addk	r19, r24, r0
    59c8:	b810fadc 	brid	-1316		// 54a4
    59cc:	10800000 	addk	r4, r0, r0
    59d0:	30e003f0 	addik	r7, r0, 1008
    59d4:	b810f7a0 	brid	-2144		// 5174
    59d8:	3100007e 	addik	r8, r0, 126
    59dc:	30a00154 	addik	r5, r0, 340
    59e0:	14a42803 	cmpu	r5, r4, r5
    59e4:	bc4500ac 	blti	r5, 172		// 5a90
    59e8:	10a01800 	addk	r5, r0, r3
    59ec:	90a30041 	srl	r5, r3
    59f0:	90a50041 	srl	r5, r5
    59f4:	90a50041 	srl	r5, r5
    59f8:	90a50041 	srl	r5, r5
    59fc:	90a50041 	srl	r5, r5
    5a00:	90a50041 	srl	r5, r5
    5a04:	90a50041 	srl	r5, r5
    5a08:	90a50041 	srl	r5, r5
    5a0c:	90a50041 	srl	r5, r5
    5a10:	90a50041 	srl	r5, r5
    5a14:	90a50041 	srl	r5, r5
    5a18:	90a50041 	srl	r5, r5
    5a1c:	90a50041 	srl	r5, r5
    5a20:	90a50041 	srl	r5, r5
    5a24:	90a50041 	srl	r5, r5
    5a28:	30a50077 	addik	r5, r5, 119
    5a2c:	b810fb40 	brid	-1216		// 556c
    5a30:	60e50008 	muli	r7, r5, 8
    5a34:	bc25fce8 	bnei	r5, -792		// 571c
    5a38:	b0000000 	imm	0
    5a3c:	eb00e520 	lwi	r24, r0, -6880
    5a40:	109ac800 	addk	r4, r26, r25
    5a44:	a0840001 	ori	r4, r4, 1
    5a48:	b810fdb0 	brid	-592		// 57f8
    5a4c:	f8980004 	swi	r4, r24, 4
    5a50:	10b70000 	addk	r5, r23, r0
    5a54:	b0000000 	imm	0
    5a58:	b9f43384 	brlid	r15, 13188	// 8ddc <_free_r>
    5a5c:	30d30008 	addik	r6, r19, 8
    5a60:	b0000000 	imm	0
    5a64:	e860eaec 	lwi	r3, r0, -5396	// eaec <__malloc_current_mallinfo>
    5a68:	b0000000 	imm	0
    5a6c:	eb00e520 	lwi	r24, r0, -6880
    5a70:	b800fd88 	bri	-632		// 57f8
    5a74:	13440000 	addk	r26, r4, r0
    5a78:	b810fd14 	brid	-748		// 578c
    5a7c:	30800001 	addik	r4, r0, 1
    5a80:	b0000000 	imm	0
    5a84:	fb00e510 	swi	r24, r0, -6896	// e510 <__malloc_sbrk_base>
    5a88:	b810fcb8 	brid	-840		// 5740
    5a8c:	a4780007 	andi	r3, r24, 7
    5a90:	30a00554 	addik	r5, r0, 1364
    5a94:	14842803 	cmpu	r4, r4, r5
    5a98:	bc440074 	blti	r4, 116		// 5b0c
    5a9c:	10a01800 	addk	r5, r0, r3
    5aa0:	90a30041 	srl	r5, r3
    5aa4:	90a50041 	srl	r5, r5
    5aa8:	90a50041 	srl	r5, r5
    5aac:	90a50041 	srl	r5, r5
    5ab0:	90a50041 	srl	r5, r5
    5ab4:	90a50041 	srl	r5, r5
    5ab8:	90a50041 	srl	r5, r5
    5abc:	90a50041 	srl	r5, r5
    5ac0:	90a50041 	srl	r5, r5
    5ac4:	90a50041 	srl	r5, r5
    5ac8:	90a50041 	srl	r5, r5
    5acc:	90a50041 	srl	r5, r5
    5ad0:	90a50041 	srl	r5, r5
    5ad4:	90a50041 	srl	r5, r5
    5ad8:	90a50041 	srl	r5, r5
    5adc:	90a50041 	srl	r5, r5
    5ae0:	90a50041 	srl	r5, r5
    5ae4:	90a50041 	srl	r5, r5
    5ae8:	30a5007c 	addik	r5, r5, 124
    5aec:	b810fa80 	brid	-1408		// 556c
    5af0:	60e50008 	muli	r7, r5, 8
    5af4:	a864ffff 	xori	r3, r4, -1
    5af8:	85291800 	and	r9, r9, r3
    5afc:	b0000000 	imm	0
    5b00:	f920e51c 	swi	r9, r0, -6884
    5b04:	b810fb3c 	brid	-1220		// 5640
    5b08:	10842000 	addk	r4, r4, r4
    5b0c:	30e003f0 	addik	r7, r0, 1008
    5b10:	b810fa5c 	brid	-1444		// 556c
    5b14:	30a0007e 	addik	r5, r0, 126

00005b18 <memcpy>:
    5b18:	3021fff4 	addik	r1, r1, -12
    5b1c:	3140000f 	addik	r10, r0, 15
    5b20:	fa610004 	swi	r19, r1, 4
    5b24:	fac10008 	swi	r22, r1, 8
    5b28:	14875003 	cmpu	r4, r7, r10
    5b2c:	bea401f0 	bgeid	r4, 496		// 5d1c
    5b30:	10650000 	addk	r3, r5, r0
    5b34:	80862800 	or	r4, r6, r5
    5b38:	a4840003 	andi	r4, r4, 3
    5b3c:	be240214 	bneid	r4, 532		// 5d50
    5b40:	11060000 	addk	r8, r6, r0
    5b44:	10850000 	addk	r4, r5, r0
    5b48:	11270000 	addk	r9, r7, r0
    5b4c:	e8a80000 	lwi	r5, r8, 0
    5b50:	3129fff0 	addik	r9, r9, -16
    5b54:	f8a40000 	swi	r5, r4, 0
    5b58:	e9680004 	lwi	r11, r8, 4
    5b5c:	14a95003 	cmpu	r5, r9, r10
    5b60:	f9640004 	swi	r11, r4, 4
    5b64:	e9680008 	lwi	r11, r8, 8
    5b68:	f9640008 	swi	r11, r4, 8
    5b6c:	e968000c 	lwi	r11, r8, 12
    5b70:	31080010 	addik	r8, r8, 16
    5b74:	f964000c 	swi	r11, r4, 12
    5b78:	be45ffd4 	bltid	r5, -44		// 5b4c
    5b7c:	30840010 	addik	r4, r4, 16
    5b80:	30a7fff0 	addik	r5, r7, -16
    5b84:	a4a5fff0 	andi	r5, r5, -16
    5b88:	a4e7000f 	andi	r7, r7, 15
    5b8c:	31600003 	addik	r11, r0, 3
    5b90:	30a50010 	addik	r5, r5, 16
    5b94:	15075803 	cmpu	r8, r7, r11
    5b98:	10832800 	addk	r4, r3, r5
    5b9c:	bea80048 	bgeid	r8, 72		// 5be4
    5ba0:	10c62800 	addk	r6, r6, r5
    5ba4:	11460000 	addk	r10, r6, r0
    5ba8:	11240000 	addk	r9, r4, r0
    5bac:	11070000 	addk	r8, r7, r0
    5bb0:	e8aa0000 	lwi	r5, r10, 0
    5bb4:	3108fffc 	addik	r8, r8, -4
    5bb8:	314a0004 	addik	r10, r10, 4
    5bbc:	f8a90000 	swi	r5, r9, 0
    5bc0:	14a85803 	cmpu	r5, r8, r11
    5bc4:	be45ffec 	bltid	r5, -20		// 5bb0
    5bc8:	31290004 	addik	r9, r9, 4
    5bcc:	30a7fffc 	addik	r5, r7, -4
    5bd0:	a4a5fffc 	andi	r5, r5, -4
    5bd4:	30a50004 	addik	r5, r5, 4
    5bd8:	a4e70003 	andi	r7, r7, 3
    5bdc:	10c62800 	addk	r6, r6, r5
    5be0:	10842800 	addk	r4, r4, r5
    5be4:	be07012c 	beqid	r7, 300		// 5d10
    5be8:	ea610004 	lwi	r19, r1, 4
    5bec:	12603800 	addk	r19, r0, r7
    5bf0:	92670041 	srl	r19, r7
    5bf4:	92730041 	srl	r19, r19
    5bf8:	11200000 	addk	r9, r0, r0
    5bfc:	62d30004 	muli	r22, r19, 4
    5c00:	89364c00 	pcmpeq	r9, r22, r9
    5c04:	be290124 	bneid	r9, 292		// 5d28
    5c08:	3107ffff 	addik	r8, r7, -1
    5c0c:	31400003 	addik	r10, r0, 3
    5c10:	15475003 	cmpu	r10, r7, r10
    5c14:	be4a000c 	bltid	r10, 12		// 5c20
    5c18:	30a00001 	addik	r5, r0, 1
    5c1c:	10a90000 	addk	r5, r9, r0
    5c20:	81243000 	or	r9, r4, r6
    5c24:	a5290003 	andi	r9, r9, 3
    5c28:	31460004 	addik	r10, r6, 4
    5c2c:	31640004 	addik	r11, r4, 4
    5c30:	11800000 	addk	r12, r0, r0
    5c34:	15445003 	cmpu	r10, r4, r10
    5c38:	89296400 	pcmpeq	r9, r9, r12
    5c3c:	15665803 	cmpu	r11, r6, r11
    5c40:	85254800 	and	r9, r5, r9
    5c44:	80ab5000 	or	r5, r11, r10
    5c48:	11402800 	addk	r10, r0, r5
    5c4c:	91450041 	srl	r10, r5
    5c50:	914a0041 	srl	r10, r10
    5c54:	914a0041 	srl	r10, r10
    5c58:	914a0041 	srl	r10, r10
    5c5c:	914a0041 	srl	r10, r10
    5c60:	914a0041 	srl	r10, r10
    5c64:	914a0041 	srl	r10, r10
    5c68:	914a0041 	srl	r10, r10
    5c6c:	914a0041 	srl	r10, r10
    5c70:	914a0041 	srl	r10, r10
    5c74:	914a0041 	srl	r10, r10
    5c78:	914a0041 	srl	r10, r10
    5c7c:	914a0041 	srl	r10, r10
    5c80:	914a0041 	srl	r10, r10
    5c84:	914a0041 	srl	r10, r10
    5c88:	914a0041 	srl	r10, r10
    5c8c:	914a0041 	srl	r10, r10
    5c90:	914a0041 	srl	r10, r10
    5c94:	914a0041 	srl	r10, r10
    5c98:	914a0041 	srl	r10, r10
    5c9c:	914a0041 	srl	r10, r10
    5ca0:	914a0041 	srl	r10, r10
    5ca4:	914a0041 	srl	r10, r10
    5ca8:	914a0041 	srl	r10, r10
    5cac:	914a0041 	srl	r10, r10
    5cb0:	914a0041 	srl	r10, r10
    5cb4:	914a0041 	srl	r10, r10
    5cb8:	914a0041 	srl	r10, r10
    5cbc:	914a0041 	srl	r10, r10
    5cc0:	914a0041 	srl	r10, r10
    5cc4:	914a0041 	srl	r10, r10
    5cc8:	85295000 	and	r9, r9, r10
    5ccc:	a9290001 	xori	r9, r9, 1
    5cd0:	be290058 	bneid	r9, 88		// 5d28
    5cd4:	11640000 	addk	r11, r4, r0
    5cd8:	11460000 	addk	r10, r6, r0
    5cdc:	e8aa0000 	lwi	r5, r10, 0
    5ce0:	31290001 	addik	r9, r9, 1
    5ce4:	15934803 	cmpu	r12, r19, r9
    5ce8:	f8ab0000 	swi	r5, r11, 0
    5cec:	314a0004 	addik	r10, r10, 4
    5cf0:	be4cffec 	bltid	r12, -20		// 5cdc
    5cf4:	316b0004 	addik	r11, r11, 4
    5cf8:	88f63800 	xor	r7, r22, r7
    5cfc:	1084b000 	addk	r4, r4, r22
    5d00:	10c6b000 	addk	r6, r6, r22
    5d04:	be270024 	bneid	r7, 36		// 5d28
    5d08:	15164000 	rsubk	r8, r22, r8
    5d0c:	ea610004 	lwi	r19, r1, 4
    5d10:	eac10008 	lwi	r22, r1, 8
    5d14:	b60f0008 	rtsd	r15, 8
    5d18:	3021000c 	addik	r1, r1, 12
    5d1c:	b810fec8 	brid	-312		// 5be4
    5d20:	10850000 	addk	r4, r5, r0
    5d24:	11070000 	addk	r8, r7, r0
    5d28:	e1660000 	lbui	r11, r6, 0
    5d2c:	30e8ffff 	addik	r7, r8, -1
    5d30:	30c60001 	addik	r6, r6, 1
    5d34:	f1640000 	sbi	r11, r4, 0
    5d38:	be28ffec 	bneid	r8, -20		// 5d24
    5d3c:	30840001 	addik	r4, r4, 1
    5d40:	ea610004 	lwi	r19, r1, 4
    5d44:	eac10008 	lwi	r22, r1, 8
    5d48:	b60f0008 	rtsd	r15, 8
    5d4c:	3021000c 	addik	r1, r1, 12
    5d50:	b810fe9c 	brid	-356		// 5bec
    5d54:	10850000 	addk	r4, r5, r0

00005d58 <memmove>:
    5d58:	3021fff4 	addik	r1, r1, -12
    5d5c:	fa610004 	swi	r19, r1, 4
    5d60:	fac10008 	swi	r22, r1, 8
    5d64:	14853003 	cmpu	r4, r5, r6
    5d68:	bea40058 	bgeid	r4, 88		// 5dc0
    5d6c:	10650000 	addk	r3, r5, r0
    5d70:	10863800 	addk	r4, r6, r7
    5d74:	14a42803 	cmpu	r5, r4, r5
    5d78:	bea5004c 	bgeid	r5, 76		// 5dc4
    5d7c:	3140000f 	addik	r10, r0, 15
    5d80:	be070034 	beqid	r7, 52		// 5db4
    5d84:	ea610004 	lwi	r19, r1, 4
    5d88:	10a33800 	addk	r5, r3, r7
    5d8c:	b810000c 	brid	12		// 5d98
    5d90:	30e7ffff 	addik	r7, r7, -1
    5d94:	10e60000 	addk	r7, r6, r0
    5d98:	e0c4ffff 	lbui	r6, r4, -1
    5d9c:	3084ffff 	addik	r4, r4, -1
    5da0:	f0c5ffff 	sbi	r6, r5, -1
    5da4:	30a5ffff 	addik	r5, r5, -1
    5da8:	be27ffec 	bneid	r7, -20		// 5d94
    5dac:	30c7ffff 	addik	r6, r7, -1
    5db0:	ea610004 	lwi	r19, r1, 4
    5db4:	eac10008 	lwi	r22, r1, 8
    5db8:	b60f0008 	rtsd	r15, 8
    5dbc:	3021000c 	addik	r1, r1, 12
    5dc0:	3140000f 	addik	r10, r0, 15
    5dc4:	14875003 	cmpu	r4, r7, r10
    5dc8:	bea400b8 	bgeid	r4, 184		// 5e80
    5dcc:	10830000 	addk	r4, r3, r0
    5dd0:	80861800 	or	r4, r6, r3
    5dd4:	a4840003 	andi	r4, r4, 3
    5dd8:	be240214 	bneid	r4, 532		// 5fec
    5ddc:	11060000 	addk	r8, r6, r0
    5de0:	10830000 	addk	r4, r3, r0
    5de4:	10a70000 	addk	r5, r7, r0
    5de8:	e9280000 	lwi	r9, r8, 0
    5dec:	30a5fff0 	addik	r5, r5, -16
    5df0:	f9240000 	swi	r9, r4, 0
    5df4:	e9680004 	lwi	r11, r8, 4
    5df8:	15255003 	cmpu	r9, r5, r10
    5dfc:	f9640004 	swi	r11, r4, 4
    5e00:	e9880008 	lwi	r12, r8, 8
    5e04:	f9840008 	swi	r12, r4, 8
    5e08:	e968000c 	lwi	r11, r8, 12
    5e0c:	31080010 	addik	r8, r8, 16
    5e10:	f964000c 	swi	r11, r4, 12
    5e14:	be49ffd4 	bltid	r9, -44		// 5de8
    5e18:	30840010 	addik	r4, r4, 16
    5e1c:	30a7fff0 	addik	r5, r7, -16
    5e20:	a4a5fff0 	andi	r5, r5, -16
    5e24:	a4e7000f 	andi	r7, r7, 15
    5e28:	31600003 	addik	r11, r0, 3
    5e2c:	30a50010 	addik	r5, r5, 16
    5e30:	15075803 	cmpu	r8, r7, r11
    5e34:	10832800 	addk	r4, r3, r5
    5e38:	bea80048 	bgeid	r8, 72		// 5e80
    5e3c:	10c62800 	addk	r6, r6, r5
    5e40:	11260000 	addk	r9, r6, r0
    5e44:	11040000 	addk	r8, r4, r0
    5e48:	10a70000 	addk	r5, r7, r0
    5e4c:	e9890000 	lwi	r12, r9, 0
    5e50:	30a5fffc 	addik	r5, r5, -4
    5e54:	15455803 	cmpu	r10, r5, r11
    5e58:	f9880000 	swi	r12, r8, 0
    5e5c:	31290004 	addik	r9, r9, 4
    5e60:	be4affec 	bltid	r10, -20		// 5e4c
    5e64:	31080004 	addik	r8, r8, 4
    5e68:	30a7fffc 	addik	r5, r7, -4
    5e6c:	a4a5fffc 	andi	r5, r5, -4
    5e70:	30a50004 	addik	r5, r5, 4
    5e74:	a4e70003 	andi	r7, r7, 3
    5e78:	10c62800 	addk	r6, r6, r5
    5e7c:	10842800 	addk	r4, r4, r5
    5e80:	be07ff34 	beqid	r7, -204		// 5db4
    5e84:	ea610004 	lwi	r19, r1, 4
    5e88:	10a03800 	addk	r5, r0, r7
    5e8c:	90a70041 	srl	r5, r7
    5e90:	90a50041 	srl	r5, r5
    5e94:	11400000 	addk	r10, r0, r0
    5e98:	62650004 	muli	r19, r5, 4
    5e9c:	89535400 	pcmpeq	r10, r19, r10
    5ea0:	be2a0124 	bneid	r10, 292		// 5fc4
    5ea4:	3107ffff 	addik	r8, r7, -1
    5ea8:	31600003 	addik	r11, r0, 3
    5eac:	15675803 	cmpu	r11, r7, r11
    5eb0:	be4b000c 	bltid	r11, 12		// 5ebc
    5eb4:	31200001 	addik	r9, r0, 1
    5eb8:	112a0000 	addk	r9, r10, r0
    5ebc:	82c43000 	or	r22, r4, r6
    5ec0:	a6d60003 	andi	r22, r22, 3
    5ec4:	31460004 	addik	r10, r6, 4
    5ec8:	31640004 	addik	r11, r4, 4
    5ecc:	11800000 	addk	r12, r0, r0
    5ed0:	15445003 	cmpu	r10, r4, r10
    5ed4:	89966400 	pcmpeq	r12, r22, r12
    5ed8:	15665803 	cmpu	r11, r6, r11
    5edc:	85296000 	and	r9, r9, r12
    5ee0:	816b5000 	or	r11, r11, r10
    5ee4:	11405800 	addk	r10, r0, r11
    5ee8:	914b0041 	srl	r10, r11
    5eec:	914a0041 	srl	r10, r10
    5ef0:	914a0041 	srl	r10, r10
    5ef4:	914a0041 	srl	r10, r10
    5ef8:	914a0041 	srl	r10, r10
    5efc:	914a0041 	srl	r10, r10
    5f00:	914a0041 	srl	r10, r10
    5f04:	914a0041 	srl	r10, r10
    5f08:	914a0041 	srl	r10, r10
    5f0c:	914a0041 	srl	r10, r10
    5f10:	914a0041 	srl	r10, r10
    5f14:	914a0041 	srl	r10, r10
    5f18:	914a0041 	srl	r10, r10
    5f1c:	914a0041 	srl	r10, r10
    5f20:	914a0041 	srl	r10, r10
    5f24:	914a0041 	srl	r10, r10
    5f28:	914a0041 	srl	r10, r10
    5f2c:	914a0041 	srl	r10, r10
    5f30:	914a0041 	srl	r10, r10
    5f34:	914a0041 	srl	r10, r10
    5f38:	914a0041 	srl	r10, r10
    5f3c:	914a0041 	srl	r10, r10
    5f40:	914a0041 	srl	r10, r10
    5f44:	914a0041 	srl	r10, r10
    5f48:	914a0041 	srl	r10, r10
    5f4c:	914a0041 	srl	r10, r10
    5f50:	914a0041 	srl	r10, r10
    5f54:	914a0041 	srl	r10, r10
    5f58:	914a0041 	srl	r10, r10
    5f5c:	914a0041 	srl	r10, r10
    5f60:	914a0041 	srl	r10, r10
    5f64:	85295000 	and	r9, r9, r10
    5f68:	a9290001 	xori	r9, r9, 1
    5f6c:	bc290058 	bnei	r9, 88		// 5fc4
    5f70:	11640000 	addk	r11, r4, r0
    5f74:	11460000 	addk	r10, r6, r0
    5f78:	e98a0000 	lwi	r12, r10, 0
    5f7c:	31290001 	addik	r9, r9, 1
    5f80:	314a0004 	addik	r10, r10, 4
    5f84:	f98b0000 	swi	r12, r11, 0
    5f88:	15854803 	cmpu	r12, r5, r9
    5f8c:	be4cffec 	bltid	r12, -20		// 5f78
    5f90:	316b0004 	addik	r11, r11, 4
    5f94:	88f33800 	xor	r7, r19, r7
    5f98:	10849800 	addk	r4, r4, r19
    5f9c:	10c69800 	addk	r6, r6, r19
    5fa0:	be07fe10 	beqid	r7, -496		// 5db0
    5fa4:	15134000 	rsubk	r8, r19, r8
    5fa8:	e0a60000 	lbui	r5, r6, 0
    5fac:	30e8ffff 	addik	r7, r8, -1
    5fb0:	30c60001 	addik	r6, r6, 1
    5fb4:	f0a40000 	sbi	r5, r4, 0
    5fb8:	be08fdf8 	beqid	r8, -520		// 5db0
    5fbc:	30840001 	addik	r4, r4, 1
    5fc0:	11070000 	addk	r8, r7, r0
    5fc4:	e0a60000 	lbui	r5, r6, 0
    5fc8:	30e8ffff 	addik	r7, r8, -1
    5fcc:	30c60001 	addik	r6, r6, 1
    5fd0:	f0a40000 	sbi	r5, r4, 0
    5fd4:	be28ffec 	bneid	r8, -20		// 5fc0
    5fd8:	30840001 	addik	r4, r4, 1
    5fdc:	ea610004 	lwi	r19, r1, 4
    5fe0:	eac10008 	lwi	r22, r1, 8
    5fe4:	b60f0008 	rtsd	r15, 8
    5fe8:	3021000c 	addik	r1, r1, 12
    5fec:	b810fe9c 	brid	-356		// 5e88
    5ff0:	10830000 	addk	r4, r3, r0

00005ff4 <memset>:
    5ff4:	3021fff4 	addik	r1, r1, -12
    5ff8:	fa610004 	swi	r19, r1, 4
    5ffc:	fac10008 	swi	r22, r1, 8
    6000:	a4850003 	andi	r4, r5, 3
    6004:	be0401d4 	beqid	r4, 468		// 61d8
    6008:	10650000 	addk	r3, r5, r0
    600c:	be070190 	beqid	r7, 400		// 619c
    6010:	30e7ffff 	addik	r7, r7, -1
    6014:	91260060 	sext8	r9, r6
    6018:	b8100014 	brid	20		// 602c
    601c:	10850000 	addk	r4, r5, r0
    6020:	be07017c 	beqid	r7, 380		// 619c
    6024:	3107ffff 	addik	r8, r7, -1
    6028:	10e80000 	addk	r7, r8, r0
    602c:	f1240000 	sbi	r9, r4, 0
    6030:	30840001 	addik	r4, r4, 1
    6034:	a5040003 	andi	r8, r4, 3
    6038:	bc28ffe8 	bnei	r8, -24		// 6020
    603c:	30a00003 	addik	r5, r0, 3
    6040:	14a72803 	cmpu	r5, r7, r5
    6044:	bea500a4 	bgeid	r5, 164		// 60e8
    6048:	a4a600ff 	andi	r5, r6, 255
    604c:	61250100 	muli	r9, r5, 256
    6050:	80a92800 	or	r5, r9, r5
    6054:	3160000f 	addik	r11, r0, 15
    6058:	b0000001 	imm	1
    605c:	61250000 	muli	r9, r5, 0
    6060:	15075803 	cmpu	r8, r7, r11
    6064:	bea80050 	bgeid	r8, 80		// 60b4
    6068:	81292800 	or	r9, r9, r5
    606c:	11040000 	addk	r8, r4, r0
    6070:	11470000 	addk	r10, r7, r0
    6074:	314afff0 	addik	r10, r10, -16
    6078:	f9280000 	swi	r9, r8, 0
    607c:	f9280004 	swi	r9, r8, 4
    6080:	f9280008 	swi	r9, r8, 8
    6084:	f928000c 	swi	r9, r8, 12
    6088:	14aa5803 	cmpu	r5, r10, r11
    608c:	be45ffe8 	bltid	r5, -24		// 6074
    6090:	31080010 	addik	r8, r8, 16
    6094:	3107fff0 	addik	r8, r7, -16
    6098:	a508fff0 	andi	r8, r8, -16
    609c:	a4e7000f 	andi	r7, r7, 15
    60a0:	30a00003 	addik	r5, r0, 3
    60a4:	31080010 	addik	r8, r8, 16
    60a8:	14a72803 	cmpu	r5, r7, r5
    60ac:	bea5003c 	bgeid	r5, 60		// 60e8
    60b0:	10844000 	addk	r4, r4, r8
    60b4:	11440000 	addk	r10, r4, r0
    60b8:	11070000 	addk	r8, r7, r0
    60bc:	31600003 	addik	r11, r0, 3
    60c0:	3108fffc 	addik	r8, r8, -4
    60c4:	f92a0000 	swi	r9, r10, 0
    60c8:	14a85803 	cmpu	r5, r8, r11
    60cc:	be45fff4 	bltid	r5, -12		// 60c0
    60d0:	314a0004 	addik	r10, r10, 4
    60d4:	30a7fffc 	addik	r5, r7, -4
    60d8:	a4a5fffc 	andi	r5, r5, -4
    60dc:	30a50004 	addik	r5, r5, 4
    60e0:	a4e70003 	andi	r7, r7, 3
    60e4:	10842800 	addk	r4, r4, r5
    60e8:	be0700b4 	beqid	r7, 180		// 619c
    60ec:	15640000 	rsubk	r11, r4, r0
    60f0:	a56b0003 	andi	r11, r11, 3
    60f4:	14ab3803 	cmpu	r5, r11, r7
    60f8:	3127ffff 	addik	r9, r7, -1
    60fc:	be4500d4 	bltid	r5, 212		// 61d0
    6100:	90c60060 	sext8	r6, r6
    6104:	be0b0030 	beqid	r11, 48		// 6134
    6108:	11040000 	addk	r8, r4, r0
    610c:	11400000 	addk	r10, r0, r0
    6110:	314a0001 	addik	r10, r10, 1
    6114:	f0c80000 	sbi	r6, r8, 0
    6118:	158b5003 	cmpu	r12, r11, r10
    611c:	31080001 	addik	r8, r8, 1
    6120:	be4cfff0 	bltid	r12, -16		// 6110
    6124:	3129ffff 	addik	r9, r9, -1
    6128:	88a75800 	xor	r5, r7, r11
    612c:	be050074 	beqid	r5, 116		// 61a0
    6130:	ea610004 	lwi	r19, r1, 4
    6134:	14eb3800 	rsubk	r7, r11, r7
    6138:	10a03800 	addk	r5, r0, r7
    613c:	90a70041 	srl	r5, r7
    6140:	90a50041 	srl	r5, r5
    6144:	62650004 	muli	r19, r5, 4
    6148:	be130068 	beqid	r19, 104		// 61b0
    614c:	a54600ff 	andi	r10, r6, 255
    6150:	62ca0100 	muli	r22, r10, 256
    6154:	b0000001 	imm	1
    6158:	618a0000 	muli	r12, r10, 0
    615c:	82cab000 	or	r22, r10, r22
    6160:	81966000 	or	r12, r22, r12
    6164:	b0000100 	imm	256
    6168:	614a0000 	muli	r10, r10, 0
    616c:	818c5000 	or	r12, r12, r10
    6170:	10845800 	addk	r4, r4, r11
    6174:	11400000 	addk	r10, r0, r0
    6178:	314a0001 	addik	r10, r10, 1
    617c:	f9840000 	swi	r12, r4, 0
    6180:	15655003 	cmpu	r11, r5, r10
    6184:	be4bfff4 	bltid	r11, -12		// 6178
    6188:	30840004 	addik	r4, r4, 4
    618c:	88e79800 	xor	r7, r7, r19
    6190:	11089800 	addk	r8, r8, r19
    6194:	be27001c 	bneid	r7, 28		// 61b0
    6198:	15334800 	rsubk	r9, r19, r9
    619c:	ea610004 	lwi	r19, r1, 4
    61a0:	eac10008 	lwi	r22, r1, 8
    61a4:	b60f0008 	rtsd	r15, 8
    61a8:	3021000c 	addik	r1, r1, 12
    61ac:	11240000 	addk	r9, r4, r0
    61b0:	f0c80000 	sbi	r6, r8, 0
    61b4:	3089ffff 	addik	r4, r9, -1
    61b8:	be29fff4 	bneid	r9, -12		// 61ac
    61bc:	31080001 	addik	r8, r8, 1
    61c0:	ea610004 	lwi	r19, r1, 4
    61c4:	eac10008 	lwi	r22, r1, 8
    61c8:	b60f0008 	rtsd	r15, 8
    61cc:	3021000c 	addik	r1, r1, 12
    61d0:	b810ff34 	brid	-204		// 6104
    61d4:	11670000 	addk	r11, r7, r0
    61d8:	b810fe64 	brid	-412		// 603c
    61dc:	10850000 	addk	r4, r5, r0

000061e0 <__tzcalc_limits>:
    61e0:	3021ffb0 	addik	r1, r1, -80
    61e4:	fa610024 	swi	r19, r1, 36
    61e8:	12650000 	addk	r19, r5, r0
    61ec:	fac10028 	swi	r22, r1, 40
    61f0:	fae1002c 	swi	r23, r1, 44
    61f4:	f9e10000 	swi	r15, r1, 0
    61f8:	fb010030 	swi	r24, r1, 48
    61fc:	fb210034 	swi	r25, r1, 52
    6200:	fb410038 	swi	r26, r1, 56
    6204:	fb61003c 	swi	r27, r1, 60
    6208:	fb810040 	swi	r28, r1, 64
    620c:	fba10044 	swi	r29, r1, 68
    6210:	fbc10048 	swi	r30, r1, 72
    6214:	b0000000 	imm	0
    6218:	b9f42fe4 	brlid	r15, 12260	// 91fc <__gettzinfo>
    621c:	fbe1004c 	swi	r31, r1, 76
    6220:	12c30000 	addk	r22, r3, r0
    6224:	306007b1 	addik	r3, r0, 1969
    6228:	14731801 	cmp	r3, r19, r3
    622c:	bea3024c 	bgeid	r3, 588		// 6478
    6230:	12e00000 	addk	r23, r0, r0
    6234:	3373f84e 	addik	r27, r19, -1970
    6238:	637b016d 	muli	r27, r27, 365
    623c:	3093f84f 	addik	r4, r19, -1969
    6240:	10602000 	addk	r3, r0, r4
    6244:	90640001 	sra	r3, r4
    6248:	90630001 	sra	r3, r3
    624c:	30b3f893 	addik	r5, r19, -1901
    6250:	30c0ff9c 	addik	r6, r0, -100
    6254:	fa760004 	swi	r19, r22, 4
    6258:	b0000000 	imm	0
    625c:	b9f46d40 	brlid	r15, 27968	// cf9c <__divsi3>
    6260:	137b1800 	addk	r27, r27, r3
    6264:	30b3f9bf 	addik	r5, r19, -1601
    6268:	30c00190 	addik	r6, r0, 400
    626c:	b0000000 	imm	0
    6270:	b9f46d2c 	brlid	r15, 27948	// cf9c <__divsi3>
    6274:	137b1800 	addk	r27, r27, r3
    6278:	10b30000 	addk	r5, r19, r0
    627c:	30c00064 	addik	r6, r0, 100
    6280:	b0000000 	imm	0
    6284:	b9f46db4 	brlid	r15, 28084	// d038 <__modsi3>
    6288:	137b1800 	addk	r27, r27, r3
    628c:	10b30000 	addk	r5, r19, r0
    6290:	30c00190 	addik	r6, r0, 400
    6294:	b0000000 	imm	0
    6298:	b9f46da0 	brlid	r15, 28064	// d038 <__modsi3>
    629c:	f861001c 	swi	r3, r1, 28
    62a0:	13170000 	addk	r24, r23, r0
    62a4:	8ae3bc00 	pcmpeq	r23, r3, r23
    62a8:	13d7b800 	addk	r30, r23, r23
    62ac:	13a30000 	addk	r29, r3, r0
    62b0:	12feb800 	addk	r23, r30, r23
    62b4:	a7930003 	andi	r28, r19, 3
    62b8:	33400002 	addik	r26, r0, 2
    62bc:	63d70010 	muli	r30, r23, 16
    62c0:	62f80008 	muli	r23, r24, 8
    62c4:	16f8b800 	rsubk	r23, r24, r23
    62c8:	60970004 	muli	r4, r23, 4
    62cc:	10962000 	addk	r4, r22, r4
    62d0:	e0a40008 	lbui	r5, r4, 8
    62d4:	90a50060 	sext8	r5, r5
    62d8:	a8c5004a 	xori	r6, r5, 74
    62dc:	be0601ec 	beqid	r6, 492		// 64c8
    62e0:	a8a50044 	xori	r5, r5, 68
    62e4:	bc05029c 	beqi	r5, 668		// 6580
    62e8:	be1c01cc 	beqid	r28, 460		// 64b4
    62ec:	133e0000 	addk	r25, r30, r0
    62f0:	60970004 	muli	r4, r23, 4
    62f4:	10962000 	addk	r4, r22, r4
    62f8:	e8e4000c 	lwi	r7, r4, 12
    62fc:	30600001 	addik	r3, r0, 1
    6300:	b0000000 	imm	0
    6304:	3339dbe4 	addik	r25, r25, -9244
    6308:	14871801 	cmp	r4, r7, r3
    630c:	bea40288 	bgeid	r4, 648		// 6594
    6310:	127b0000 	addk	r19, r27, r0
    6314:	10830000 	addk	r4, r3, r0
    6318:	30a4ffff 	addik	r5, r4, -1
    631c:	60a50004 	muli	r5, r5, 4
    6320:	c8c5c800 	lw	r6, r5, r25
    6324:	30840001 	addik	r4, r4, 1
    6328:	14a72001 	cmp	r5, r7, r4
    632c:	be45ffec 	bltid	r5, -20		// 6318
    6330:	12733000 	addk	r19, r19, r6
    6334:	30e7ffff 	addik	r7, r7, -1
    6338:	60e70004 	muli	r7, r7, 4
    633c:	30b30004 	addik	r5, r19, 4
    6340:	63f70004 	muli	r31, r23, 4
    6344:	30c00007 	addik	r6, r0, 7
    6348:	f8e10020 	swi	r7, r1, 32
    634c:	b0000000 	imm	0
    6350:	b9f46ce8 	brlid	r15, 27880	// d038 <__modsi3>
    6354:	13f6f800 	addk	r31, r22, r31
    6358:	e8bf0014 	lwi	r5, r31, 20
    635c:	14a32800 	rsubk	r5, r3, r5
    6360:	be45022c 	bltid	r5, 556		// 658c
    6364:	e8e10020 	lwi	r7, r1, 32
    6368:	60970004 	muli	r4, r23, 4
    636c:	10962000 	addk	r4, r22, r4
    6370:	e8840010 	lwi	r4, r4, 16
    6374:	c8c7c800 	lw	r6, r7, r25
    6378:	3084ffff 	addik	r4, r4, -1
    637c:	60e40008 	muli	r7, r4, 8
    6380:	14843800 	rsubk	r4, r4, r7
    6384:	10842800 	addk	r4, r4, r5
    6388:	14a62001 	cmp	r5, r6, r4
    638c:	bc450018 	blti	r5, 24		// 63a4
    6390:	3084fff9 	addik	r4, r4, -7
    6394:	14a62001 	cmp	r5, r6, r4
    6398:	bea5fffc 	bgeid	r5, -4		// 6394
    639c:	3084fff9 	addik	r4, r4, -7
    63a0:	30840007 	addik	r4, r4, 7
    63a4:	10932000 	addk	r4, r19, r4
    63a8:	62f70004 	muli	r23, r23, 4
    63ac:	12f6b800 	addk	r23, r22, r23
    63b0:	b0000001 	imm	1
    63b4:	60845180 	muli	r4, r4, 20864
    63b8:	e8f70018 	lwi	r7, r23, 24
    63bc:	33180001 	addik	r24, r24, 1
    63c0:	e8d70020 	lwi	r6, r23, 32
    63c4:	60b80008 	muli	r5, r24, 8
    63c8:	14b82800 	rsubk	r5, r24, r5
    63cc:	10843800 	addk	r4, r4, r7
    63d0:	60a50004 	muli	r5, r5, 4
    63d4:	10843000 	addk	r4, r4, r6
    63d8:	335affff 	addik	r26, r26, -1
    63dc:	be3afee4 	bneid	r26, -284		// 62c0
    63e0:	d885b000 	sw	r4, r5, r22
    63e4:	e8760038 	lwi	r3, r22, 56
    63e8:	e896001c 	lwi	r4, r22, 28
    63ec:	32e00001 	addik	r23, r0, 1
    63f0:	14832001 	cmp	r4, r3, r4
    63f4:	10602000 	addk	r3, r0, r4
    63f8:	90640041 	srl	r3, r4
    63fc:	90630041 	srl	r3, r3
    6400:	90630041 	srl	r3, r3
    6404:	90630041 	srl	r3, r3
    6408:	90630041 	srl	r3, r3
    640c:	90630041 	srl	r3, r3
    6410:	90630041 	srl	r3, r3
    6414:	90630041 	srl	r3, r3
    6418:	90630041 	srl	r3, r3
    641c:	90630041 	srl	r3, r3
    6420:	90630041 	srl	r3, r3
    6424:	90630041 	srl	r3, r3
    6428:	90630041 	srl	r3, r3
    642c:	90630041 	srl	r3, r3
    6430:	90630041 	srl	r3, r3
    6434:	90630041 	srl	r3, r3
    6438:	90630041 	srl	r3, r3
    643c:	90630041 	srl	r3, r3
    6440:	90630041 	srl	r3, r3
    6444:	90630041 	srl	r3, r3
    6448:	90630041 	srl	r3, r3
    644c:	90630041 	srl	r3, r3
    6450:	90630041 	srl	r3, r3
    6454:	90630041 	srl	r3, r3
    6458:	90630041 	srl	r3, r3
    645c:	90630041 	srl	r3, r3
    6460:	90630041 	srl	r3, r3
    6464:	90630041 	srl	r3, r3
    6468:	90630041 	srl	r3, r3
    646c:	90630041 	srl	r3, r3
    6470:	90630041 	srl	r3, r3
    6474:	f8760000 	swi	r3, r22, 0
    6478:	10770000 	addk	r3, r23, r0
    647c:	e9e10000 	lwi	r15, r1, 0
    6480:	ea610024 	lwi	r19, r1, 36
    6484:	eac10028 	lwi	r22, r1, 40
    6488:	eae1002c 	lwi	r23, r1, 44
    648c:	eb010030 	lwi	r24, r1, 48
    6490:	eb210034 	lwi	r25, r1, 52
    6494:	eb410038 	lwi	r26, r1, 56
    6498:	eb61003c 	lwi	r27, r1, 60
    649c:	eb810040 	lwi	r28, r1, 64
    64a0:	eba10044 	lwi	r29, r1, 68
    64a4:	ebc10048 	lwi	r30, r1, 72
    64a8:	ebe1004c 	lwi	r31, r1, 76
    64ac:	b60f0008 	rtsd	r15, 8
    64b0:	30210050 	addik	r1, r1, 80
    64b4:	e881001c 	lwi	r4, r1, 28
    64b8:	be24fe38 	bneid	r4, -456		// 62f0
    64bc:	33200030 	addik	r25, r0, 48
    64c0:	b810fe30 	brid	-464		// 62f0
    64c4:	133e0000 	addk	r25, r30, r0
    64c8:	e8640014 	lwi	r3, r4, 20
    64cc:	be3c00a4 	bneid	r28, 164		// 6570
    64d0:	10a3d800 	addk	r5, r3, r27
    64d4:	e881001c 	lwi	r4, r1, 28
    64d8:	bc040098 	beqi	r4, 152		// 6570
    64dc:	3080003b 	addik	r4, r0, 59
    64e0:	14632001 	cmp	r3, r3, r4
    64e4:	10801800 	addk	r4, r0, r3
    64e8:	90830041 	srl	r4, r3
    64ec:	90840041 	srl	r4, r4
    64f0:	90840041 	srl	r4, r4
    64f4:	90840041 	srl	r4, r4
    64f8:	90840041 	srl	r4, r4
    64fc:	90840041 	srl	r4, r4
    6500:	90840041 	srl	r4, r4
    6504:	90840041 	srl	r4, r4
    6508:	90840041 	srl	r4, r4
    650c:	90840041 	srl	r4, r4
    6510:	90840041 	srl	r4, r4
    6514:	90840041 	srl	r4, r4
    6518:	90840041 	srl	r4, r4
    651c:	90840041 	srl	r4, r4
    6520:	90840041 	srl	r4, r4
    6524:	90840041 	srl	r4, r4
    6528:	90840041 	srl	r4, r4
    652c:	90840041 	srl	r4, r4
    6530:	90840041 	srl	r4, r4
    6534:	90840041 	srl	r4, r4
    6538:	90840041 	srl	r4, r4
    653c:	90840041 	srl	r4, r4
    6540:	90840041 	srl	r4, r4
    6544:	90840041 	srl	r4, r4
    6548:	90840041 	srl	r4, r4
    654c:	90840041 	srl	r4, r4
    6550:	90840041 	srl	r4, r4
    6554:	90840041 	srl	r4, r4
    6558:	90840041 	srl	r4, r4
    655c:	90840041 	srl	r4, r4
    6560:	90840041 	srl	r4, r4
    6564:	10852000 	addk	r4, r5, r4
    6568:	b810fe40 	brid	-448		// 63a8
    656c:	3084ffff 	addik	r4, r4, -1
    6570:	be3dfff4 	bneid	r29, -12		// 6564
    6574:	10800000 	addk	r4, r0, r0
    6578:	b810ff68 	brid	-152		// 64e0
    657c:	3080003b 	addik	r4, r0, 59
    6580:	e8840014 	lwi	r4, r4, 20
    6584:	b810fe24 	brid	-476		// 63a8
    6588:	109b2000 	addk	r4, r27, r4
    658c:	b810fddc 	brid	-548		// 6368
    6590:	30a50007 	addik	r5, r5, 7
    6594:	b810fda8 	brid	-600		// 633c
    6598:	10e00000 	addk	r7, r0, r0

0000659c <_mktm_r>:
    659c:	3021ffc8 	addik	r1, r1, -56
    65a0:	fb410030 	swi	r26, r1, 48
    65a4:	13450000 	addk	r26, r5, r0
    65a8:	f9e10000 	swi	r15, r1, 0
    65ac:	fa61001c 	swi	r19, r1, 28
    65b0:	fac10020 	swi	r22, r1, 32
    65b4:	fae10024 	swi	r23, r1, 36
    65b8:	fb21002c 	swi	r25, r1, 44
    65bc:	fb610034 	swi	r27, r1, 52
    65c0:	12e60000 	addk	r23, r6, r0
    65c4:	13670000 	addk	r27, r7, r0
    65c8:	b0000000 	imm	0
    65cc:	b9f42c30 	brlid	r15, 11312	// 91fc <__gettzinfo>
    65d0:	fb010028 	swi	r24, r1, 40
    65d4:	eada0000 	lwi	r22, r26, 0
    65d8:	b0000001 	imm	1
    65dc:	30c05180 	addik	r6, r0, 20864
    65e0:	13230000 	addk	r25, r3, r0
    65e4:	b0000000 	imm	0
    65e8:	b9f469b4 	brlid	r15, 27060	// cf9c <__divsi3>
    65ec:	10b60000 	addk	r5, r22, r0
    65f0:	10b60000 	addk	r5, r22, r0
    65f4:	b0000001 	imm	1
    65f8:	30c05180 	addik	r6, r0, 20864
    65fc:	b0000000 	imm	0
    6600:	b9f46a38 	brlid	r15, 27192	// d038 <__modsi3>
    6604:	12630000 	addk	r19, r3, r0
    6608:	bea30014 	bgeid	r3, 20		// 661c
    660c:	12c30000 	addk	r22, r3, r0
    6610:	b0000001 	imm	1
    6614:	32c35180 	addik	r22, r3, 20864
    6618:	3273ffff 	addik	r19, r19, -1
    661c:	10b60000 	addk	r5, r22, r0
    6620:	b0000000 	imm	0
    6624:	b9f46978 	brlid	r15, 27000	// cf9c <__divsi3>
    6628:	30c00e10 	addik	r6, r0, 3600
    662c:	10b60000 	addk	r5, r22, r0
    6630:	30c00e10 	addik	r6, r0, 3600
    6634:	b0000000 	imm	0
    6638:	b9f46a00 	brlid	r15, 27136	// d038 <__modsi3>
    663c:	f8770008 	swi	r3, r23, 8
    6640:	10a30000 	addk	r5, r3, r0
    6644:	12c30000 	addk	r22, r3, r0
    6648:	b0000000 	imm	0
    664c:	b9f46950 	brlid	r15, 26960	// cf9c <__divsi3>
    6650:	30c0003c 	addik	r6, r0, 60
    6654:	10b60000 	addk	r5, r22, r0
    6658:	30c0003c 	addik	r6, r0, 60
    665c:	b0000000 	imm	0
    6660:	b9f469d8 	brlid	r15, 27096	// d038 <__modsi3>
    6664:	f8770004 	swi	r3, r23, 4
    6668:	f8770000 	swi	r3, r23, 0
    666c:	30b30004 	addik	r5, r19, 4
    6670:	b0000000 	imm	0
    6674:	b9f469c4 	brlid	r15, 27076	// d038 <__modsi3>
    6678:	30c00007 	addik	r6, r0, 7
    667c:	be4301e8 	bltid	r3, 488		// 6864
    6680:	f8770018 	swi	r3, r23, 24
    6684:	32c007b2 	addik	r22, r0, 1970
    6688:	beb30014 	bgeid	r19, 20		// 669c
    668c:	13000000 	addk	r24, r0, r0
    6690:	b8100128 	brid	296		// 67b8
    6694:	32d6ffff 	addik	r22, r22, -1
    6698:	16669800 	rsubk	r19, r6, r19
    669c:	a4960003 	andi	r4, r22, 3
    66a0:	10b60000 	addk	r5, r22, r0
    66a4:	be240020 	bneid	r4, 32		// 66c4
    66a8:	30c00064 	addik	r6, r0, 100
    66ac:	b0000000 	imm	0
    66b0:	b9f46988 	brlid	r15, 27016	// d038 <__modsi3>
    66b4:	80000000 	or	r0, r0, r0
    66b8:	be23001c 	bneid	r3, 28		// 66d4
    66bc:	30800001 	addik	r4, r0, 1
    66c0:	10b60000 	addk	r5, r22, r0
    66c4:	b0000000 	imm	0
    66c8:	b9f46970 	brlid	r15, 26992	// d038 <__modsi3>
    66cc:	30c00190 	addik	r6, r0, 400
    66d0:	8883c400 	pcmpeq	r4, r3, r24
    66d4:	60c40004 	muli	r6, r4, 4
    66d8:	b0000000 	imm	0
    66dc:	30c6dbdc 	addik	r6, r6, -9252
    66e0:	e8c60000 	lwi	r6, r6, 0
    66e4:	15069801 	cmp	r8, r6, r19
    66e8:	bea8ffb0 	bgeid	r8, -80		// 6698
    66ec:	32d60001 	addik	r22, r22, 1
    66f0:	32d6ffff 	addik	r22, r22, -1
    66f4:	13042000 	addk	r24, r4, r4
    66f8:	13182000 	addk	r24, r24, r4
    66fc:	3076f894 	addik	r3, r22, -1900
    6700:	63180010 	muli	r24, r24, 16
    6704:	f8770014 	swi	r3, r23, 20
    6708:	fa77001c 	swi	r19, r23, 28
    670c:	b0000000 	imm	0
    6710:	3318dbe4 	addik	r24, r24, -9244
    6714:	f8170010 	swi	r0, r23, 16
    6718:	e8d80000 	lwi	r6, r24, 0
    671c:	14669801 	cmp	r3, r6, r19
    6720:	bc43002c 	blti	r3, 44		// 674c
    6724:	10800000 	addk	r4, r0, r0
    6728:	30840001 	addik	r4, r4, 1
    672c:	61040004 	muli	r8, r4, 4
    6730:	f8970010 	swi	r4, r23, 16
    6734:	16669800 	rsubk	r19, r6, r19
    6738:	c8c8c000 	lw	r6, r8, r24
    673c:	15069801 	cmp	r8, r6, r19
    6740:	bea8ffec 	bgeid	r8, -20		// 672c
    6744:	30840001 	addik	r4, r4, 1
    6748:	3084ffff 	addik	r4, r4, -1
    674c:	32730001 	addik	r19, r19, 1
    6750:	be1b00ac 	beqid	r27, 172		// 67fc
    6754:	fa77000c 	swi	r19, r23, 12
    6758:	f8170020 	swi	r0, r23, 32
    675c:	10770000 	addk	r3, r23, r0
    6760:	e9e10000 	lwi	r15, r1, 0
    6764:	ea61001c 	lwi	r19, r1, 28
    6768:	eac10020 	lwi	r22, r1, 32
    676c:	eae10024 	lwi	r23, r1, 36
    6770:	eb010028 	lwi	r24, r1, 40
    6774:	eb21002c 	lwi	r25, r1, 44
    6778:	eb410030 	lwi	r26, r1, 48
    677c:	eb610034 	lwi	r27, r1, 52
    6780:	b60f0008 	rtsd	r15, 8
    6784:	30210038 	addik	r1, r1, 56
    6788:	10b60000 	addk	r5, r22, r0
    678c:	b0000000 	imm	0
    6790:	b9f468a8 	brlid	r15, 26792	// d038 <__modsi3>
    6794:	30c00190 	addik	r6, r0, 400
    6798:	8883c400 	pcmpeq	r4, r3, r24
    679c:	60640004 	muli	r3, r4, 4
    67a0:	b0000000 	imm	0
    67a4:	3063dbdc 	addik	r3, r3, -9252
    67a8:	e8630000 	lwi	r3, r3, 0
    67ac:	12731800 	addk	r19, r19, r3
    67b0:	bcb3ff44 	bgei	r19, -188		// 66f4
    67b4:	32d6ffff 	addik	r22, r22, -1
    67b8:	a4760003 	andi	r3, r22, 3
    67bc:	10b60000 	addk	r5, r22, r0
    67c0:	be23ffcc 	bneid	r3, -52		// 678c
    67c4:	30c00064 	addik	r6, r0, 100
    67c8:	b0000000 	imm	0
    67cc:	b9f4686c 	brlid	r15, 26732	// d038 <__modsi3>
    67d0:	80000000 	or	r0, r0, r0
    67d4:	be03ffb4 	beqid	r3, -76		// 6788
    67d8:	30800001 	addik	r4, r0, 1
    67dc:	60640004 	muli	r3, r4, 4
    67e0:	b0000000 	imm	0
    67e4:	3063dbdc 	addik	r3, r3, -9252
    67e8:	e8630000 	lwi	r3, r3, 0
    67ec:	12731800 	addk	r19, r19, r3
    67f0:	bc53ffc4 	blti	r19, -60		// 67b4
    67f4:	b810ff04 	brid	-252		// 66f8
    67f8:	13042000 	addk	r24, r4, r4
    67fc:	b0000000 	imm	0
    6800:	b9f423f4 	brlid	r15, 9204	// 8bf4 <__tz_lock>
    6804:	80000000 	or	r0, r0, r0
    6808:	b0000000 	imm	0
    680c:	e860ec28 	lwi	r3, r0, -5080	// ec28 <_daylight>
    6810:	bc030060 	beqi	r3, 96		// 6870
    6814:	e8790004 	lwi	r3, r25, 4
    6818:	8863b000 	xor	r3, r3, r22
    681c:	bc030014 	beqi	r3, 20		// 6830
    6820:	b9f4f9c0 	brlid	r15, -1600	// 61e0 <__tzcalc_limits>
    6824:	10b60000 	addk	r5, r22, r0
    6828:	be0302bc 	beqid	r3, 700		// 6ae4
    682c:	3060ffff 	addik	r3, r0, -1
    6830:	e8790000 	lwi	r3, r25, 0
    6834:	bc030204 	beqi	r3, 516		// 6a38
    6838:	e87a0000 	lwi	r3, r26, 0
    683c:	e899001c 	lwi	r4, r25, 28
    6840:	14841801 	cmp	r4, r4, r3
    6844:	bc4402cc 	blti	r4, 716		// 6b10
    6848:	e8990038 	lwi	r4, r25, 56
    684c:	14641801 	cmp	r3, r4, r3
    6850:	bca302c0 	bgei	r3, 704		// 6b10
    6854:	30600001 	addik	r3, r0, 1
    6858:	f8770020 	swi	r3, r23, 32
    685c:	b810001c 	brid	28		// 6878
    6860:	eb39003c 	lwi	r25, r25, 60
    6864:	30630007 	addik	r3, r3, 7
    6868:	b810fe1c 	brid	-484		// 6684
    686c:	f8770018 	swi	r3, r23, 24
    6870:	fb770020 	swi	r27, r23, 32
    6874:	eb390020 	lwi	r25, r25, 32
    6878:	10b90000 	addk	r5, r25, r0
    687c:	b0000000 	imm	0
    6880:	b9f467b8 	brlid	r15, 26552	// d038 <__modsi3>
    6884:	30c00e10 	addik	r6, r0, 3600
    6888:	10a30000 	addk	r5, r3, r0
    688c:	12630000 	addk	r19, r3, r0
    6890:	b0000000 	imm	0
    6894:	b9f467a4 	brlid	r15, 26532	// d038 <__modsi3>
    6898:	30c0003c 	addik	r6, r0, 60
    689c:	ead70000 	lwi	r22, r23, 0
    68a0:	10b30000 	addk	r5, r19, r0
    68a4:	30c0003c 	addik	r6, r0, 60
    68a8:	16c3b000 	rsubk	r22, r3, r22
    68ac:	b0000000 	imm	0
    68b0:	b9f466ec 	brlid	r15, 26348	// cf9c <__divsi3>
    68b4:	fad70000 	swi	r22, r23, 0
    68b8:	ea770004 	lwi	r19, r23, 4
    68bc:	10b90000 	addk	r5, r25, r0
    68c0:	30c00e10 	addik	r6, r0, 3600
    68c4:	16639800 	rsubk	r19, r3, r19
    68c8:	b0000000 	imm	0
    68cc:	b9f466d0 	brlid	r15, 26320	// cf9c <__divsi3>
    68d0:	fa770004 	swi	r19, r23, 4
    68d4:	e8970008 	lwi	r4, r23, 8
    68d8:	30a0003b 	addik	r5, r0, 59
    68dc:	14b62801 	cmp	r5, r22, r5
    68e0:	14832000 	rsubk	r4, r3, r4
    68e4:	bea500bc 	bgeid	r5, 188		// 69a0
    68e8:	f8970008 	swi	r4, r23, 8
    68ec:	32730001 	addik	r19, r19, 1
    68f0:	32d6ffc4 	addik	r22, r22, -60
    68f4:	fa770004 	swi	r19, r23, 4
    68f8:	fad70000 	swi	r22, r23, 0
    68fc:	3060003b 	addik	r3, r0, 59
    6900:	14731801 	cmp	r3, r19, r3
    6904:	bea3011c 	bgeid	r3, 284		// 6a20
    6908:	30600017 	addik	r3, r0, 23
    690c:	30840001 	addik	r4, r4, 1
    6910:	3273ffc4 	addik	r19, r19, -60
    6914:	f8970008 	swi	r4, r23, 8
    6918:	fa770004 	swi	r19, r23, 4
    691c:	14641801 	cmp	r3, r4, r3
    6920:	bca3009c 	bgei	r3, 156		// 69bc
    6924:	e8b7001c 	lwi	r5, r23, 28
    6928:	e8770018 	lwi	r3, r23, 24
    692c:	30a50001 	addik	r5, r5, 1
    6930:	30630001 	addik	r3, r3, 1
    6934:	f8b7001c 	swi	r5, r23, 28
    6938:	30a00006 	addik	r5, r0, 6
    693c:	f8770018 	swi	r3, r23, 24
    6940:	14632801 	cmp	r3, r3, r5
    6944:	bca30008 	bgei	r3, 8		// 694c
    6948:	f8170018 	swi	r0, r23, 24
    694c:	e877000c 	lwi	r3, r23, 12
    6950:	e8b70010 	lwi	r5, r23, 16
    6954:	3084ffe8 	addik	r4, r4, -24
    6958:	30630001 	addik	r3, r3, 1
    695c:	f8970008 	swi	r4, r23, 8
    6960:	f877000c 	swi	r3, r23, 12
    6964:	60850004 	muli	r4, r5, 4
    6968:	c884c000 	lw	r4, r4, r24
    696c:	14c32001 	cmp	r6, r3, r4
    6970:	bca6001c 	bgei	r6, 28		// 698c
    6974:	30a50001 	addik	r5, r5, 1
    6978:	14641800 	rsubk	r3, r4, r3
    697c:	f877000c 	swi	r3, r23, 12
    6980:	a865000c 	xori	r3, r5, 12
    6984:	be030168 	beqid	r3, 360		// 6aec
    6988:	f8b70010 	swi	r5, r23, 16
    698c:	b0000000 	imm	0
    6990:	b9f4226c 	brlid	r15, 8812	// 8bfc <__tz_unlock>
    6994:	80000000 	or	r0, r0, r0
    6998:	b810fdc8 	brid	-568		// 6760
    699c:	10770000 	addk	r3, r23, r0
    69a0:	beb6ff60 	bgeid	r22, -160		// 6900
    69a4:	3060003b 	addik	r3, r0, 59
    69a8:	3273ffff 	addik	r19, r19, -1
    69ac:	32d6003c 	addik	r22, r22, 60
    69b0:	fa770004 	swi	r19, r23, 4
    69b4:	b810ff4c 	brid	-180		// 6900
    69b8:	fad70000 	swi	r22, r23, 0
    69bc:	bca4ffd0 	bgei	r4, -48		// 698c
    69c0:	e8b7001c 	lwi	r5, r23, 28
    69c4:	e8770018 	lwi	r3, r23, 24
    69c8:	30a5ffff 	addik	r5, r5, -1
    69cc:	3063ffff 	addik	r3, r3, -1
    69d0:	f8b7001c 	swi	r5, r23, 28
    69d4:	be430144 	bltid	r3, 324		// 6b18
    69d8:	f8770018 	swi	r3, r23, 24
    69dc:	e877000c 	lwi	r3, r23, 12
    69e0:	30840018 	addik	r4, r4, 24
    69e4:	f8970008 	swi	r4, r23, 8
    69e8:	3063ffff 	addik	r3, r3, -1
    69ec:	be23ffa0 	bneid	r3, -96		// 698c
    69f0:	f877000c 	swi	r3, r23, 12
    69f4:	e8770010 	lwi	r3, r23, 16
    69f8:	3063ffff 	addik	r3, r3, -1
    69fc:	be430128 	bltid	r3, 296		// 6b24
    6a00:	f8770010 	swi	r3, r23, 16
    6a04:	60630004 	muli	r3, r3, 4
    6a08:	c863c000 	lw	r3, r3, r24
    6a0c:	b0000000 	imm	0
    6a10:	b9f421ec 	brlid	r15, 8684	// 8bfc <__tz_unlock>
    6a14:	f877000c 	swi	r3, r23, 12
    6a18:	b810fd48 	brid	-696		// 6760
    6a1c:	10770000 	addk	r3, r23, r0
    6a20:	bcb3fefc 	bgei	r19, -260		// 691c
    6a24:	3084ffff 	addik	r4, r4, -1
    6a28:	3273003c 	addik	r19, r19, 60
    6a2c:	f8970008 	swi	r4, r23, 8
    6a30:	b810feec 	brid	-276		// 691c
    6a34:	fa770004 	swi	r19, r23, 4
    6a38:	e87a0000 	lwi	r3, r26, 0
    6a3c:	e899001c 	lwi	r4, r25, 28
    6a40:	14841801 	cmp	r4, r4, r3
    6a44:	bca4fe10 	bgei	r4, -496		// 6854
    6a48:	e8990038 	lwi	r4, r25, 56
    6a4c:	14641801 	cmp	r3, r4, r3
    6a50:	10801800 	addk	r4, r0, r3
    6a54:	90830041 	srl	r4, r3
    6a58:	90840041 	srl	r4, r4
    6a5c:	90840041 	srl	r4, r4
    6a60:	90840041 	srl	r4, r4
    6a64:	90840041 	srl	r4, r4
    6a68:	90840041 	srl	r4, r4
    6a6c:	90840041 	srl	r4, r4
    6a70:	90840041 	srl	r4, r4
    6a74:	90840041 	srl	r4, r4
    6a78:	90840041 	srl	r4, r4
    6a7c:	90840041 	srl	r4, r4
    6a80:	90840041 	srl	r4, r4
    6a84:	90840041 	srl	r4, r4
    6a88:	90840041 	srl	r4, r4
    6a8c:	90840041 	srl	r4, r4
    6a90:	90840041 	srl	r4, r4
    6a94:	90840041 	srl	r4, r4
    6a98:	90840041 	srl	r4, r4
    6a9c:	90840041 	srl	r4, r4
    6aa0:	90840041 	srl	r4, r4
    6aa4:	90840041 	srl	r4, r4
    6aa8:	90840041 	srl	r4, r4
    6aac:	90840041 	srl	r4, r4
    6ab0:	90840041 	srl	r4, r4
    6ab4:	90840041 	srl	r4, r4
    6ab8:	90840041 	srl	r4, r4
    6abc:	90840041 	srl	r4, r4
    6ac0:	90840041 	srl	r4, r4
    6ac4:	90840041 	srl	r4, r4
    6ac8:	90840041 	srl	r4, r4
    6acc:	90840041 	srl	r4, r4
    6ad0:	f8970020 	swi	r4, r23, 32
    6ad4:	a8840001 	xori	r4, r4, 1
    6ad8:	bc24fd9c 	bnei	r4, -612		// 6874
    6adc:	b810fd9c 	brid	-612		// 6878
    6ae0:	eb39003c 	lwi	r25, r25, 60
    6ae4:	b810fd90 	brid	-624		// 6874
    6ae8:	f8770020 	swi	r3, r23, 32
    6aec:	e8970014 	lwi	r4, r23, 20
    6af0:	f8770010 	swi	r3, r23, 16
    6af4:	f877001c 	swi	r3, r23, 28
    6af8:	30640001 	addik	r3, r4, 1
    6afc:	b0000000 	imm	0
    6b00:	b9f420fc 	brlid	r15, 8444	// 8bfc <__tz_unlock>
    6b04:	f8770014 	swi	r3, r23, 20
    6b08:	b810fc58 	brid	-936		// 6760
    6b0c:	10770000 	addk	r3, r23, r0
    6b10:	b810fd64 	brid	-668		// 6874
    6b14:	f8170020 	swi	r0, r23, 32
    6b18:	30600006 	addik	r3, r0, 6
    6b1c:	b810fec0 	brid	-320		// 69dc
    6b20:	f8770018 	swi	r3, r23, 24
    6b24:	ea770014 	lwi	r19, r23, 20
    6b28:	3060000b 	addik	r3, r0, 11
    6b2c:	f8770010 	swi	r3, r23, 16
    6b30:	3073ffff 	addik	r3, r19, -1
    6b34:	f8770014 	swi	r3, r23, 20
    6b38:	a4630003 	andi	r3, r3, 3
    6b3c:	be230020 	bneid	r3, 32		// 6b5c
    6b40:	3273076b 	addik	r19, r19, 1899
    6b44:	10b30000 	addk	r5, r19, r0
    6b48:	b0000000 	imm	0
    6b4c:	b9f464ec 	brlid	r15, 25836	// d038 <__modsi3>
    6b50:	30c00064 	addik	r6, r0, 100
    6b54:	be230024 	bneid	r3, 36		// 6b78
    6b58:	3080016d 	addik	r4, r0, 365
    6b5c:	10b30000 	addk	r5, r19, r0
    6b60:	b0000000 	imm	0
    6b64:	b9f464d4 	brlid	r15, 25812	// d038 <__modsi3>
    6b68:	30c00190 	addik	r6, r0, 400
    6b6c:	10800000 	addk	r4, r0, r0
    6b70:	88632400 	pcmpeq	r3, r3, r4
    6b74:	3083016c 	addik	r4, r3, 364
    6b78:	f897001c 	swi	r4, r23, 28
    6b7c:	b810fe8c 	brid	-372		// 6a08
    6b80:	3060002c 	addik	r3, r0, 44

00006b84 <__malloc_lock>:
    6b84:	b60f0008 	rtsd	r15, 8
    6b88:	80000000 	or	r0, r0, r0

00006b8c <__malloc_unlock>:
    6b8c:	b60f0008 	rtsd	r15, 8
    6b90:	80000000 	or	r0, r0, r0

00006b94 <realloc>:
    6b94:	10650000 	addk	r3, r5, r0
    6b98:	10e60000 	addk	r7, r6, r0
    6b9c:	b0000000 	imm	0
    6ba0:	e8a0e3e8 	lwi	r5, r0, -7192	// e3e8 <_impure_ptr>
    6ba4:	3021ffe4 	addik	r1, r1, -28
    6ba8:	f9e10000 	swi	r15, r1, 0
    6bac:	b0000000 	imm	0
    6bb0:	b9f40014 	brlid	r15, 20	// 6bc4 <_realloc_r>
    6bb4:	10c30000 	addk	r6, r3, r0
    6bb8:	e9e10000 	lwi	r15, r1, 0
    6bbc:	b60f0008 	rtsd	r15, 8
    6bc0:	3021001c 	addik	r1, r1, 28

00006bc4 <_realloc_r>:
    6bc4:	3021ffc0 	addik	r1, r1, -64
    6bc8:	fa61001c 	swi	r19, r1, 28
    6bcc:	fb410030 	swi	r26, r1, 48
    6bd0:	fb610034 	swi	r27, r1, 52
    6bd4:	f9e10000 	swi	r15, r1, 0
    6bd8:	fac10020 	swi	r22, r1, 32
    6bdc:	fae10024 	swi	r23, r1, 36
    6be0:	fb010028 	swi	r24, r1, 40
    6be4:	fb21002c 	swi	r25, r1, 44
    6be8:	fb810038 	swi	r28, r1, 56
    6bec:	fba1003c 	swi	r29, r1, 60
    6bf0:	12660000 	addk	r19, r6, r0
    6bf4:	13450000 	addk	r26, r5, r0
    6bf8:	be0603b8 	beqid	r6, 952		// 6fb0
    6bfc:	13670000 	addk	r27, r7, r0
    6c00:	b000ffff 	imm	-1
    6c04:	b9f4ff80 	brlid	r15, -128	// 6b84 <__malloc_lock>
    6c08:	32db000b 	addik	r22, r27, 11
    6c0c:	30800016 	addik	r4, r0, 22
    6c10:	14962003 	cmpu	r4, r22, r4
    6c14:	be44010c 	bltid	r4, 268		// 6d20
    6c18:	e873fffc 	lwi	r3, r19, -4
    6c1c:	30a00010 	addik	r5, r0, 16	// 10 <_vector_interrupt>
    6c20:	12c50000 	addk	r22, r5, r0
    6c24:	149bb003 	cmpu	r4, r27, r22
    6c28:	be440188 	bltid	r4, 392		// 6db0
    6c2c:	10c00000 	addk	r6, r0, r0
    6c30:	be260180 	bneid	r6, 384		// 6db0
    6c34:	a703fffc 	andi	r24, r3, -4
    6c38:	1485c001 	cmp	r4, r5, r24
    6c3c:	3393fff8 	addik	r28, r19, -8
    6c40:	bea40210 	bgeid	r4, 528		// 6e50
    6c44:	12f80000 	addk	r23, r24, r0
    6c48:	b0000000 	imm	0
    6c4c:	e8e0e520 	lwi	r7, r0, -6880
    6c50:	109cc000 	addk	r4, r28, r24
    6c54:	89072000 	xor	r8, r7, r4
    6c58:	be08036c 	beqid	r8, 876		// 6fc4
    6c5c:	31360010 	addik	r9, r22, 16
    6c60:	e9040004 	lwi	r8, r4, 4
    6c64:	a528fffe 	andi	r9, r8, -2
    6c68:	11244800 	addk	r9, r4, r9
    6c6c:	e9290004 	lwi	r9, r9, 4
    6c70:	a5290001 	andi	r9, r9, 1
    6c74:	bc09024c 	beqi	r9, 588		// 6ec0
    6c78:	10860000 	addk	r4, r6, r0
    6c7c:	a4630001 	andi	r3, r3, 1
    6c80:	bc2302a0 	bnei	r3, 672		// 6f20
    6c84:	eb33fff8 	lwi	r25, r19, -8
    6c88:	1739e000 	rsubk	r25, r25, r28
    6c8c:	e8790004 	lwi	r3, r25, 4
    6c90:	be040130 	beqid	r4, 304		// 6dc0
    6c94:	a463fffc 	andi	r3, r3, -4
    6c98:	88e43800 	xor	r7, r4, r7
    6c9c:	be07040c 	beqid	r7, 1036		// 70a8
    6ca0:	1063c000 	addk	r3, r3, r24
    6ca4:	12e61800 	addk	r23, r6, r3
    6ca8:	14c5b801 	cmp	r6, r5, r23
    6cac:	be46011c 	bltid	r6, 284		// 6dc8
    6cb0:	14a51801 	cmp	r5, r5, r3
    6cb4:	e864000c 	lwi	r3, r4, 12
    6cb8:	e8840008 	lwi	r4, r4, 8
    6cbc:	30f8fffc 	addik	r7, r24, -4
    6cc0:	31190008 	addik	r8, r25, 8
    6cc4:	f8830008 	swi	r4, r3, 8
    6cc8:	f864000c 	swi	r3, r4, 12
    6ccc:	e879000c 	lwi	r3, r25, 12
    6cd0:	e8b90008 	lwi	r5, r25, 8
    6cd4:	30800024 	addik	r4, r0, 36
    6cd8:	14872003 	cmpu	r4, r7, r4
    6cdc:	f865000c 	swi	r3, r5, 12
    6ce0:	be4404b8 	bltid	r4, 1208		// 7198
    6ce4:	f8a30008 	swi	r5, r3, 8
    6ce8:	30600013 	addik	r3, r0, 19
    6cec:	14671803 	cmpu	r3, r7, r3
    6cf0:	bea30350 	bgeid	r3, 848		// 7040
    6cf4:	10680000 	addk	r3, r8, r0
    6cf8:	e8730000 	lwi	r3, r19, 0
    6cfc:	f8790008 	swi	r3, r25, 8
    6d00:	e8930004 	lwi	r4, r19, 4
    6d04:	3060001b 	addik	r3, r0, 27
    6d08:	14671803 	cmpu	r3, r7, r3
    6d0c:	be4304b4 	bltid	r3, 1204		// 71c0
    6d10:	f899000c 	swi	r4, r25, 12
    6d14:	30790010 	addik	r3, r25, 16
    6d18:	b810032c 	brid	812		// 7044
    6d1c:	30930008 	addik	r4, r19, 8
    6d20:	a6d6fff8 	andi	r22, r22, -8
    6d24:	149bb003 	cmpu	r4, r27, r22
    6d28:	10c0b000 	addk	r6, r0, r22
    6d2c:	90d60041 	srl	r6, r22
    6d30:	90c60041 	srl	r6, r6
    6d34:	90c60041 	srl	r6, r6
    6d38:	90c60041 	srl	r6, r6
    6d3c:	90c60041 	srl	r6, r6
    6d40:	90c60041 	srl	r6, r6
    6d44:	90c60041 	srl	r6, r6
    6d48:	90c60041 	srl	r6, r6
    6d4c:	90c60041 	srl	r6, r6
    6d50:	90c60041 	srl	r6, r6
    6d54:	90c60041 	srl	r6, r6
    6d58:	90c60041 	srl	r6, r6
    6d5c:	90c60041 	srl	r6, r6
    6d60:	90c60041 	srl	r6, r6
    6d64:	90c60041 	srl	r6, r6
    6d68:	90c60041 	srl	r6, r6
    6d6c:	90c60041 	srl	r6, r6
    6d70:	90c60041 	srl	r6, r6
    6d74:	90c60041 	srl	r6, r6
    6d78:	90c60041 	srl	r6, r6
    6d7c:	90c60041 	srl	r6, r6
    6d80:	90c60041 	srl	r6, r6
    6d84:	90c60041 	srl	r6, r6
    6d88:	90c60041 	srl	r6, r6
    6d8c:	90c60041 	srl	r6, r6
    6d90:	90c60041 	srl	r6, r6
    6d94:	90c60041 	srl	r6, r6
    6d98:	90c60041 	srl	r6, r6
    6d9c:	90c60041 	srl	r6, r6
    6da0:	90c60041 	srl	r6, r6
    6da4:	90c60041 	srl	r6, r6
    6da8:	bea4fe88 	bgeid	r4, -376		// 6c30
    6dac:	10b60000 	addk	r5, r22, r0
    6db0:	3060000c 	addik	r3, r0, 12
    6db4:	f87a0000 	swi	r3, r26, 0
    6db8:	b81000d4 	brid	212		// 6e8c
    6dbc:	12e00000 	addk	r23, r0, r0
    6dc0:	1063c000 	addk	r3, r3, r24
    6dc4:	14a51801 	cmp	r5, r5, r3
    6dc8:	be45015c 	bltid	r5, 348		// 6f24
    6dcc:	10ba0000 	addk	r5, r26, r0
    6dd0:	e899000c 	lwi	r4, r25, 12
    6dd4:	e8b90008 	lwi	r5, r25, 8
    6dd8:	30f8fffc 	addik	r7, r24, -4
    6ddc:	f885000c 	swi	r4, r5, 12
    6de0:	f8a40008 	swi	r5, r4, 8
    6de4:	30800024 	addik	r4, r0, 36
    6de8:	14872003 	cmpu	r4, r7, r4
    6dec:	be440280 	bltid	r4, 640		// 706c
    6df0:	31190008 	addik	r8, r25, 8
    6df4:	30800013 	addik	r4, r0, 19
    6df8:	14872003 	cmpu	r4, r7, r4
    6dfc:	bea403bc 	bgeid	r4, 956		// 71b8
    6e00:	10880000 	addk	r4, r8, r0
    6e04:	e8930000 	lwi	r4, r19, 0
    6e08:	f8990008 	swi	r4, r25, 8
    6e0c:	e8b30004 	lwi	r5, r19, 4
    6e10:	3080001b 	addik	r4, r0, 27
    6e14:	14872003 	cmpu	r4, r7, r4
    6e18:	be4403e8 	bltid	r4, 1000		// 7200
    6e1c:	f8b9000c 	swi	r5, r25, 12
    6e20:	30990010 	addik	r4, r25, 16
    6e24:	30d30008 	addik	r6, r19, 8
    6e28:	e8a60000 	lwi	r5, r6, 0
    6e2c:	12e30000 	addk	r23, r3, r0
    6e30:	12680000 	addk	r19, r8, r0
    6e34:	f8a40000 	swi	r5, r4, 0
    6e38:	e8660004 	lwi	r3, r6, 4
    6e3c:	13990000 	addk	r28, r25, r0
    6e40:	f8640004 	swi	r3, r4, 4
    6e44:	e8c60008 	lwi	r6, r6, 8
    6e48:	f8c40008 	swi	r6, r4, 8
    6e4c:	e8790004 	lwi	r3, r25, 4
    6e50:	1496b800 	rsubk	r4, r22, r23
    6e54:	30a0000f 	addik	r5, r0, 15
    6e58:	14a42803 	cmpu	r5, r4, r5
    6e5c:	be450088 	bltid	r5, 136		// 6ee4
    6e60:	a4630001 	andi	r3, r3, 1
    6e64:	8063b800 	or	r3, r3, r23
    6e68:	f87c0004 	swi	r3, r28, 4
    6e6c:	139cb800 	addk	r28, r28, r23
    6e70:	e87c0004 	lwi	r3, r28, 4
    6e74:	a0630001 	ori	r3, r3, 1
    6e78:	f87c0004 	swi	r3, r28, 4
    6e7c:	10ba0000 	addk	r5, r26, r0
    6e80:	b000ffff 	imm	-1
    6e84:	b9f4fd08 	brlid	r15, -760	// 6b8c <__malloc_unlock>
    6e88:	12f30000 	addk	r23, r19, r0
    6e8c:	10770000 	addk	r3, r23, r0
    6e90:	e9e10000 	lwi	r15, r1, 0
    6e94:	ea61001c 	lwi	r19, r1, 28
    6e98:	eac10020 	lwi	r22, r1, 32
    6e9c:	eae10024 	lwi	r23, r1, 36
    6ea0:	eb010028 	lwi	r24, r1, 40
    6ea4:	eb21002c 	lwi	r25, r1, 44
    6ea8:	eb410030 	lwi	r26, r1, 48
    6eac:	eb610034 	lwi	r27, r1, 52
    6eb0:	eb810038 	lwi	r28, r1, 56
    6eb4:	eba1003c 	lwi	r29, r1, 60
    6eb8:	b60f0008 	rtsd	r15, 8
    6ebc:	30210040 	addik	r1, r1, 64
    6ec0:	a4c8fffc 	andi	r6, r8, -4
    6ec4:	12e6c000 	addk	r23, r6, r24
    6ec8:	1505b801 	cmp	r8, r5, r23
    6ecc:	bc48fdb0 	blti	r8, -592		// 6c7c
    6ed0:	e8a4000c 	lwi	r5, r4, 12
    6ed4:	e8840008 	lwi	r4, r4, 8
    6ed8:	f8a4000c 	swi	r5, r4, 12
    6edc:	b810ff74 	brid	-140		// 6e50
    6ee0:	f8850008 	swi	r4, r5, 8
    6ee4:	8063b000 	or	r3, r3, r22
    6ee8:	f87c0004 	swi	r3, r28, 4
    6eec:	10dcb000 	addk	r6, r28, r22
    6ef0:	a0640001 	ori	r3, r4, 1
    6ef4:	f8660004 	swi	r3, r6, 4
    6ef8:	10862000 	addk	r4, r6, r4
    6efc:	e8640004 	lwi	r3, r4, 4
    6f00:	10ba0000 	addk	r5, r26, r0
    6f04:	30c60008 	addik	r6, r6, 8
    6f08:	a0630001 	ori	r3, r3, 1
    6f0c:	b0000000 	imm	0
    6f10:	b9f41ecc 	brlid	r15, 7884	// 8ddc <_free_r>
    6f14:	f8640004 	swi	r3, r4, 4
    6f18:	b810ff68 	brid	-152		// 6e80
    6f1c:	10ba0000 	addk	r5, r26, r0
    6f20:	10ba0000 	addk	r5, r26, r0
    6f24:	b000ffff 	imm	-1
    6f28:	b9f4e068 	brlid	r15, -8088	// 4f90 <_malloc_r>
    6f2c:	10db0000 	addk	r6, r27, r0
    6f30:	be03006c 	beqid	r3, 108		// 6f9c
    6f34:	12e30000 	addk	r23, r3, r0
    6f38:	e873fffc 	lwi	r3, r19, -4
    6f3c:	30b7fff8 	addik	r5, r23, -8
    6f40:	a483fffe 	andi	r4, r3, -2
    6f44:	109c2000 	addk	r4, r28, r4
    6f48:	88852000 	xor	r4, r5, r4
    6f4c:	be04023c 	beqid	r4, 572		// 7188
    6f50:	30f8fffc 	addik	r7, r24, -4
    6f54:	30600024 	addik	r3, r0, 36
    6f58:	14671803 	cmpu	r3, r7, r3
    6f5c:	bc430134 	blti	r3, 308		// 7090
    6f60:	30600013 	addik	r3, r0, 19
    6f64:	14671803 	cmpu	r3, r7, r3
    6f68:	be4300b0 	bltid	r3, 176		// 7018
    6f6c:	10770000 	addk	r3, r23, r0
    6f70:	10930000 	addk	r4, r19, r0
    6f74:	e8a40000 	lwi	r5, r4, 0
    6f78:	f8a30000 	swi	r5, r3, 0
    6f7c:	e8a40004 	lwi	r5, r4, 4
    6f80:	f8a30004 	swi	r5, r3, 4
    6f84:	e8840008 	lwi	r4, r4, 8
    6f88:	f8830008 	swi	r4, r3, 8
    6f8c:	10ba0000 	addk	r5, r26, r0
    6f90:	b0000000 	imm	0
    6f94:	b9f41e48 	brlid	r15, 7752	// 8ddc <_free_r>
    6f98:	10d30000 	addk	r6, r19, r0
    6f9c:	b000ffff 	imm	-1
    6fa0:	b9f4fbec 	brlid	r15, -1044	// 6b8c <__malloc_unlock>
    6fa4:	10ba0000 	addk	r5, r26, r0
    6fa8:	b810fee8 	brid	-280		// 6e90
    6fac:	10770000 	addk	r3, r23, r0
    6fb0:	b000ffff 	imm	-1
    6fb4:	b9f4dfdc 	brlid	r15, -8228	// 4f90 <_malloc_r>
    6fb8:	10c70000 	addk	r6, r7, r0
    6fbc:	b810fed0 	brid	-304		// 6e8c
    6fc0:	12e30000 	addk	r23, r3, r0
    6fc4:	e8c70004 	lwi	r6, r7, 4
    6fc8:	a4c6fffc 	andi	r6, r6, -4
    6fcc:	1106c000 	addk	r8, r6, r24
    6fd0:	15294001 	cmp	r9, r9, r8
    6fd4:	be49fca8 	bltid	r9, -856		// 6c7c
    6fd8:	10870000 	addk	r4, r7, r0
    6fdc:	14764000 	rsubk	r3, r22, r8
    6fe0:	139cb000 	addk	r28, r28, r22
    6fe4:	a0630001 	ori	r3, r3, 1
    6fe8:	f87c0004 	swi	r3, r28, 4
    6fec:	e873fffc 	lwi	r3, r19, -4
    6ff0:	10ba0000 	addk	r5, r26, r0
    6ff4:	b0000000 	imm	0
    6ff8:	fb80e520 	swi	r28, r0, -6880
    6ffc:	a4630001 	andi	r3, r3, 1
    7000:	82d61800 	or	r22, r22, r3
    7004:	b000ffff 	imm	-1
    7008:	b9f4fb84 	brlid	r15, -1148	// 6b8c <__malloc_unlock>
    700c:	fad3fffc 	swi	r22, r19, -4
    7010:	b810fe7c 	brid	-388		// 6e8c
    7014:	12f30000 	addk	r23, r19, r0
    7018:	e8930000 	lwi	r4, r19, 0
    701c:	3060001b 	addik	r3, r0, 27
    7020:	14671803 	cmpu	r3, r7, r3
    7024:	f8970000 	swi	r4, r23, 0
    7028:	e8b30004 	lwi	r5, r19, 4
    702c:	be430138 	bltid	r3, 312		// 7164
    7030:	f8b70004 	swi	r5, r23, 4
    7034:	30770008 	addik	r3, r23, 8
    7038:	b810ff3c 	brid	-196		// 6f74
    703c:	30930008 	addik	r4, r19, 8
    7040:	10930000 	addk	r4, r19, r0
    7044:	e8a40000 	lwi	r5, r4, 0
    7048:	12680000 	addk	r19, r8, r0
    704c:	13990000 	addk	r28, r25, r0
    7050:	f8a30000 	swi	r5, r3, 0
    7054:	e8a40004 	lwi	r5, r4, 4
    7058:	f8a30004 	swi	r5, r3, 4
    705c:	e8840008 	lwi	r4, r4, 8
    7060:	f8830008 	swi	r4, r3, 8
    7064:	b810fdec 	brid	-532		// 6e50
    7068:	e8790004 	lwi	r3, r25, 4
    706c:	10d30000 	addk	r6, r19, r0
    7070:	10a80000 	addk	r5, r8, r0
    7074:	12680000 	addk	r19, r8, r0
    7078:	b000ffff 	imm	-1
    707c:	b9f4ecdc 	brlid	r15, -4900	// 5d58 <memmove>
    7080:	12e30000 	addk	r23, r3, r0
    7084:	e8790004 	lwi	r3, r25, 4
    7088:	b810fdc8 	brid	-568		// 6e50
    708c:	13990000 	addk	r28, r25, r0
    7090:	10b70000 	addk	r5, r23, r0
    7094:	b000ffff 	imm	-1
    7098:	b9f4ecc0 	brlid	r15, -4928	// 5d58 <memmove>
    709c:	10d30000 	addk	r6, r19, r0
    70a0:	b810fef0 	brid	-272		// 6f90
    70a4:	10ba0000 	addk	r5, r26, r0
    70a8:	13a61800 	addk	r29, r6, r3
    70ac:	30960010 	addik	r4, r22, 16
    70b0:	1484e801 	cmp	r4, r4, r29
    70b4:	be44fd10 	bltid	r4, -752		// 6dc4
    70b8:	30f8fffc 	addik	r7, r24, -4
    70bc:	e879000c 	lwi	r3, r25, 12
    70c0:	e8990008 	lwi	r4, r25, 8
    70c4:	f864000c 	swi	r3, r4, 12
    70c8:	f8830008 	swi	r4, r3, 8
    70cc:	30600024 	addik	r3, r0, 36
    70d0:	14671803 	cmpu	r3, r7, r3
    70d4:	be430190 	bltid	r3, 400		// 7264
    70d8:	32f90008 	addik	r23, r25, 8
    70dc:	30600013 	addik	r3, r0, 19
    70e0:	14671803 	cmpu	r3, r7, r3
    70e4:	bea3015c 	bgeid	r3, 348		// 7240
    70e8:	10770000 	addk	r3, r23, r0
    70ec:	e8930000 	lwi	r4, r19, 0
    70f0:	3060001b 	addik	r3, r0, 27
    70f4:	14671803 	cmpu	r3, r7, r3
    70f8:	f8990008 	swi	r4, r25, 8
    70fc:	e8b30004 	lwi	r5, r19, 4
    7100:	be43017c 	bltid	r3, 380		// 727c
    7104:	f8b9000c 	swi	r5, r25, 12
    7108:	30790010 	addik	r3, r25, 16
    710c:	30930008 	addik	r4, r19, 8
    7110:	e8a40000 	lwi	r5, r4, 0
    7114:	f8a30000 	swi	r5, r3, 0
    7118:	e8a40004 	lwi	r5, r4, 4
    711c:	f8a30004 	swi	r5, r3, 4
    7120:	e8840008 	lwi	r4, r4, 8
    7124:	f8830008 	swi	r4, r3, 8
    7128:	1496e800 	rsubk	r4, r22, r29
    712c:	1079b000 	addk	r3, r25, r22
    7130:	a0840001 	ori	r4, r4, 1
    7134:	f8830004 	swi	r4, r3, 4
    7138:	e8990004 	lwi	r4, r25, 4
    713c:	10ba0000 	addk	r5, r26, r0
    7140:	b0000000 	imm	0
    7144:	f860e520 	swi	r3, r0, -6880
    7148:	a4640001 	andi	r3, r4, 1
    714c:	82d61800 	or	r22, r22, r3
    7150:	b000ffff 	imm	-1
    7154:	b9f4fa38 	brlid	r15, -1480	// 6b8c <__malloc_unlock>
    7158:	fad90004 	swi	r22, r25, 4
    715c:	b810fd34 	brid	-716		// 6e90
    7160:	10770000 	addk	r3, r23, r0
    7164:	e8730008 	lwi	r3, r19, 8
    7168:	a8e70024 	xori	r7, r7, 36
    716c:	f8770008 	swi	r3, r23, 8
    7170:	e893000c 	lwi	r4, r19, 12
    7174:	be070070 	beqid	r7, 112		// 71e4
    7178:	f897000c 	swi	r4, r23, 12
    717c:	30770010 	addik	r3, r23, 16
    7180:	b810fdf4 	brid	-524		// 6f74
    7184:	30930010 	addik	r4, r19, 16
    7188:	eaf7fffc 	lwi	r23, r23, -4
    718c:	a6f7fffc 	andi	r23, r23, -4
    7190:	b810fcc0 	brid	-832		// 6e50
    7194:	12f7c000 	addk	r23, r23, r24
    7198:	10d30000 	addk	r6, r19, r0
    719c:	10a80000 	addk	r5, r8, r0
    71a0:	12680000 	addk	r19, r8, r0
    71a4:	b000ffff 	imm	-1
    71a8:	b9f4ebb0 	brlid	r15, -5200	// 5d58 <memmove>
    71ac:	13990000 	addk	r28, r25, r0
    71b0:	b810fca0 	brid	-864		// 6e50
    71b4:	e8790004 	lwi	r3, r25, 4
    71b8:	b810fc70 	brid	-912		// 6e28
    71bc:	10d30000 	addk	r6, r19, r0
    71c0:	e8b30008 	lwi	r5, r19, 8
    71c4:	a8e70024 	xori	r7, r7, 36
    71c8:	f8b90010 	swi	r5, r25, 16
    71cc:	e873000c 	lwi	r3, r19, 12
    71d0:	be070054 	beqid	r7, 84		// 7224
    71d4:	f8790014 	swi	r3, r25, 20
    71d8:	30790018 	addik	r3, r25, 24
    71dc:	b810fe68 	brid	-408		// 7044
    71e0:	30930010 	addik	r4, r19, 16
    71e4:	e8b30010 	lwi	r5, r19, 16
    71e8:	30770018 	addik	r3, r23, 24
    71ec:	30930018 	addik	r4, r19, 24
    71f0:	f8b70010 	swi	r5, r23, 16
    71f4:	e8b30014 	lwi	r5, r19, 20
    71f8:	b810fd7c 	brid	-644		// 6f74
    71fc:	f8b70014 	swi	r5, r23, 20
    7200:	e8930008 	lwi	r4, r19, 8
    7204:	a8e70024 	xori	r7, r7, 36
    7208:	f8990010 	swi	r4, r25, 16
    720c:	e8b3000c 	lwi	r5, r19, 12
    7210:	be070038 	beqid	r7, 56		// 7248
    7214:	f8b90014 	swi	r5, r25, 20
    7218:	30990018 	addik	r4, r25, 24
    721c:	b810fc0c 	brid	-1012		// 6e28
    7220:	30d30010 	addik	r6, r19, 16
    7224:	e8930010 	lwi	r4, r19, 16
    7228:	30790020 	addik	r3, r25, 32
    722c:	f8990018 	swi	r4, r25, 24
    7230:	30930018 	addik	r4, r19, 24
    7234:	ea730014 	lwi	r19, r19, 20
    7238:	b810fe0c 	brid	-500		// 7044
    723c:	fa79001c 	swi	r19, r25, 28
    7240:	b810fed0 	brid	-304		// 7110
    7244:	10930000 	addk	r4, r19, r0
    7248:	e8930010 	lwi	r4, r19, 16
    724c:	30d30018 	addik	r6, r19, 24
    7250:	f8990018 	swi	r4, r25, 24
    7254:	ea730014 	lwi	r19, r19, 20
    7258:	30990020 	addik	r4, r25, 32
    725c:	b810fbcc 	brid	-1076		// 6e28
    7260:	fa79001c 	swi	r19, r25, 28
    7264:	10b70000 	addk	r5, r23, r0
    7268:	b000ffff 	imm	-1
    726c:	b9f4eaec 	brlid	r15, -5396	// 5d58 <memmove>
    7270:	10d30000 	addk	r6, r19, r0
    7274:	b810feb8 	brid	-328		// 712c
    7278:	1496e800 	rsubk	r4, r22, r29
    727c:	e8730008 	lwi	r3, r19, 8
    7280:	a8e70024 	xori	r7, r7, 36
    7284:	f8790010 	swi	r3, r25, 16
    7288:	e893000c 	lwi	r4, r19, 12
    728c:	be070014 	beqid	r7, 20		// 72a0
    7290:	f8990014 	swi	r4, r25, 20
    7294:	30790018 	addik	r3, r25, 24
    7298:	b810fe78 	brid	-392		// 7110
    729c:	30930010 	addik	r4, r19, 16
    72a0:	e8b30010 	lwi	r5, r19, 16
    72a4:	30930018 	addik	r4, r19, 24
    72a8:	30790020 	addik	r3, r25, 32
    72ac:	f8b90018 	swi	r5, r25, 24
    72b0:	ea730014 	lwi	r19, r19, 20
    72b4:	b810fe5c 	brid	-420		// 7110
    72b8:	fa79001c 	swi	r19, r25, 28

000072bc <_sbrk_r>:
    72bc:	3021ffe0 	addik	r1, r1, -32
    72c0:	fa61001c 	swi	r19, r1, 28
    72c4:	12650000 	addk	r19, r5, r0
    72c8:	f9e10000 	swi	r15, r1, 0
    72cc:	b0000000 	imm	0
    72d0:	f800ecbc 	swi	r0, r0, -4932	// ecbc <errno>
    72d4:	b0000000 	imm	0
    72d8:	b9f442f4 	brlid	r15, 17140	// b5cc <sbrk>
    72dc:	10a60000 	addk	r5, r6, r0
    72e0:	a883ffff 	xori	r4, r3, -1
    72e4:	be040014 	beqid	r4, 20		// 72f8
    72e8:	e9e10000 	lwi	r15, r1, 0
    72ec:	ea61001c 	lwi	r19, r1, 28
    72f0:	b60f0008 	rtsd	r15, 8
    72f4:	30210020 	addik	r1, r1, 32
    72f8:	b0000000 	imm	0
    72fc:	e880ecbc 	lwi	r4, r0, -4932	// ecbc <errno>
    7300:	bc04ffec 	beqi	r4, -20		// 72ec
    7304:	f8930000 	swi	r4, r19, 0
    7308:	e9e10000 	lwi	r15, r1, 0
    730c:	ea61001c 	lwi	r19, r1, 28
    7310:	b60f0008 	rtsd	r15, 8
    7314:	30210020 	addik	r1, r1, 32

00007318 <iso_year_adjust>:
    7318:	3021ffdc 	addik	r1, r1, -36
    731c:	fac10020 	swi	r22, r1, 32
    7320:	f9e10000 	swi	r15, r1, 0
    7324:	fa61001c 	swi	r19, r1, 28
    7328:	ea650014 	lwi	r19, r5, 20
    732c:	a4730003 	andi	r3, r19, 3
    7330:	be230074 	bneid	r3, 116		// 73a4
    7334:	12c50000 	addk	r22, r5, r0
    7338:	be53010c 	bltid	r19, 268		// 7444
    733c:	30a0ff9c 	addik	r5, r0, -100
    7340:	10a59800 	addk	r5, r5, r19
    7344:	b0000000 	imm	0
    7348:	b9f45cf0 	brlid	r15, 23792	// d038 <__modsi3>
    734c:	30c00064 	addik	r6, r0, 100
    7350:	be030054 	beqid	r3, 84		// 73a4
    7354:	30800001 	addik	r4, r0, 1
    7358:	e8b6001c 	lwi	r5, r22, 28
    735c:	e8760018 	lwi	r3, r22, 24
    7360:	60a50010 	muli	r5, r5, 16
    7364:	10631800 	addk	r3, r3, r3
    7368:	10651800 	addk	r3, r5, r3
    736c:	10641800 	addk	r3, r4, r3
    7370:	30800021 	addik	r4, r0, 33
    7374:	14832001 	cmp	r4, r3, r4
    7378:	be440050 	bltid	r4, 80		// 73c8
    737c:	30800020 	addik	r4, r0, 32	// 20 <_vector_hw_exception>
    7380:	14841801 	cmp	r4, r4, r3
    7384:	be440080 	bltid	r4, 128		// 7404
    7388:	3080000d 	addik	r4, r0, 13
    738c:	e9e10000 	lwi	r15, r1, 0
    7390:	ea61001c 	lwi	r19, r1, 28
    7394:	eac10020 	lwi	r22, r1, 32
    7398:	3060ffff 	addik	r3, r0, -1
    739c:	b60f0008 	rtsd	r15, 8
    73a0:	30210024 	addik	r1, r1, 36
    73a4:	be530058 	bltid	r19, 88		// 73fc
    73a8:	30a0ff9c 	addik	r5, r0, -100
    73ac:	10a59800 	addk	r5, r5, r19
    73b0:	b0000000 	imm	0
    73b4:	b9f45c84 	brlid	r15, 23684	// d038 <__modsi3>
    73b8:	30c00190 	addik	r6, r0, 400
    73bc:	10800000 	addk	r4, r0, r0
    73c0:	b810ff98 	brid	-104		// 7358
    73c4:	88832400 	pcmpeq	r4, r3, r4
    73c8:	308016c6 	addik	r4, r0, 5830
    73cc:	14832001 	cmp	r4, r3, r4
    73d0:	be440094 	bltid	r4, 148		// 7464
    73d4:	308016c2 	addik	r4, r0, 5826
    73d8:	14841801 	cmp	r4, r4, r3
    73dc:	be4400ac 	bltid	r4, 172		// 7488
    73e0:	a88316a2 	xori	r4, r3, 5794
    73e4:	30600001 	addik	r3, r0, 1
    73e8:	e9e10000 	lwi	r15, r1, 0
    73ec:	ea61001c 	lwi	r19, r1, 28
    73f0:	eac10020 	lwi	r22, r1, 32
    73f4:	b60f0008 	rtsd	r15, 8
    73f8:	30210024 	addik	r1, r1, 36
    73fc:	b810ffb0 	brid	-80		// 73ac
    7400:	30a0076c 	addik	r5, r0, 1900
    7404:	14832001 	cmp	r4, r3, r4
    7408:	be4400ac 	bltid	r4, 172		// 74b4
    740c:	3080000a 	addik	r4, r0, 10
    7410:	14841801 	cmp	r4, r4, r3
    7414:	bea4ff7c 	bgeid	r4, -132		// 7390
    7418:	e9e10000 	lwi	r15, r1, 0
    741c:	30800001 	addik	r4, r0, 1
    7420:	14632003 	cmpu	r3, r3, r4
    7424:	bea3ff6c 	bgeid	r3, -148		// 7390
    7428:	e9e10000 	lwi	r15, r1, 0
    742c:	e9e10000 	lwi	r15, r1, 0
    7430:	ea61001c 	lwi	r19, r1, 28
    7434:	eac10020 	lwi	r22, r1, 32
    7438:	10600000 	addk	r3, r0, r0
    743c:	b60f0008 	rtsd	r15, 8
    7440:	30210024 	addik	r1, r1, 36
    7444:	30a0076c 	addik	r5, r0, 1900
    7448:	10a59800 	addk	r5, r5, r19
    744c:	b0000000 	imm	0
    7450:	b9f45be8 	brlid	r15, 23528	// d038 <__modsi3>
    7454:	30c00064 	addik	r6, r0, 100
    7458:	be23ff00 	bneid	r3, -256		// 7358
    745c:	30800001 	addik	r4, r0, 1
    7460:	b800ff44 	bri	-188		// 73a4
    7464:	a88316d5 	xori	r4, r3, 5845
    7468:	be04ff7c 	beqid	r4, -132		// 73e4
    746c:	a88316d7 	xori	r4, r3, 5847
    7470:	be04ff74 	beqid	r4, -140		// 73e4
    7474:	a86316d3 	xori	r3, r3, 5843
    7478:	be23ffb8 	bneid	r3, -72		// 7430
    747c:	e9e10000 	lwi	r15, r1, 0
    7480:	b810ff6c 	brid	-148		// 73ec
    7484:	30600001 	addik	r3, r0, 1
    7488:	be04ff5c 	beqid	r4, -164		// 73e4
    748c:	308016a2 	addik	r4, r0, 5794
    7490:	14841801 	cmp	r4, r4, r3
    7494:	be44ff98 	bltid	r4, -104		// 742c
    7498:	3063e94e 	addik	r3, r3, -5810
    749c:	30800002 	addik	r4, r0, 2
    74a0:	14632003 	cmpu	r3, r3, r4
    74a4:	be43ff88 	bltid	r3, -120		// 742c
    74a8:	30600001 	addik	r3, r0, 1
    74ac:	b810ff40 	brid	-192		// 73ec
    74b0:	e9e10000 	lwi	r15, r1, 0
    74b4:	30800010 	addik	r4, r0, 16	// 10 <_vector_interrupt>
    74b8:	14841801 	cmp	r4, r4, r3
    74bc:	be44ff70 	bltid	r4, -144		// 742c
    74c0:	30800011 	addik	r4, r0, 17
    74c4:	14832001 	cmp	r4, r3, r4
    74c8:	bea4fec8 	bgeid	r4, -312		// 7390
    74cc:	e9e10000 	lwi	r15, r1, 0
    74d0:	b810ff4c 	brid	-180		// 741c
    74d4:	3063ffe4 	addik	r3, r3, -28

000074d8 <strftime>:
    74d8:	3021ff8c 	addik	r1, r1, -116
    74dc:	fa610048 	swi	r19, r1, 72
    74e0:	fac1004c 	swi	r22, r1, 76
    74e4:	fb010054 	swi	r24, r1, 84
    74e8:	fb210058 	swi	r25, r1, 88
    74ec:	fb610060 	swi	r27, r1, 96
    74f0:	fbc1006c 	swi	r30, r1, 108
    74f4:	fbe10070 	swi	r31, r1, 112
    74f8:	f9e10000 	swi	r15, r1, 0
    74fc:	fae10050 	swi	r23, r1, 80
    7500:	fb41005c 	swi	r26, r1, 92
    7504:	fb810064 	swi	r28, r1, 100
    7508:	fba10068 	swi	r29, r1, 104
    750c:	12600000 	addk	r19, r0, r0
    7510:	13050000 	addk	r24, r5, r0
    7514:	13260000 	addk	r25, r6, r0
    7518:	12c70000 	addk	r22, r7, r0
    751c:	b0000000 	imm	0
    7520:	b9f41660 	brlid	r15, 5728	// 8b80 <__get_current_time_locale>
    7524:	13680000 	addk	r27, r8, r0
    7528:	13d30000 	addk	r30, r19, r0
    752c:	13e30000 	addk	r31, r3, r0
    7530:	e0b60000 	lbui	r5, r22, 0
    7534:	30c00025 	addik	r6, r0, 37
    7538:	90850060 	sext8	r4, r5
    753c:	8cc43400 	pcmpne	r6, r4, r6
    7540:	be06000c 	beqid	r6, 12		// 754c
    7544:	8cc4f400 	pcmpne	r6, r4, r30
    7548:	bc260084 	bnei	r6, 132		// 75cc
    754c:	be0401d0 	beqid	r4, 464		// 771c
    7550:	3380002b 	addik	r28, r0, 43
    7554:	e3560001 	lbui	r26, r22, 1
    7558:	935a0060 	sext8	r26, r26
    755c:	8b9ae400 	pcmpeq	r28, r26, r28
    7560:	be3c011c 	bneid	r28, 284		// 767c
    7564:	30800030 	addik	r4, r0, 48
    7568:	889a2400 	pcmpeq	r4, r26, r4
    756c:	be240110 	bneid	r4, 272		// 767c
    7570:	12fa0000 	addk	r23, r26, r0
    7574:	30a00008 	addik	r5, r0, 8	// 8 <_vector_sw_exception>
    7578:	32d60001 	addik	r22, r22, 1
    757c:	3097ffcf 	addik	r4, r23, -49
    7580:	a48400ff 	andi	r4, r4, 255
    7584:	14842803 	cmpu	r4, r4, r5
    7588:	135c0000 	addk	r26, r28, r0
    758c:	bea40114 	bgeid	r4, 276		// 76a0
    7590:	13a00000 	addk	r29, r0, r0
    7594:	a8970045 	xori	r4, r23, 69
    7598:	bc040134 	beqi	r4, 308		// 76cc
    759c:	a897004f 	xori	r4, r23, 79
    75a0:	bc04012c 	beqi	r4, 300		// 76cc
    75a4:	3097ffdb 	addik	r4, r23, -37
    75a8:	a48400ff 	andi	r4, r4, 255
    75ac:	30a00055 	addik	r5, r0, 85
    75b0:	14a42803 	cmpu	r5, r4, r5
    75b4:	bc450088 	blti	r5, 136		// 763c
    75b8:	60840004 	muli	r4, r4, 4
    75bc:	b0000000 	imm	0
    75c0:	3084dcbc 	addik	r4, r4, -9028
    75c4:	e8840000 	lwi	r4, r4, 0
    75c8:	98082000 	bra	r4
    75cc:	3099ffff 	addik	r4, r25, -1
    75d0:	14849803 	cmpu	r4, r4, r19
    75d4:	bea40068 	bgeid	r4, 104		// 763c
    75d8:	32d60001 	addik	r22, r22, 1
    75dc:	d0b3c000 	sb	r5, r19, r24
    75e0:	b810ff50 	brid	-176		// 7530
    75e4:	32730001 	addik	r19, r19, 1
    75e8:	e87b0010 	lwi	r3, r27, 16
    75ec:	60630004 	muli	r3, r3, 4
    75f0:	cae3f800 	lw	r23, r3, r31
    75f4:	b0000000 	imm	0
    75f8:	b9f41290 	brlid	r15, 4752	// 8888 <strlen>
    75fc:	10b70000 	addk	r5, r23, r0
    7600:	be030380 	beqid	r3, 896		// 7980
    7604:	30b9ffff 	addik	r5, r25, -1
    7608:	14859803 	cmpu	r4, r5, r19
    760c:	bca40030 	bgei	r4, 48		// 763c
    7610:	10c00000 	addk	r6, r0, r0
    7614:	10860000 	addk	r4, r6, r0
    7618:	c0c6b800 	lbu	r6, r6, r23
    761c:	30840001 	addik	r4, r4, 1
    7620:	14e32003 	cmpu	r7, r3, r4
    7624:	d0d3c000 	sb	r6, r19, r24
    7628:	32730001 	addik	r19, r19, 1
    762c:	bea70354 	bgeid	r7, 852		// 7980
    7630:	10c40000 	addk	r6, r4, r0
    7634:	14e59803 	cmpu	r7, r5, r19
    7638:	bc47ffe0 	blti	r7, -32		// 7618
    763c:	12600000 	addk	r19, r0, r0
    7640:	10730000 	addk	r3, r19, r0
    7644:	e9e10000 	lwi	r15, r1, 0
    7648:	ea610048 	lwi	r19, r1, 72
    764c:	eac1004c 	lwi	r22, r1, 76
    7650:	eae10050 	lwi	r23, r1, 80
    7654:	eb010054 	lwi	r24, r1, 84
    7658:	eb210058 	lwi	r25, r1, 88
    765c:	eb41005c 	lwi	r26, r1, 92
    7660:	eb610060 	lwi	r27, r1, 96
    7664:	eb810064 	lwi	r28, r1, 100
    7668:	eba10068 	lwi	r29, r1, 104
    766c:	ebc1006c 	lwi	r30, r1, 108
    7670:	ebe10070 	lwi	r31, r1, 112
    7674:	b60f0008 	rtsd	r15, 8
    7678:	30210074 	addik	r1, r1, 116
    767c:	e2f60002 	lbui	r23, r22, 2
    7680:	30a00008 	addik	r5, r0, 8	// 8 <_vector_sw_exception>
    7684:	32d60002 	addik	r22, r22, 2
    7688:	92f70060 	sext8	r23, r23
    768c:	3097ffcf 	addik	r4, r23, -49
    7690:	a48400ff 	andi	r4, r4, 255
    7694:	14842803 	cmpu	r4, r4, r5
    7698:	be44fefc 	bltid	r4, -260		// 7594
    769c:	13a00000 	addk	r29, r0, r0
    76a0:	10b60000 	addk	r5, r22, r0
    76a4:	30c1001c 	addik	r6, r1, 28
    76a8:	b0000000 	imm	0
    76ac:	b9f414a0 	brlid	r15, 5280	// 8b4c <strtoul>
    76b0:	30e0000a 	addik	r7, r0, 10
    76b4:	eac1001c 	lwi	r22, r1, 28
    76b8:	e2f60000 	lbui	r23, r22, 0
    76bc:	92f70060 	sext8	r23, r23
    76c0:	a8970045 	xori	r4, r23, 69
    76c4:	be24fed8 	bneid	r4, -296		// 759c
    76c8:	13a30000 	addk	r29, r3, r0
    76cc:	e2f60001 	lbui	r23, r22, 1
    76d0:	32d60001 	addik	r22, r22, 1
    76d4:	b810fed0 	brid	-304		// 75a4
    76d8:	92f70060 	sext8	r23, r23
    76dc:	eaff00a0 	lwi	r23, r31, 160
    76e0:	b0000000 	imm	0
    76e4:	b9f411a4 	brlid	r15, 4516	// 8888 <strlen>
    76e8:	10b70000 	addk	r5, r23, r0
    76ec:	e0770000 	lbui	r3, r23, 0
    76f0:	be030290 	beqid	r3, 656		// 7980
    76f4:	10f70000 	addk	r7, r23, r0
    76f8:	111b0000 	addk	r8, r27, r0
    76fc:	10b89800 	addk	r5, r24, r19
    7700:	b9f4fdd8 	brlid	r15, -552	// 74d8 <strftime>
    7704:	14d3c800 	rsubk	r6, r19, r25
    7708:	bc63ff34 	blei	r3, -204		// 763c
    770c:	e0960000 	lbui	r4, r22, 0
    7710:	90840060 	sext8	r4, r4
    7714:	be24003c 	bneid	r4, 60		// 7750
    7718:	12731800 	addk	r19, r19, r3
    771c:	be19ff28 	beqid	r25, -216		// 7644
    7720:	10730000 	addk	r3, r19, r0
    7724:	b810ff20 	brid	-224		// 7644
    7728:	d013c000 	sb	r0, r19, r24
    772c:	3079ffff 	addik	r3, r25, -1
    7730:	14639803 	cmpu	r3, r3, r19
    7734:	bea3ff08 	bgeid	r3, -248		// 763c
    7738:	30600025 	addik	r3, r0, 37
    773c:	d073c000 	sb	r3, r19, r24
    7740:	e0960000 	lbui	r4, r22, 0
    7744:	90840060 	sext8	r4, r4
    7748:	be04ffd4 	beqid	r4, -44		// 771c
    774c:	32730001 	addik	r19, r19, 1
    7750:	b810fde0 	brid	-544		// 7530
    7754:	32d60001 	addik	r22, r22, 1
    7758:	e87b0018 	lwi	r3, r27, 24
    775c:	3063001f 	addik	r3, r3, 31
    7760:	60630004 	muli	r3, r3, 4
    7764:	cae3f800 	lw	r23, r3, r31
    7768:	b0000000 	imm	0
    776c:	b9f4111c 	brlid	r15, 4380	// 8888 <strlen>
    7770:	10b70000 	addk	r5, r23, r0
    7774:	be03020c 	beqid	r3, 524		// 7980
    7778:	30b9ffff 	addik	r5, r25, -1
    777c:	14859803 	cmpu	r4, r5, r19
    7780:	bca4febc 	bgei	r4, -324		// 763c
    7784:	10c00000 	addk	r6, r0, r0
    7788:	b8100010 	brid	16		// 7798
    778c:	10860000 	addk	r4, r6, r0
    7790:	14e59803 	cmpu	r7, r5, r19
    7794:	bca7fea8 	bgei	r7, -344		// 763c
    7798:	c0c6b800 	lbu	r6, r6, r23
    779c:	30840001 	addik	r4, r4, 1
    77a0:	14e32003 	cmpu	r7, r3, r4
    77a4:	d0d3c000 	sb	r6, r19, r24
    77a8:	32730001 	addik	r19, r19, 1
    77ac:	be47ffe4 	bltid	r7, -28		// 7790
    77b0:	10c40000 	addk	r6, r4, r0
    77b4:	b81001d0 	brid	464		// 7984
    77b8:	e0960000 	lbui	r4, r22, 0
    77bc:	e87b0010 	lwi	r3, r27, 16
    77c0:	3063000c 	addik	r3, r3, 12
    77c4:	60630004 	muli	r3, r3, 4
    77c8:	cae3f800 	lw	r23, r3, r31
    77cc:	b0000000 	imm	0
    77d0:	b9f410b8 	brlid	r15, 4280	// 8888 <strlen>
    77d4:	10b70000 	addk	r5, r23, r0
    77d8:	be0301a8 	beqid	r3, 424		// 7980
    77dc:	30b9ffff 	addik	r5, r25, -1
    77e0:	14859803 	cmpu	r4, r5, r19
    77e4:	bca4fe58 	bgei	r4, -424		// 763c
    77e8:	10c00000 	addk	r6, r0, r0
    77ec:	b8100010 	brid	16		// 77fc
    77f0:	10860000 	addk	r4, r6, r0
    77f4:	14e59803 	cmpu	r7, r5, r19
    77f8:	bca7fe44 	bgei	r7, -444		// 763c
    77fc:	c0c6b800 	lbu	r6, r6, r23
    7800:	30840001 	addik	r4, r4, 1
    7804:	14e32003 	cmpu	r7, r3, r4
    7808:	d0d3c000 	sb	r6, r19, r24
    780c:	32730001 	addik	r19, r19, 1
    7810:	be47ffe4 	bltid	r7, -28		// 77f4
    7814:	10c40000 	addk	r6, r4, r0
    7818:	b810016c 	brid	364		// 7984
    781c:	e0960000 	lbui	r4, r22, 0
    7820:	e8bb0014 	lwi	r5, r27, 20
    7824:	3060f894 	addik	r3, r0, -1900
    7828:	14632801 	cmp	r3, r3, r5
    782c:	12e01800 	addk	r23, r0, r3
    7830:	92e30041 	srl	r23, r3
    7834:	92f70041 	srl	r23, r23
    7838:	92f70041 	srl	r23, r23
    783c:	92f70041 	srl	r23, r23
    7840:	92f70041 	srl	r23, r23
    7844:	92f70041 	srl	r23, r23
    7848:	92f70041 	srl	r23, r23
    784c:	92f70041 	srl	r23, r23
    7850:	92f70041 	srl	r23, r23
    7854:	92f70041 	srl	r23, r23
    7858:	92f70041 	srl	r23, r23
    785c:	92f70041 	srl	r23, r23
    7860:	92f70041 	srl	r23, r23
    7864:	92f70041 	srl	r23, r23
    7868:	92f70041 	srl	r23, r23
    786c:	92f70041 	srl	r23, r23
    7870:	92f70041 	srl	r23, r23
    7874:	92f70041 	srl	r23, r23
    7878:	92f70041 	srl	r23, r23
    787c:	92f70041 	srl	r23, r23
    7880:	92f70041 	srl	r23, r23
    7884:	92f70041 	srl	r23, r23
    7888:	92f70041 	srl	r23, r23
    788c:	92f70041 	srl	r23, r23
    7890:	92f70041 	srl	r23, r23
    7894:	92f70041 	srl	r23, r23
    7898:	92f70041 	srl	r23, r23
    789c:	92f70041 	srl	r23, r23
    78a0:	92f70041 	srl	r23, r23
    78a4:	92f70041 	srl	r23, r23
    78a8:	92f70041 	srl	r23, r23
    78ac:	bc450ea4 	blti	r5, 3748		// 8750
    78b0:	b0000000 	imm	0
    78b4:	b9f456e8 	brlid	r15, 22248	// cf9c <__divsi3>
    78b8:	30c00064 	addik	r6, r0, 100
    78bc:	31430013 	addik	r10, r3, 19
    78c0:	be1a0d4c 	beqid	r26, 3404		// 860c
    78c4:	30600063 	addik	r3, r0, 99
    78c8:	146a1801 	cmp	r3, r10, r3
    78cc:	bc430dbc 	blti	r3, 3516		// 8688
    78d0:	b0000000 	imm	0
    78d4:	3100dc44 	addik	r8, r0, -9148
    78d8:	b0000000 	imm	0
    78dc:	30e0dc50 	addik	r7, r0, -9136
    78e0:	30800001 	addik	r4, r0, 1
    78e4:	147d2003 	cmpu	r3, r29, r4
    78e8:	bca30d58 	bgei	r3, 3416		// 8640
    78ec:	10b89800 	addk	r5, r24, r19
    78f0:	be170010 	beqid	r23, 16		// 7900
    78f4:	14d3c800 	rsubk	r6, r19, r25
    78f8:	b0000000 	imm	0
    78fc:	3100dc5c 	addik	r8, r0, -9124
    7900:	b0000000 	imm	0
    7904:	b9f42278 	brlid	r15, 8824	// 9b7c <sniprintf>
    7908:	1537e800 	rsubk	r9, r23, r29
    790c:	bea3006c 	bgeid	r3, 108		// 7978
    7910:	12731800 	addk	r19, r19, r3
    7914:	16639800 	rsubk	r19, r3, r19
    7918:	b810fd28 	brid	-728		// 7640
    791c:	12600000 	addk	r19, r0, r0
    7920:	eb5b0010 	lwi	r26, r27, 16
    7924:	e87b0014 	lwi	r3, r27, 20
    7928:	13b89800 	addk	r29, r24, r19
    792c:	1793c800 	rsubk	r28, r19, r25
    7930:	335a0001 	addik	r26, r26, 1
    7934:	be430e08 	bltid	r3, 3592		// 873c
    7938:	eafb000c 	lwi	r23, r27, 12
    793c:	10a30000 	addk	r5, r3, r0
    7940:	b0000000 	imm	0
    7944:	b9f456f4 	brlid	r15, 22260	// d038 <__modsi3>
    7948:	30c00064 	addik	r6, r0, 100
    794c:	11430000 	addk	r10, r3, r0
    7950:	10bd0000 	addk	r5, r29, r0
    7954:	10dc0000 	addk	r6, r28, r0
    7958:	b0000000 	imm	0
    795c:	30e0dc6c 	addik	r7, r0, -9108
    7960:	111a0000 	addk	r8, r26, r0
    7964:	b0000000 	imm	0
    7968:	b9f42214 	brlid	r15, 8724	// 9b7c <sniprintf>
    796c:	11370000 	addk	r9, r23, r0
    7970:	be43fccc 	bltid	r3, -820		// 763c
    7974:	12731800 	addk	r19, r19, r3
    7978:	14799803 	cmpu	r3, r25, r19
    797c:	bca3fcc0 	bgei	r3, -832		// 763c
    7980:	e0960000 	lbui	r4, r22, 0
    7984:	90840060 	sext8	r4, r4
    7988:	be24fba8 	bneid	r4, -1112		// 7530
    798c:	32d60001 	addik	r22, r22, 1
    7990:	b800fd8c 	bri	-628		// 771c
    7994:	e87b0020 	lwi	r3, r27, 32
    7998:	bc43fdb8 	blti	r3, -584		// 7750
    799c:	b0000000 	imm	0
    79a0:	b9f41254 	brlid	r15, 4692	// 8bf4 <__tz_lock>
    79a4:	80000000 	or	r0, r0, r0
    79a8:	e87b0020 	lwi	r3, r27, 32
    79ac:	10801800 	addk	r4, r0, r3
    79b0:	90830001 	sra	r4, r3
    79b4:	90840001 	sra	r4, r4
    79b8:	90840001 	sra	r4, r4
    79bc:	90840001 	sra	r4, r4
    79c0:	90840001 	sra	r4, r4
    79c4:	90840001 	sra	r4, r4
    79c8:	90840001 	sra	r4, r4
    79cc:	90840001 	sra	r4, r4
    79d0:	90840001 	sra	r4, r4
    79d4:	90840001 	sra	r4, r4
    79d8:	90840001 	sra	r4, r4
    79dc:	90840001 	sra	r4, r4
    79e0:	90840001 	sra	r4, r4
    79e4:	90840001 	sra	r4, r4
    79e8:	90840001 	sra	r4, r4
    79ec:	90840001 	sra	r4, r4
    79f0:	90840001 	sra	r4, r4
    79f4:	90840001 	sra	r4, r4
    79f8:	90840001 	sra	r4, r4
    79fc:	90840001 	sra	r4, r4
    7a00:	90840001 	sra	r4, r4
    7a04:	90840001 	sra	r4, r4
    7a08:	90840001 	sra	r4, r4
    7a0c:	90840001 	sra	r4, r4
    7a10:	90840001 	sra	r4, r4
    7a14:	90840001 	sra	r4, r4
    7a18:	90840001 	sra	r4, r4
    7a1c:	90840001 	sra	r4, r4
    7a20:	90840001 	sra	r4, r4
    7a24:	90840001 	sra	r4, r4
    7a28:	90840001 	sra	r4, r4
    7a2c:	14832000 	rsubk	r4, r3, r4
    7a30:	10602000 	addk	r3, r0, r4
    7a34:	90640041 	srl	r3, r4
    7a38:	90630041 	srl	r3, r3
    7a3c:	90630041 	srl	r3, r3
    7a40:	90630041 	srl	r3, r3
    7a44:	90630041 	srl	r3, r3
    7a48:	90630041 	srl	r3, r3
    7a4c:	90630041 	srl	r3, r3
    7a50:	90630041 	srl	r3, r3
    7a54:	90630041 	srl	r3, r3
    7a58:	90630041 	srl	r3, r3
    7a5c:	90630041 	srl	r3, r3
    7a60:	90630041 	srl	r3, r3
    7a64:	90630041 	srl	r3, r3
    7a68:	90630041 	srl	r3, r3
    7a6c:	90630041 	srl	r3, r3
    7a70:	90630041 	srl	r3, r3
    7a74:	90630041 	srl	r3, r3
    7a78:	90630041 	srl	r3, r3
    7a7c:	90630041 	srl	r3, r3
    7a80:	90630041 	srl	r3, r3
    7a84:	90630041 	srl	r3, r3
    7a88:	90630041 	srl	r3, r3
    7a8c:	90630041 	srl	r3, r3
    7a90:	90630041 	srl	r3, r3
    7a94:	90630041 	srl	r3, r3
    7a98:	90630041 	srl	r3, r3
    7a9c:	90630041 	srl	r3, r3
    7aa0:	90630041 	srl	r3, r3
    7aa4:	90630041 	srl	r3, r3
    7aa8:	90630041 	srl	r3, r3
    7aac:	90630041 	srl	r3, r3
    7ab0:	60630004 	muli	r3, r3, 4
    7ab4:	b0000000 	imm	0
    7ab8:	3063e920 	addik	r3, r3, -5856
    7abc:	b0000000 	imm	0
    7ac0:	b9f40dc8 	brlid	r15, 3528	// 8888 <strlen>
    7ac4:	e8a30000 	lwi	r5, r3, 0
    7ac8:	be630150 	bleid	r3, 336		// 7c18
    7acc:	30f9ffff 	addik	r7, r25, -1
    7ad0:	14879803 	cmpu	r4, r7, r19
    7ad4:	bca40ba0 	bgei	r4, 2976		// 8674
    7ad8:	b8100010 	brid	16		// 7ae8
    7adc:	10800000 	addk	r4, r0, r0
    7ae0:	14a79803 	cmpu	r5, r7, r19
    7ae4:	bca50b90 	bgei	r5, 2960		// 8674
    7ae8:	e8bb0020 	lwi	r5, r27, 32
    7aec:	10c02800 	addk	r6, r0, r5
    7af0:	90c50001 	sra	r6, r5
    7af4:	90c60001 	sra	r6, r6
    7af8:	90c60001 	sra	r6, r6
    7afc:	90c60001 	sra	r6, r6
    7b00:	90c60001 	sra	r6, r6
    7b04:	90c60001 	sra	r6, r6
    7b08:	90c60001 	sra	r6, r6
    7b0c:	90c60001 	sra	r6, r6
    7b10:	90c60001 	sra	r6, r6
    7b14:	90c60001 	sra	r6, r6
    7b18:	90c60001 	sra	r6, r6
    7b1c:	90c60001 	sra	r6, r6
    7b20:	90c60001 	sra	r6, r6
    7b24:	90c60001 	sra	r6, r6
    7b28:	90c60001 	sra	r6, r6
    7b2c:	90c60001 	sra	r6, r6
    7b30:	90c60001 	sra	r6, r6
    7b34:	90c60001 	sra	r6, r6
    7b38:	90c60001 	sra	r6, r6
    7b3c:	90c60001 	sra	r6, r6
    7b40:	90c60001 	sra	r6, r6
    7b44:	90c60001 	sra	r6, r6
    7b48:	90c60001 	sra	r6, r6
    7b4c:	90c60001 	sra	r6, r6
    7b50:	90c60001 	sra	r6, r6
    7b54:	90c60001 	sra	r6, r6
    7b58:	90c60001 	sra	r6, r6
    7b5c:	90c60001 	sra	r6, r6
    7b60:	90c60001 	sra	r6, r6
    7b64:	90c60001 	sra	r6, r6
    7b68:	90c60001 	sra	r6, r6
    7b6c:	14c53000 	rsubk	r6, r5, r6
    7b70:	10a03000 	addk	r5, r0, r6
    7b74:	90a60041 	srl	r5, r6
    7b78:	90a50041 	srl	r5, r5
    7b7c:	90a50041 	srl	r5, r5
    7b80:	90a50041 	srl	r5, r5
    7b84:	90a50041 	srl	r5, r5
    7b88:	90a50041 	srl	r5, r5
    7b8c:	90a50041 	srl	r5, r5
    7b90:	90a50041 	srl	r5, r5
    7b94:	90a50041 	srl	r5, r5
    7b98:	90a50041 	srl	r5, r5
    7b9c:	90a50041 	srl	r5, r5
    7ba0:	90a50041 	srl	r5, r5
    7ba4:	90a50041 	srl	r5, r5
    7ba8:	90a50041 	srl	r5, r5
    7bac:	90a50041 	srl	r5, r5
    7bb0:	90a50041 	srl	r5, r5
    7bb4:	90a50041 	srl	r5, r5
    7bb8:	90a50041 	srl	r5, r5
    7bbc:	90a50041 	srl	r5, r5
    7bc0:	90a50041 	srl	r5, r5
    7bc4:	90a50041 	srl	r5, r5
    7bc8:	90a50041 	srl	r5, r5
    7bcc:	90a50041 	srl	r5, r5
    7bd0:	90a50041 	srl	r5, r5
    7bd4:	90a50041 	srl	r5, r5
    7bd8:	90a50041 	srl	r5, r5
    7bdc:	90a50041 	srl	r5, r5
    7be0:	90a50041 	srl	r5, r5
    7be4:	90a50041 	srl	r5, r5
    7be8:	90a50041 	srl	r5, r5
    7bec:	90a50041 	srl	r5, r5
    7bf0:	60a50004 	muli	r5, r5, 4
    7bf4:	b0000000 	imm	0
    7bf8:	30a5e920 	addik	r5, r5, -5856
    7bfc:	e8a50000 	lwi	r5, r5, 0
    7c00:	c0a42800 	lbu	r5, r4, r5
    7c04:	30840001 	addik	r4, r4, 1
    7c08:	d0b3c000 	sb	r5, r19, r24
    7c0c:	14a32001 	cmp	r5, r3, r4
    7c10:	be45fed0 	bltid	r5, -304		// 7ae0
    7c14:	32730001 	addik	r19, r19, 1
    7c18:	b0000000 	imm	0
    7c1c:	b9f40fe0 	brlid	r15, 4064	// 8bfc <__tz_unlock>
    7c20:	80000000 	or	r0, r0, r0
    7c24:	b810fd60 	brid	-672		// 7984
    7c28:	e0960000 	lbui	r4, r22, 0
    7c2c:	e87b0018 	lwi	r3, r27, 24
    7c30:	30630018 	addik	r3, r3, 24
    7c34:	60630004 	muli	r3, r3, 4
    7c38:	cae3f800 	lw	r23, r3, r31
    7c3c:	b0000000 	imm	0
    7c40:	b9f40c48 	brlid	r15, 3144	// 8888 <strlen>
    7c44:	10b70000 	addk	r5, r23, r0
    7c48:	be03fd38 	beqid	r3, -712		// 7980
    7c4c:	30b9ffff 	addik	r5, r25, -1
    7c50:	14859803 	cmpu	r4, r5, r19
    7c54:	bca4f9e8 	bgei	r4, -1560		// 763c
    7c58:	10c00000 	addk	r6, r0, r0
    7c5c:	10860000 	addk	r4, r6, r0
    7c60:	c0c6b800 	lbu	r6, r6, r23
    7c64:	30840001 	addik	r4, r4, 1
    7c68:	14e32003 	cmpu	r7, r3, r4
    7c6c:	d0d3c000 	sb	r6, r19, r24
    7c70:	32730001 	addik	r19, r19, 1
    7c74:	bea7fd0c 	bgeid	r7, -756		// 7980
    7c78:	10c40000 	addk	r6, r4, r0
    7c7c:	14e59803 	cmpu	r7, r5, r19
    7c80:	bc47ffe0 	blti	r7, -32		// 7c60
    7c84:	b810f9bc 	brid	-1604		// 7640
    7c88:	12600000 	addk	r19, r0, r0
    7c8c:	aaf70064 	xori	r23, r23, 100
    7c90:	10b89800 	addk	r5, r24, r19
    7c94:	b0000000 	imm	0
    7c98:	30e0dc60 	addik	r7, r0, -9120
    7c9c:	be170010 	beqid	r23, 16		// 7cac
    7ca0:	14d3c800 	rsubk	r6, r19, r25
    7ca4:	b0000000 	imm	0
    7ca8:	30e0dc68 	addik	r7, r0, -9112
    7cac:	b0000000 	imm	0
    7cb0:	b9f41ecc 	brlid	r15, 7884	// 9b7c <sniprintf>
    7cb4:	e91b000c 	lwi	r8, r27, 12
    7cb8:	bea3fcc0 	bgeid	r3, -832		// 7978
    7cbc:	12731800 	addk	r19, r19, r3
    7cc0:	16639800 	rsubk	r19, r3, r19
    7cc4:	b810f97c 	brid	-1668		// 7640
    7cc8:	12600000 	addk	r19, r0, r0
    7ccc:	b9f4f64c 	brlid	r15, -2484	// 7318 <iso_year_adjust>
    7cd0:	10bb0000 	addk	r5, r27, r0
    7cd4:	e8bb0014 	lwi	r5, r27, 20
    7cd8:	be4509dc 	bltid	r5, 2524		// 86b4
    7cdc:	12e30000 	addk	r23, r3, r0
    7ce0:	b0000000 	imm	0
    7ce4:	b9f45354 	brlid	r15, 21332	// d038 <__modsi3>
    7ce8:	30c00064 	addik	r6, r0, 100
    7cec:	be570974 	bltid	r23, 2420		// 8660
    7cf0:	3080f895 	addik	r4, r0, -1899
    7cf4:	be170018 	beqid	r23, 24		// 7d0c
    7cf8:	3080f894 	addik	r4, r0, -1900
    7cfc:	e8bb0014 	lwi	r5, r27, 20
    7d00:	14842801 	cmp	r4, r4, r5
    7d04:	bca40008 	bgei	r4, 8		// 7d0c
    7d08:	32e0ffff 	addik	r23, r0, -1
    7d0c:	10b71800 	addk	r5, r23, r3
    7d10:	b0000000 	imm	0
    7d14:	b9f45324 	brlid	r15, 21284	// d038 <__modsi3>
    7d18:	30c00064 	addik	r6, r0, 100
    7d1c:	30a30064 	addik	r5, r3, 100
    7d20:	30c00064 	addik	r6, r0, 100
    7d24:	13589800 	addk	r26, r24, r19
    7d28:	b0000000 	imm	0
    7d2c:	b9f4530c 	brlid	r15, 21260	// d038 <__modsi3>
    7d30:	16f3c800 	rsubk	r23, r19, r25
    7d34:	b81003e4 	brid	996		// 8118
    7d38:	10ba0000 	addk	r5, r26, r0
    7d3c:	e91b001c 	lwi	r8, r27, 28
    7d40:	b0000000 	imm	0
    7d44:	30e0dc8c 	addik	r7, r0, -9076
    7d48:	10b89800 	addk	r5, r24, r19
    7d4c:	14d3c800 	rsubk	r6, r19, r25
    7d50:	b0000000 	imm	0
    7d54:	b9f41e28 	brlid	r15, 7720	// 9b7c <sniprintf>
    7d58:	31080001 	addik	r8, r8, 1
    7d5c:	bea3fc1c 	bgeid	r3, -996		// 7978
    7d60:	12731800 	addk	r19, r19, r3
    7d64:	16639800 	rsubk	r19, r3, r19
    7d68:	b810f8d8 	brid	-1832		// 7640
    7d6c:	12600000 	addk	r19, r0, r0
    7d70:	e87b0020 	lwi	r3, r27, 32
    7d74:	bc43f9dc 	blti	r3, -1572		// 7750
    7d78:	b0000000 	imm	0
    7d7c:	b9f41480 	brlid	r15, 5248	// 91fc <__gettzinfo>
    7d80:	13989800 	addk	r28, r24, r19
    7d84:	b0000000 	imm	0
    7d88:	b9f40e6c 	brlid	r15, 3692	// 8bf4 <__tz_lock>
    7d8c:	12e30000 	addk	r23, r3, r0
    7d90:	e87b0020 	lwi	r3, r27, 32
    7d94:	1753c800 	rsubk	r26, r19, r25
    7d98:	10801800 	addk	r4, r0, r3
    7d9c:	90830001 	sra	r4, r3
    7da0:	90840001 	sra	r4, r4
    7da4:	90840001 	sra	r4, r4
    7da8:	90840001 	sra	r4, r4
    7dac:	90840001 	sra	r4, r4
    7db0:	90840001 	sra	r4, r4
    7db4:	90840001 	sra	r4, r4
    7db8:	90840001 	sra	r4, r4
    7dbc:	90840001 	sra	r4, r4
    7dc0:	90840001 	sra	r4, r4
    7dc4:	90840001 	sra	r4, r4
    7dc8:	90840001 	sra	r4, r4
    7dcc:	90840001 	sra	r4, r4
    7dd0:	90840001 	sra	r4, r4
    7dd4:	90840001 	sra	r4, r4
    7dd8:	90840001 	sra	r4, r4
    7ddc:	90840001 	sra	r4, r4
    7de0:	90840001 	sra	r4, r4
    7de4:	90840001 	sra	r4, r4
    7de8:	90840001 	sra	r4, r4
    7dec:	90840001 	sra	r4, r4
    7df0:	90840001 	sra	r4, r4
    7df4:	90840001 	sra	r4, r4
    7df8:	90840001 	sra	r4, r4
    7dfc:	90840001 	sra	r4, r4
    7e00:	90840001 	sra	r4, r4
    7e04:	90840001 	sra	r4, r4
    7e08:	90840001 	sra	r4, r4
    7e0c:	90840001 	sra	r4, r4
    7e10:	90840001 	sra	r4, r4
    7e14:	90840001 	sra	r4, r4
    7e18:	14632000 	rsubk	r3, r3, r4
    7e1c:	10801800 	addk	r4, r0, r3
    7e20:	90830041 	srl	r4, r3
    7e24:	90840041 	srl	r4, r4
    7e28:	90840041 	srl	r4, r4
    7e2c:	90840041 	srl	r4, r4
    7e30:	90840041 	srl	r4, r4
    7e34:	90840041 	srl	r4, r4
    7e38:	90840041 	srl	r4, r4
    7e3c:	90840041 	srl	r4, r4
    7e40:	90840041 	srl	r4, r4
    7e44:	90840041 	srl	r4, r4
    7e48:	90840041 	srl	r4, r4
    7e4c:	90840041 	srl	r4, r4
    7e50:	90840041 	srl	r4, r4
    7e54:	90840041 	srl	r4, r4
    7e58:	90840041 	srl	r4, r4
    7e5c:	90840041 	srl	r4, r4
    7e60:	90840041 	srl	r4, r4
    7e64:	90840041 	srl	r4, r4
    7e68:	90840041 	srl	r4, r4
    7e6c:	90840041 	srl	r4, r4
    7e70:	90840041 	srl	r4, r4
    7e74:	90840041 	srl	r4, r4
    7e78:	90840041 	srl	r4, r4
    7e7c:	90840041 	srl	r4, r4
    7e80:	90840041 	srl	r4, r4
    7e84:	90840041 	srl	r4, r4
    7e88:	90840041 	srl	r4, r4
    7e8c:	90840041 	srl	r4, r4
    7e90:	90840041 	srl	r4, r4
    7e94:	90840041 	srl	r4, r4
    7e98:	90840041 	srl	r4, r4
    7e9c:	60640008 	muli	r3, r4, 8
    7ea0:	14841800 	rsubk	r4, r4, r3
    7ea4:	60840004 	muli	r4, r4, 4
    7ea8:	10772000 	addk	r3, r23, r4
    7eac:	b0000000 	imm	0
    7eb0:	b9f40d4c 	brlid	r15, 3404	// 8bfc <__tz_unlock>
    7eb4:	eae30020 	lwi	r23, r3, 32
    7eb8:	30c0003c 	addik	r6, r0, 60
    7ebc:	16f70000 	rsubk	r23, r23, r0
    7ec0:	b0000000 	imm	0
    7ec4:	b9f450d8 	brlid	r15, 20696	// cf9c <__divsi3>
    7ec8:	10b70000 	addk	r5, r23, r0
    7ecc:	b0000000 	imm	0
    7ed0:	b9f4133c 	brlid	r15, 4924	// 920c <labs>
    7ed4:	10a30000 	addk	r5, r3, r0
    7ed8:	10b70000 	addk	r5, r23, r0
    7edc:	13a30000 	addk	r29, r3, r0
    7ee0:	b0000000 	imm	0
    7ee4:	b9f450b8 	brlid	r15, 20664	// cf9c <__divsi3>
    7ee8:	30c00e10 	addik	r6, r0, 3600
    7eec:	10bd0000 	addk	r5, r29, r0
    7ef0:	12e30000 	addk	r23, r3, r0
    7ef4:	b0000000 	imm	0
    7ef8:	b9f45140 	brlid	r15, 20800	// d038 <__modsi3>
    7efc:	30c0003c 	addik	r6, r0, 60
    7f00:	10bc0000 	addk	r5, r28, r0
    7f04:	10da0000 	addk	r6, r26, r0
    7f08:	b0000000 	imm	0
    7f0c:	30e0dcb0 	addik	r7, r0, -9040
    7f10:	11170000 	addk	r8, r23, r0
    7f14:	b0000000 	imm	0
    7f18:	b9f41c64 	brlid	r15, 7268	// 9b7c <sniprintf>
    7f1c:	11230000 	addk	r9, r3, r0
    7f20:	bea3fa58 	bgeid	r3, -1448		// 7978
    7f24:	12731800 	addk	r19, r19, r3
    7f28:	16639800 	rsubk	r19, r3, r19
    7f2c:	b810f714 	brid	-2284		// 7640
    7f30:	12600000 	addk	r19, r0, r0
    7f34:	b0000000 	imm	0
    7f38:	30e0dc60 	addik	r7, r0, -9120
    7f3c:	b810fe0c 	brid	-500		// 7d48
    7f40:	e91b0010 	lwi	r8, r27, 16
    7f44:	3079ffff 	addik	r3, r25, -1
    7f48:	14639803 	cmpu	r3, r3, r19
    7f4c:	bea3f6f0 	bgeid	r3, -2320		// 763c
    7f50:	3060000a 	addik	r3, r0, 10
    7f54:	d073c000 	sb	r3, r19, r24
    7f58:	e0960000 	lbui	r4, r22, 0
    7f5c:	90840060 	sext8	r4, r4
    7f60:	be24f7f0 	bneid	r4, -2064		// 7750
    7f64:	32730001 	addik	r19, r19, 1
    7f68:	b800f7b4 	bri	-2124		// 771c
    7f6c:	eaff00e4 	lwi	r23, r31, 228
    7f70:	b0000000 	imm	0
    7f74:	b9f40914 	brlid	r15, 2324	// 8888 <strlen>
    7f78:	10b70000 	addk	r5, r23, r0
    7f7c:	b810f774 	brid	-2188		// 76f0
    7f80:	e0770000 	lbui	r3, r23, 0
    7f84:	3079ffff 	addik	r3, r25, -1
    7f88:	14639803 	cmpu	r3, r3, r19
    7f8c:	bca3f6b0 	bgei	r3, -2384		// 763c
    7f90:	30800009 	addik	r4, r0, 9
    7f94:	d093c000 	sb	r4, r19, r24
    7f98:	e0960000 	lbui	r4, r22, 0
    7f9c:	90840060 	sext8	r4, r4
    7fa0:	be24f7b0 	bneid	r4, -2128		// 7750
    7fa4:	32730001 	addik	r19, r19, 1
    7fa8:	b800f774 	bri	-2188		// 771c
    7fac:	3079ffff 	addik	r3, r25, -1
    7fb0:	14639803 	cmpu	r3, r3, r19
    7fb4:	bca3f688 	bgei	r3, -2424		// 763c
    7fb8:	e87b0018 	lwi	r3, r27, 24
    7fbc:	be230038 	bneid	r3, 56		// 7ff4
    7fc0:	30630030 	addik	r3, r3, 48
    7fc4:	30600037 	addik	r3, r0, 55
    7fc8:	d073c000 	sb	r3, r19, r24
    7fcc:	e0960000 	lbui	r4, r22, 0
    7fd0:	90840060 	sext8	r4, r4
    7fd4:	be24f77c 	bneid	r4, -2180		// 7750
    7fd8:	32730001 	addik	r19, r19, 1
    7fdc:	b800f740 	bri	-2240		// 771c
    7fe0:	3079ffff 	addik	r3, r25, -1
    7fe4:	14639803 	cmpu	r3, r3, r19
    7fe8:	bca3f654 	bgei	r3, -2476		// 763c
    7fec:	e87b0018 	lwi	r3, r27, 24
    7ff0:	30630030 	addik	r3, r3, 48
    7ff4:	d073c000 	sb	r3, r19, r24
    7ff8:	e0960000 	lbui	r4, r22, 0
    7ffc:	90840060 	sext8	r4, r4
    8000:	be24f750 	bneid	r4, -2224		// 7750
    8004:	32730001 	addik	r19, r19, 1
    8008:	b800f714 	bri	-2284		// 771c
    800c:	eaff009c 	lwi	r23, r31, 156
    8010:	b0000000 	imm	0
    8014:	b9f40874 	brlid	r15, 2164	// 8888 <strlen>
    8018:	10b70000 	addk	r5, r23, r0
    801c:	b810f6d4 	brid	-2348		// 76f0
    8020:	e0770000 	lbui	r3, r23, 0
    8024:	e8bb0014 	lwi	r5, r27, 20
    8028:	bc450700 	blti	r5, 1792		// 8728
    802c:	b0000000 	imm	0
    8030:	b9f45008 	brlid	r15, 20488	// d038 <__modsi3>
    8034:	30c00064 	addik	r6, r0, 100
    8038:	11030000 	addk	r8, r3, r0
    803c:	b0000000 	imm	0
    8040:	30e0dc60 	addik	r7, r0, -9120
    8044:	10b89800 	addk	r5, r24, r19
    8048:	14d3c800 	rsubk	r6, r19, r25
    804c:	b0000000 	imm	0
    8050:	b9f41b2c 	brlid	r15, 6956	// 9b7c <sniprintf>
    8054:	80000000 	or	r0, r0, r0
    8058:	bea3f920 	bgeid	r3, -1760		// 7978
    805c:	12731800 	addk	r19, r19, r3
    8060:	16639800 	rsubk	r19, r3, r19
    8064:	b810f5dc 	brid	-2596		// 7640
    8068:	12600000 	addk	r19, r0, r0
    806c:	b0000000 	imm	0
    8070:	30e0dc94 	addik	r7, r0, -9068
    8074:	e91b0008 	lwi	r8, r27, 8
    8078:	e93b0004 	lwi	r9, r27, 4
    807c:	10b89800 	addk	r5, r24, r19
    8080:	b0000000 	imm	0
    8084:	b9f41af8 	brlid	r15, 6904	// 9b7c <sniprintf>
    8088:	14d3c800 	rsubk	r6, r19, r25
    808c:	bea3f8ec 	bgeid	r3, -1812		// 7978
    8090:	12731800 	addk	r19, r19, r3
    8094:	16639800 	rsubk	r19, r3, r19
    8098:	b810f5a8 	brid	-2648		// 7640
    809c:	12600000 	addk	r19, r0, r0
    80a0:	b0000000 	imm	0
    80a4:	30e0dc60 	addik	r7, r0, -9120
    80a8:	e91b0000 	lwi	r8, r27, 0
    80ac:	10b89800 	addk	r5, r24, r19
    80b0:	b810ff9c 	brid	-100		// 804c
    80b4:	14d3c800 	rsubk	r6, r19, r25
    80b8:	b0000000 	imm	0
    80bc:	30e0dca0 	addik	r7, r0, -9056
    80c0:	e91b0008 	lwi	r8, r27, 8
    80c4:	e93b0004 	lwi	r9, r27, 4
    80c8:	e95b0000 	lwi	r10, r27, 0
    80cc:	10b89800 	addk	r5, r24, r19
    80d0:	b0000000 	imm	0
    80d4:	b9f41aa8 	brlid	r15, 6824	// 9b7c <sniprintf>
    80d8:	14d3c800 	rsubk	r6, r19, r25
    80dc:	bea3f89c 	bgeid	r3, -1892		// 7978
    80e0:	12731800 	addk	r19, r19, r3
    80e4:	16639800 	rsubk	r19, r3, r19
    80e8:	b810f558 	brid	-2728		// 7640
    80ec:	12600000 	addk	r19, r0, r0
    80f0:	e87b001c 	lwi	r3, r27, 28
    80f4:	e8bb0018 	lwi	r5, r27, 24
    80f8:	30c00007 	addik	r6, r0, 7
    80fc:	30630007 	addik	r3, r3, 7
    8100:	14a51800 	rsubk	r5, r5, r3
    8104:	13589800 	addk	r26, r24, r19
    8108:	b0000000 	imm	0
    810c:	b9f44e90 	brlid	r15, 20112	// cf9c <__divsi3>
    8110:	16f3c800 	rsubk	r23, r19, r25
    8114:	10ba0000 	addk	r5, r26, r0
    8118:	10d70000 	addk	r6, r23, r0
    811c:	b0000000 	imm	0
    8120:	30e0dc60 	addik	r7, r0, -9120
    8124:	b0000000 	imm	0
    8128:	b9f41a54 	brlid	r15, 6740	// 9b7c <sniprintf>
    812c:	11030000 	addk	r8, r3, r0
    8130:	bea3f848 	bgeid	r3, -1976		// 7978
    8134:	12731800 	addk	r19, r19, r3
    8138:	16639800 	rsubk	r19, r3, r19
    813c:	b810f504 	brid	-2812		// 7640
    8140:	12600000 	addk	r19, r0, r0
    8144:	b9f4f1d4 	brlid	r15, -3628	// 7318 <iso_year_adjust>
    8148:	10bb0000 	addk	r5, r27, r0
    814c:	e8bb0018 	lwi	r5, r27, 24
    8150:	be05000c 	beqid	r5, 12		// 815c
    8154:	30800006 	addik	r4, r0, 6
    8158:	3085ffff 	addik	r4, r5, -1
    815c:	e8db001c 	lwi	r6, r27, 28
    8160:	be83fedc 	bgtid	r3, -292		// 803c
    8164:	31000001 	addik	r8, r0, 1
    8168:	be23060c 	bneid	r3, 1548		// 8774
    816c:	30a6000a 	addik	r5, r6, 10
    8170:	14a42800 	rsubk	r5, r4, r5
    8174:	b0000000 	imm	0
    8178:	b9f44e24 	brlid	r15, 20004	// cf9c <__divsi3>
    817c:	30c00007 	addik	r6, r0, 7
    8180:	b810febc 	brid	-324		// 803c
    8184:	11030000 	addk	r8, r3, r0
    8188:	e89b0018 	lwi	r4, r27, 24
    818c:	be04000c 	beqid	r4, 12		// 8198
    8190:	30600006 	addik	r3, r0, 6
    8194:	3064ffff 	addik	r3, r4, -1
    8198:	e89b001c 	lwi	r4, r27, 28
    819c:	30c00007 	addik	r6, r0, 7
    81a0:	13589800 	addk	r26, r24, r19
    81a4:	30840007 	addik	r4, r4, 7
    81a8:	14a32000 	rsubk	r5, r3, r4
    81ac:	b0000000 	imm	0
    81b0:	b9f44dec 	brlid	r15, 19948	// cf9c <__divsi3>
    81b4:	16f3c800 	rsubk	r23, r19, r25
    81b8:	b810ff60 	brid	-160		// 8118
    81bc:	10ba0000 	addk	r5, r26, r0
    81c0:	eaff0098 	lwi	r23, r31, 152
    81c4:	b0000000 	imm	0
    81c8:	b9f406c0 	brlid	r15, 1728	// 8888 <strlen>
    81cc:	10b70000 	addk	r5, r23, r0
    81d0:	b810f520 	brid	-2784		// 76f0
    81d4:	e0770000 	lbui	r3, r23, 0
    81d8:	eafb0014 	lwi	r23, r27, 20
    81dc:	3060f894 	addik	r3, r0, -1900
    81e0:	1463b801 	cmp	r3, r3, r23
    81e4:	bea30404 	bgeid	r3, 1028		// 85e8
    81e8:	32f7076c 	addik	r23, r23, 1900
    81ec:	3060002d 	addik	r3, r0, 45
    81f0:	f0610020 	sbi	r3, r1, 32
    81f4:	16f70000 	rsubk	r23, r23, r0
    81f8:	be1d000c 	beqid	r29, 12		// 8204
    81fc:	30a10021 	addik	r5, r1, 33
    8200:	33bdffff 	addik	r29, r29, -1
    8204:	30600025 	addik	r3, r0, 37
    8208:	be3a0388 	bneid	r26, 904		// 8590
    820c:	f0650000 	sbi	r3, r5, 0
    8210:	30a50001 	addik	r5, r5, 1
    8214:	b0000000 	imm	0
    8218:	30c0dc88 	addik	r6, r0, -9080
    821c:	b0000000 	imm	0
    8220:	b9f41d44 	brlid	r15, 7492	// 9f64 <strcpy>
    8224:	80000000 	or	r0, r0, r0
    8228:	111d0000 	addk	r8, r29, r0
    822c:	11370000 	addk	r9, r23, r0
    8230:	30e10020 	addik	r7, r1, 32
    8234:	10b89800 	addk	r5, r24, r19
    8238:	b0000000 	imm	0
    823c:	b9f41940 	brlid	r15, 6464	// 9b7c <sniprintf>
    8240:	14d3c800 	rsubk	r6, r19, r25
    8244:	bea3f734 	bgeid	r3, -2252		// 7978
    8248:	12731800 	addk	r19, r19, r3
    824c:	16639800 	rsubk	r19, r3, r19
    8250:	b810f3f0 	brid	-3088		// 7640
    8254:	12600000 	addk	r19, r0, r0
    8258:	aaf7006b 	xori	r23, r23, 107
    825c:	10b89800 	addk	r5, r24, r19
    8260:	b0000000 	imm	0
    8264:	30e0dc68 	addik	r7, r0, -9112
    8268:	be170010 	beqid	r23, 16		// 8278
    826c:	14d3c800 	rsubk	r6, r19, r25
    8270:	b0000000 	imm	0
    8274:	30e0dc60 	addik	r7, r0, -9120
    8278:	b0000000 	imm	0
    827c:	b9f41900 	brlid	r15, 6400	// 9b7c <sniprintf>
    8280:	e91b0008 	lwi	r8, r27, 8
    8284:	bea3f6f4 	bgeid	r3, -2316		// 7978
    8288:	12731800 	addk	r19, r19, r3
    828c:	16639800 	rsubk	r19, r3, r19
    8290:	b810f3b0 	brid	-3152		// 7640
    8294:	12600000 	addk	r19, r0, r0
    8298:	30600025 	addik	r3, r0, 37
    829c:	be1a0318 	beqid	r26, 792		// 85b4
    82a0:	f0610020 	sbi	r3, r1, 32
    82a4:	30600005 	addik	r3, r0, 5
    82a8:	f3410021 	sbi	r26, r1, 33
    82ac:	147d1803 	cmpu	r3, r29, r3
    82b0:	be4305cc 	bltid	r3, 1484		// 887c
    82b4:	30a10022 	addik	r5, r1, 34
    82b8:	b0000000 	imm	0
    82bc:	30c0dc80 	addik	r6, r0, -9088
    82c0:	b0000000 	imm	0
    82c4:	b9f41ca0 	brlid	r15, 7328	// 9f64 <strcpy>
    82c8:	80000000 	or	r0, r0, r0
    82cc:	b810f42c 	brid	-3028		// 76f8
    82d0:	30e10020 	addik	r7, r1, 32
    82d4:	eafb0014 	lwi	r23, r27, 20
    82d8:	b9f4f040 	brlid	r15, -4032	// 7318 <iso_year_adjust>
    82dc:	10bb0000 	addk	r5, r27, r0
    82e0:	be5703e8 	bltid	r23, 1000		// 86c8
    82e4:	10b70000 	addk	r5, r23, r0
    82e8:	30c00064 	addik	r6, r0, 100
    82ec:	b0000000 	imm	0
    82f0:	b9f44cac 	brlid	r15, 19628	// cf9c <__divsi3>
    82f4:	f8610044 	swi	r3, r1, 68
    82f8:	10b70000 	addk	r5, r23, r0
    82fc:	e8810044 	lwi	r4, r1, 68
    8300:	30e30013 	addik	r7, r3, 19
    8304:	30c00064 	addik	r6, r0, 100
    8308:	f8810044 	swi	r4, r1, 68
    830c:	b0000000 	imm	0
    8310:	b9f44d28 	brlid	r15, 19752	// d038 <__modsi3>
    8314:	f8e10040 	swi	r7, r1, 64
    8318:	e8810044 	lwi	r4, r1, 68
    831c:	e8e10040 	lwi	r7, r1, 64
    8320:	be440328 	bltid	r4, 808		// 8648
    8324:	30a0f895 	addik	r5, r0, -1899
    8328:	30a0f894 	addik	r5, r0, -1900
    832c:	16e5b801 	cmp	r23, r5, r23
    8330:	10a0b800 	addk	r5, r0, r23
    8334:	90b70041 	srl	r5, r23
    8338:	90a50041 	srl	r5, r5
    833c:	90a50041 	srl	r5, r5
    8340:	90a50041 	srl	r5, r5
    8344:	90a50041 	srl	r5, r5
    8348:	90a50041 	srl	r5, r5
    834c:	90a50041 	srl	r5, r5
    8350:	90a50041 	srl	r5, r5
    8354:	90a50041 	srl	r5, r5
    8358:	90a50041 	srl	r5, r5
    835c:	90a50041 	srl	r5, r5
    8360:	90a50041 	srl	r5, r5
    8364:	90a50041 	srl	r5, r5
    8368:	90a50041 	srl	r5, r5
    836c:	90a50041 	srl	r5, r5
    8370:	90a50041 	srl	r5, r5
    8374:	90a50041 	srl	r5, r5
    8378:	90a50041 	srl	r5, r5
    837c:	90a50041 	srl	r5, r5
    8380:	90a50041 	srl	r5, r5
    8384:	90a50041 	srl	r5, r5
    8388:	90a50041 	srl	r5, r5
    838c:	90a50041 	srl	r5, r5
    8390:	90a50041 	srl	r5, r5
    8394:	90a50041 	srl	r5, r5
    8398:	90a50041 	srl	r5, r5
    839c:	90a50041 	srl	r5, r5
    83a0:	90a50041 	srl	r5, r5
    83a4:	90a50041 	srl	r5, r5
    83a8:	90a50041 	srl	r5, r5
    83ac:	90a50041 	srl	r5, r5
    83b0:	bc640008 	blei	r4, 8		// 83b8
    83b4:	bc2501d0 	bnei	r5, 464		// 8584
    83b8:	10841800 	addk	r4, r4, r3
    83bc:	a864ffff 	xori	r3, r4, -1
    83c0:	be030274 	beqid	r3, 628		// 8634
    83c4:	a8640064 	xori	r3, r4, 100
    83c8:	bc0302e0 	beqi	r3, 736		// 86a8
    83cc:	60e70064 	muli	r7, r7, 100
    83d0:	be0501d0 	beqid	r5, 464		// 85a0
    83d4:	12e72000 	addk	r23, r7, r4
    83d8:	3060002d 	addik	r3, r0, 45
    83dc:	b810fe1c 	brid	-484		// 81f8
    83e0:	f0610020 	sbi	r3, r1, 32
    83e4:	b0000000 	imm	0
    83e8:	30e0dc60 	addik	r7, r0, -9120
    83ec:	e91b0004 	lwi	r8, r27, 4
    83f0:	10b89800 	addk	r5, r24, r19
    83f4:	b0000000 	imm	0
    83f8:	b9f41784 	brlid	r15, 6020	// 9b7c <sniprintf>
    83fc:	14d3c800 	rsubk	r6, r19, r25
    8400:	bea3f578 	bgeid	r3, -2696		// 7978
    8404:	12731800 	addk	r19, r19, r3
    8408:	16639800 	rsubk	r19, r3, r19
    840c:	b810f234 	brid	-3532		// 7640
    8410:	12600000 	addk	r19, r0, r0
    8414:	e89b0008 	lwi	r4, r27, 8
    8418:	3060000b 	addik	r3, r0, 11
    841c:	14841801 	cmp	r4, r4, r3
    8420:	10602000 	addk	r3, r0, r4
    8424:	90640041 	srl	r3, r4
    8428:	90630041 	srl	r3, r3
    842c:	90630041 	srl	r3, r3
    8430:	90630041 	srl	r3, r3
    8434:	90630041 	srl	r3, r3
    8438:	90630041 	srl	r3, r3
    843c:	90630041 	srl	r3, r3
    8440:	90630041 	srl	r3, r3
    8444:	90630041 	srl	r3, r3
    8448:	90630041 	srl	r3, r3
    844c:	90630041 	srl	r3, r3
    8450:	90630041 	srl	r3, r3
    8454:	90630041 	srl	r3, r3
    8458:	90630041 	srl	r3, r3
    845c:	90630041 	srl	r3, r3
    8460:	90630041 	srl	r3, r3
    8464:	90630041 	srl	r3, r3
    8468:	90630041 	srl	r3, r3
    846c:	90630041 	srl	r3, r3
    8470:	90630041 	srl	r3, r3
    8474:	90630041 	srl	r3, r3
    8478:	90630041 	srl	r3, r3
    847c:	90630041 	srl	r3, r3
    8480:	90630041 	srl	r3, r3
    8484:	90630041 	srl	r3, r3
    8488:	90630041 	srl	r3, r3
    848c:	90630041 	srl	r3, r3
    8490:	90630041 	srl	r3, r3
    8494:	90630041 	srl	r3, r3
    8498:	90630041 	srl	r3, r3
    849c:	90630041 	srl	r3, r3
    84a0:	30630029 	addik	r3, r3, 41
    84a4:	60630004 	muli	r3, r3, 4
    84a8:	cae3f800 	lw	r23, r3, r31
    84ac:	b0000000 	imm	0
    84b0:	b9f403d8 	brlid	r15, 984	// 8888 <strlen>
    84b4:	10b70000 	addk	r5, r23, r0
    84b8:	be03f4c8 	beqid	r3, -2872		// 7980
    84bc:	30b9ffff 	addik	r5, r25, -1
    84c0:	14859803 	cmpu	r4, r5, r19
    84c4:	bca4f178 	bgei	r4, -3720		// 763c
    84c8:	10c00000 	addk	r6, r0, r0
    84cc:	b810002c 	brid	44		// 84f8
    84d0:	10860000 	addk	r4, r6, r0
    84d4:	90c60060 	sext8	r6, r6
    84d8:	30840001 	addik	r4, r4, 1
    84dc:	f0c70000 	sbi	r6, r7, 0
    84e0:	14e32003 	cmpu	r7, r3, r4
    84e4:	32730001 	addik	r19, r19, 1
    84e8:	bea7f498 	bgeid	r7, -2920		// 7980
    84ec:	10c40000 	addk	r6, r4, r0
    84f0:	14e59803 	cmpu	r7, r5, r19
    84f4:	bca7f148 	bgei	r7, -3768		// 763c
    84f8:	e1160000 	lbui	r8, r22, 0
    84fc:	10f89800 	addk	r7, r24, r19
    8500:	91080060 	sext8	r8, r8
    8504:	a9080050 	xori	r8, r8, 80
    8508:	be28ffcc 	bneid	r8, -52		// 84d4
    850c:	c0c6b800 	lbu	r6, r6, r23
    8510:	b0000000 	imm	0
    8514:	e900e50c 	lwi	r8, r0, -6900	// e50c <__ctype_ptr__>
    8518:	11083000 	addk	r8, r8, r6
    851c:	e1080001 	lbui	r8, r8, 1
    8520:	a5080003 	andi	r8, r8, 3
    8524:	a9080001 	xori	r8, r8, 1
    8528:	bc28ffac 	bnei	r8, -84		// 84d4
    852c:	b810ffa8 	brid	-88		// 84d4
    8530:	30c60020 	addik	r6, r6, 32
    8534:	e8bb0008 	lwi	r5, r27, 8
    8538:	30c0000c 	addik	r6, r0, 12
    853c:	8c653400 	pcmpne	r3, r5, r6
    8540:	be030020 	beqid	r3, 32		// 8560
    8544:	3100000c 	addik	r8, r0, 12
    8548:	8c65f400 	pcmpne	r3, r5, r30
    854c:	bc030014 	beqi	r3, 20		// 8560
    8550:	b0000000 	imm	0
    8554:	b9f44ae4 	brlid	r15, 19172	// d038 <__modsi3>
    8558:	80000000 	or	r0, r0, r0
    855c:	11030000 	addk	r8, r3, r0
    8560:	aaf70049 	xori	r23, r23, 73
    8564:	10b89800 	addk	r5, r24, r19
    8568:	b0000000 	imm	0
    856c:	30e0dc60 	addik	r7, r0, -9120
    8570:	be17fadc 	beqid	r23, -1316		// 804c
    8574:	14d3c800 	rsubk	r6, r19, r25
    8578:	b0000000 	imm	0
    857c:	30e0dc68 	addik	r7, r0, -9112
    8580:	b800facc 	bri	-1332		// 804c
    8584:	3080ffff 	addik	r4, r0, -1
    8588:	b810fe30 	brid	-464		// 83b8
    858c:	30a00001 	addik	r5, r0, 1
    8590:	30800030 	addik	r4, r0, 48
    8594:	f0850001 	sbi	r4, r5, 1
    8598:	b810fc7c 	brid	-900		// 8214
    859c:	30a50002 	addik	r5, r5, 2
    85a0:	3060270f 	addik	r3, r0, 9999
    85a4:	14771803 	cmpu	r3, r23, r3
    85a8:	be43007c 	bltid	r3, 124		// 8624
    85ac:	30a10020 	addik	r5, r1, 32
    85b0:	b800fc54 	bri	-940		// 8204
    85b4:	3080002b 	addik	r4, r0, 43
    85b8:	f0810021 	sbi	r4, r1, 33
    85bc:	31000004 	addik	r8, r0, 4
    85c0:	b0000000 	imm	0
    85c4:	30e0dc7c 	addik	r7, r0, -9092
    85c8:	30a10022 	addik	r5, r1, 34
    85cc:	b0000000 	imm	0
    85d0:	b9f415ac 	brlid	r15, 5548	// 9b7c <sniprintf>
    85d4:	30c0001e 	addik	r6, r0, 30
    85d8:	be63fce0 	bleid	r3, -800		// 82b8
    85dc:	30a10022 	addik	r5, r1, 34
    85e0:	b810fcd8 	brid	-808		// 82b8
    85e4:	10a51800 	addk	r5, r5, r3
    85e8:	be1cfc1c 	beqid	r28, -996		// 8204
    85ec:	30a10020 	addik	r5, r1, 32
    85f0:	3060270f 	addik	r3, r0, 9999
    85f4:	14771803 	cmpu	r3, r23, r3
    85f8:	bea3fc10 	bgeid	r3, -1008		// 8208
    85fc:	30600025 	addik	r3, r0, 37
    8600:	3080002b 	addik	r4, r0, 43
    8604:	b810fbf4 	brid	-1036		// 81f8
    8608:	f0810020 	sbi	r4, r1, 32
    860c:	b0000000 	imm	0
    8610:	3100dc44 	addik	r8, r0, -9148
    8614:	b0000000 	imm	0
    8618:	30e0dc48 	addik	r7, r0, -9144
    861c:	b810f2c8 	brid	-3384		// 78e4
    8620:	30800001 	addik	r4, r0, 1
    8624:	be3cffe0 	bneid	r28, -32		// 8604
    8628:	3080002b 	addik	r4, r0, 43
    862c:	b810fbd8 	brid	-1064		// 8204
    8630:	30a10020 	addik	r5, r1, 32
    8634:	30e7ffff 	addik	r7, r7, -1
    8638:	b810fd94 	brid	-620		// 83cc
    863c:	30800063 	addik	r4, r0, 99
    8640:	b810f2ac 	brid	-3412		// 78ec
    8644:	33a00002 	addik	r29, r0, 2
    8648:	e8db0014 	lwi	r6, r27, 20
    864c:	14a53001 	cmp	r5, r5, r6
    8650:	bca5fcd8 	bgei	r5, -808		// 8328
    8654:	30800001 	addik	r4, r0, 1
    8658:	b810fd60 	brid	-672		// 83b8
    865c:	10a40000 	addk	r5, r4, r0
    8660:	e8bb0014 	lwi	r5, r27, 20
    8664:	14842801 	cmp	r4, r4, r5
    8668:	bca4f6a4 	bgei	r4, -2396		// 7d0c
    866c:	b810f6a0 	brid	-2400		// 7d0c
    8670:	32e00001 	addik	r23, r0, 1
    8674:	b0000000 	imm	0
    8678:	b9f40584 	brlid	r15, 1412	// 8bfc <__tz_unlock>
    867c:	12600000 	addk	r19, r0, r0
    8680:	b810efc4 	brid	-4156		// 7644
    8684:	10730000 	addk	r3, r19, r0
    8688:	be1cf248 	beqid	r28, -3512		// 78d0
    868c:	30800001 	addik	r4, r0, 1
    8690:	b0000000 	imm	0
    8694:	3100dc58 	addik	r8, r0, -9128
    8698:	b0000000 	imm	0
    869c:	30e0dc50 	addik	r7, r0, -9136
    86a0:	b810f248 	brid	-3512		// 78e8
    86a4:	147d2003 	cmpu	r3, r29, r4
    86a8:	10830000 	addk	r4, r3, r0
    86ac:	b810fd20 	brid	-736		// 83cc
    86b0:	30e70001 	addik	r7, r7, 1
    86b4:	b0000000 	imm	0
    86b8:	b9f4054c 	brlid	r15, 1356	// 8c04 <abs>
    86bc:	30a5076c 	addik	r5, r5, 1900
    86c0:	b810f620 	brid	-2528		// 7ce0
    86c4:	10a30000 	addk	r5, r3, r0
    86c8:	30b7076c 	addik	r5, r23, 1900
    86cc:	b0000000 	imm	0
    86d0:	b9f40534 	brlid	r15, 1332	// 8c04 <abs>
    86d4:	f8610044 	swi	r3, r1, 68
    86d8:	10a30000 	addk	r5, r3, r0
    86dc:	b0000000 	imm	0
    86e0:	b9f448bc 	brlid	r15, 18620	// cf9c <__divsi3>
    86e4:	30c00064 	addik	r6, r0, 100
    86e8:	e8bb0014 	lwi	r5, r27, 20
    86ec:	10e30000 	addk	r7, r3, r0
    86f0:	bea5fc14 	bgeid	r5, -1004		// 8304
    86f4:	e8810044 	lwi	r4, r1, 68
    86f8:	30a5076c 	addik	r5, r5, 1900
    86fc:	f8810044 	swi	r4, r1, 68
    8700:	b0000000 	imm	0
    8704:	b9f40500 	brlid	r15, 1280	// 8c04 <abs>
    8708:	f8610040 	swi	r3, r1, 64
    870c:	10a30000 	addk	r5, r3, r0
    8710:	b0000000 	imm	0
    8714:	b9f44924 	brlid	r15, 18724	// d038 <__modsi3>
    8718:	30c00064 	addik	r6, r0, 100
    871c:	e8e10040 	lwi	r7, r1, 64
    8720:	b810fc00 	brid	-1024		// 8320
    8724:	e8810044 	lwi	r4, r1, 68
    8728:	b0000000 	imm	0
    872c:	b9f404d8 	brlid	r15, 1240	// 8c04 <abs>
    8730:	30a5076c 	addik	r5, r5, 1900
    8734:	b810f8f8 	brid	-1800		// 802c
    8738:	10a30000 	addk	r5, r3, r0
    873c:	b0000000 	imm	0
    8740:	b9f404c4 	brlid	r15, 1220	// 8c04 <abs>
    8744:	30a3076c 	addik	r5, r3, 1900
    8748:	b810f1f8 	brid	-3592		// 7940
    874c:	10a30000 	addk	r5, r3, r0
    8750:	b0000000 	imm	0
    8754:	b9f404b0 	brlid	r15, 1200	// 8c04 <abs>
    8758:	30a5076c 	addik	r5, r5, 1900
    875c:	10a30000 	addk	r5, r3, r0
    8760:	b0000000 	imm	0
    8764:	b9f44838 	brlid	r15, 18488	// cf9c <__divsi3>
    8768:	30c00064 	addik	r6, r0, 100
    876c:	b810f154 	brid	-3756		// 78c0
    8770:	11430000 	addk	r10, r3, r0
    8774:	eafb0014 	lwi	r23, r27, 20
    8778:	17462000 	rsubk	r26, r6, r4
    877c:	be5700e8 	bltid	r23, 232		// 8864
    8780:	3060ff9b 	addik	r3, r0, -101
    8784:	10771800 	addk	r3, r23, r3
    8788:	a4630003 	andi	r3, r3, 3
    878c:	bc230024 	bnei	r3, 36		// 87b0
    8790:	be5700e4 	bltid	r23, 228		// 8874
    8794:	30a0ff9b 	addik	r5, r0, -101
    8798:	10a5b800 	addk	r5, r5, r23
    879c:	b0000000 	imm	0
    87a0:	b9f44898 	brlid	r15, 18584	// d038 <__modsi3>
    87a4:	30c00064 	addik	r6, r0, 100
    87a8:	be230024 	bneid	r3, 36		// 87cc
    87ac:	30a00001 	addik	r5, r0, 1
    87b0:	be5700bc 	bltid	r23, 188		// 886c
    87b4:	30a0ff9b 	addik	r5, r0, -101
    87b8:	10a5b800 	addk	r5, r5, r23
    87bc:	b0000000 	imm	0
    87c0:	b9f44878 	brlid	r15, 18552	// d038 <__modsi3>
    87c4:	30c00190 	addik	r6, r0, 400
    87c8:	88a3f400 	pcmpeq	r5, r3, r30
    87cc:	14a5d000 	rsubk	r5, r5, r26
    87d0:	30600004 	addik	r3, r0, 4
    87d4:	14651801 	cmp	r3, r5, r3
    87d8:	30800035 	addik	r4, r0, 53
    87dc:	11001800 	addk	r8, r0, r3
    87e0:	91030041 	srl	r8, r3
    87e4:	91080041 	srl	r8, r8
    87e8:	91080041 	srl	r8, r8
    87ec:	91080041 	srl	r8, r8
    87f0:	91080041 	srl	r8, r8
    87f4:	91080041 	srl	r8, r8
    87f8:	91080041 	srl	r8, r8
    87fc:	91080041 	srl	r8, r8
    8800:	91080041 	srl	r8, r8
    8804:	91080041 	srl	r8, r8
    8808:	91080041 	srl	r8, r8
    880c:	91080041 	srl	r8, r8
    8810:	91080041 	srl	r8, r8
    8814:	91080041 	srl	r8, r8
    8818:	91080041 	srl	r8, r8
    881c:	91080041 	srl	r8, r8
    8820:	91080041 	srl	r8, r8
    8824:	91080041 	srl	r8, r8
    8828:	91080041 	srl	r8, r8
    882c:	91080041 	srl	r8, r8
    8830:	91080041 	srl	r8, r8
    8834:	91080041 	srl	r8, r8
    8838:	91080041 	srl	r8, r8
    883c:	91080041 	srl	r8, r8
    8840:	91080041 	srl	r8, r8
    8844:	91080041 	srl	r8, r8
    8848:	91080041 	srl	r8, r8
    884c:	91080041 	srl	r8, r8
    8850:	91080041 	srl	r8, r8
    8854:	91080041 	srl	r8, r8
    8858:	91080041 	srl	r8, r8
    885c:	b810f7e0 	brid	-2080		// 803c
    8860:	15082000 	rsubk	r8, r8, r4
    8864:	b810ff20 	brid	-224		// 8784
    8868:	3060076b 	addik	r3, r0, 1899
    886c:	b810ff4c 	brid	-180		// 87b8
    8870:	30a0076b 	addik	r5, r0, 1899
    8874:	b810ff24 	brid	-220		// 8798
    8878:	30a0076b 	addik	r5, r0, 1899
    887c:	311dfffa 	addik	r8, r29, -6
    8880:	bc08fa38 	beqi	r8, -1480		// 82b8
    8884:	b800fd3c 	bri	-708		// 85c0

00008888 <strlen>:
    8888:	81200000 	or	r9, r0, r0

0000888c <check_alignment>:
    888c:	a4650003 	andi	r3, r5, 3
    8890:	bc230030 	bnei	r3, 48	// 88c0 <align_arg>

00008894 <len_loop>:
    8894:	c8654a00 	lwr	r3, r5, r9
    8898:	80830400 	pcmpbf	r4, r3, r0
    889c:	bc24000c 	bnei	r4, 12	// 88a8 <end_len>
    88a0:	b810fff4 	brid	-12	// 8894 <len_loop>
    88a4:	31290004 	addik	r9, r9, 4

000088a8 <end_len>:
    88a8:	c0654800 	lbu	r3, r5, r9
    88ac:	bc03000c 	beqi	r3, 12	// 88b8 <done_len>
    88b0:	b810fff8 	brid	-8	// 88a8 <end_len>
    88b4:	31290001 	addik	r9, r9, 1

000088b8 <done_len>:
    88b8:	b60f0008 	rtsd	r15, 8
    88bc:	80604800 	or	r3, r0, r9

000088c0 <align_arg>:
    88c0:	35430004 	rsubik	r10, r3, 4

000088c4 <align_loop>:
    88c4:	c0654800 	lbu	r3, r5, r9
    88c8:	be03fff0 	beqid	r3, -16	// 88b8 <done_len>
    88cc:	314affff 	addik	r10, r10, -1
    88d0:	be2afff4 	bneid	r10, -12	// 88c4 <align_loop>
    88d4:	31290001 	addik	r9, r9, 1
    88d8:	b800ffbc 	bri	-68	// 8894 <len_loop>
    88dc:	b60f0008 	rtsd	r15, 8
    88e0:	80000000 	or	r0, r0, r0

000088e4 <_strtoul_r>:
    88e4:	3021ffbc 	addik	r1, r1, -68
    88e8:	fae10024 	swi	r23, r1, 36
    88ec:	fb21002c 	swi	r25, r1, 44
    88f0:	fb610034 	swi	r27, r1, 52
    88f4:	fb810038 	swi	r28, r1, 56
    88f8:	fbc10040 	swi	r30, r1, 64
    88fc:	f9e10000 	swi	r15, r1, 0
    8900:	fa61001c 	swi	r19, r1, 28
    8904:	fac10020 	swi	r22, r1, 32
    8908:	fb010028 	swi	r24, r1, 40
    890c:	fb410030 	swi	r26, r1, 48
    8910:	fba1003c 	swi	r29, r1, 60
    8914:	13660000 	addk	r27, r6, r0
    8918:	13c50000 	addk	r30, r5, r0
    891c:	13870000 	addk	r28, r7, r0
    8920:	12e80000 	addk	r23, r8, r0
    8924:	b0000000 	imm	0
    8928:	eb20e50c 	lwi	r25, r0, -6900	// e50c <__ctype_ptr__>
    892c:	b810000c 	brid	12		// 8938
    8930:	10660000 	addk	r3, r6, r0
    8934:	10760000 	addk	r3, r22, r0
    8938:	e2630000 	lbui	r19, r3, 0
    893c:	10999800 	addk	r4, r25, r19
    8940:	e0840001 	lbui	r4, r4, 1
    8944:	a4840008 	andi	r4, r4, 8
    8948:	be24ffec 	bneid	r4, -20		// 8934
    894c:	32c30001 	addik	r22, r3, 1
    8950:	a8d3002d 	xori	r6, r19, 45
    8954:	be06018c 	beqid	r6, 396		// 8ae0
    8958:	a8b3002b 	xori	r5, r19, 43
    895c:	be050194 	beqid	r5, 404		// 8af0
    8960:	13a40000 	addk	r29, r4, r0
    8964:	30600010 	addik	r3, r0, 16	// 10 <_vector_interrupt>
    8968:	10c00000 	addk	r6, r0, r0
    896c:	88771c00 	pcmpeq	r3, r23, r3
    8970:	be23010c 	bneid	r3, 268		// 8a7c
    8974:	88d73400 	pcmpeq	r6, r23, r6
    8978:	bc260104 	bnei	r6, 260		// 8a7c
    897c:	10d70000 	addk	r6, r23, r0
    8980:	30a0ffff 	addik	r5, r0, -1
    8984:	b0000000 	imm	0
    8988:	b9f4474c 	brlid	r15, 18252	// d0d4 <__udivsi3>
    898c:	13570000 	addk	r26, r23, r0
    8990:	10d70000 	addk	r6, r23, r0
    8994:	30a0ffff 	addik	r5, r0, -1
    8998:	b0000000 	imm	0
    899c:	b9f447e0 	brlid	r15, 18400	// d17c <__umodsi3>
    89a0:	13030000 	addk	r24, r3, r0
    89a4:	10800000 	addk	r4, r0, r0
    89a8:	b8100040 	brid	64		// 89e8
    89ac:	11240000 	addk	r9, r4, r0
    89b0:	3273ffd0 	addik	r19, r19, -48
    89b4:	15179801 	cmp	r8, r23, r19
    89b8:	bea80064 	bgeid	r8, 100		// 8a1c
    89bc:	1509c003 	cmpu	r8, r9, r24
    89c0:	bc4800e8 	blti	r8, 232		// 8aa8
    89c4:	be4400e4 	bltid	r4, 228		// 8aa8
    89c8:	15131801 	cmp	r8, r19, r3
    89cc:	be4800e4 	bltid	r8, 228		// 8ab0
    89d0:	8909c400 	pcmpeq	r8, r9, r24
    89d4:	4129d000 	mul	r9, r9, r26
    89d8:	30800001 	addik	r4, r0, 1
    89dc:	11334800 	addk	r9, r19, r9
    89e0:	e2760000 	lbui	r19, r22, 0
    89e4:	32d60001 	addik	r22, r22, 1
    89e8:	11199800 	addk	r8, r25, r19
    89ec:	e1080001 	lbui	r8, r8, 1
    89f0:	a5480004 	andi	r10, r8, 4
    89f4:	be2affbc 	bneid	r10, -68		// 89b0
    89f8:	a5080003 	andi	r8, r8, 3
    89fc:	be080020 	beqid	r8, 32		// 8a1c
    8a00:	a9080001 	xori	r8, r8, 1
    8a04:	be08006c 	beqid	r8, 108		// 8a70
    8a08:	31400057 	addik	r10, r0, 87
    8a0c:	166a9800 	rsubk	r19, r10, r19
    8a10:	15179801 	cmp	r8, r23, r19
    8a14:	be48ffac 	bltid	r8, -84		// 89c0
    8a18:	1509c003 	cmpu	r8, r9, r24
    8a1c:	a864ffff 	xori	r3, r4, -1
    8a20:	bc0300b0 	beqi	r3, 176		// 8ad0
    8a24:	bc3d00a4 	bnei	r29, 164		// 8ac8
    8a28:	be1c0014 	beqid	r28, 20		// 8a3c
    8a2c:	10690000 	addk	r3, r9, r0
    8a30:	bc240090 	bnei	r4, 144		// 8ac0
    8a34:	fb7c0000 	swi	r27, r28, 0
    8a38:	10690000 	addk	r3, r9, r0
    8a3c:	e9e10000 	lwi	r15, r1, 0
    8a40:	ea61001c 	lwi	r19, r1, 28
    8a44:	eac10020 	lwi	r22, r1, 32
    8a48:	eae10024 	lwi	r23, r1, 36
    8a4c:	eb010028 	lwi	r24, r1, 40
    8a50:	eb21002c 	lwi	r25, r1, 44
    8a54:	eb410030 	lwi	r26, r1, 48
    8a58:	eb610034 	lwi	r27, r1, 52
    8a5c:	eb810038 	lwi	r28, r1, 56
    8a60:	eba1003c 	lwi	r29, r1, 60
    8a64:	ebc10040 	lwi	r30, r1, 64
    8a68:	b60f0008 	rtsd	r15, 8
    8a6c:	30210044 	addik	r1, r1, 68
    8a70:	31400037 	addik	r10, r0, 55
    8a74:	b810ff9c 	brid	-100		// 8a10
    8a78:	166a9800 	rsubk	r19, r10, r19
    8a7c:	a8730030 	xori	r3, r19, 48
    8a80:	be03007c 	beqid	r3, 124		// 8afc
    8a84:	30a00058 	addik	r5, r0, 88
    8a88:	bc06fef4 	beqi	r6, -268		// 897c
    8a8c:	bc0300a8 	beqi	r3, 168		// 8b34
    8a90:	32e0000a 	addik	r23, r0, 10
    8a94:	b0001999 	imm	6553
    8a98:	33009999 	addik	r24, r0, -26215
    8a9c:	13570000 	addk	r26, r23, r0
    8aa0:	b810ff04 	brid	-252		// 89a4
    8aa4:	30600005 	addik	r3, r0, 5
    8aa8:	b810ff38 	brid	-200		// 89e0
    8aac:	3080ffff 	addik	r4, r0, -1
    8ab0:	be28ff30 	bneid	r8, -208		// 89e0
    8ab4:	3080ffff 	addik	r4, r0, -1
    8ab8:	b810ff20 	brid	-224		// 89d8
    8abc:	4129d000 	mul	r9, r9, r26
    8ac0:	b810ff74 	brid	-140		// 8a34
    8ac4:	3376ffff 	addik	r27, r22, -1
    8ac8:	b810ff60 	brid	-160		// 8a28
    8acc:	15290000 	rsubk	r9, r9, r0
    8ad0:	30600022 	addik	r3, r0, 34
    8ad4:	f87e0000 	swi	r3, r30, 0
    8ad8:	b810ff50 	brid	-176		// 8a28
    8adc:	3120ffff 	addik	r9, r0, -1
    8ae0:	e2630001 	lbui	r19, r3, 1
    8ae4:	32c30002 	addik	r22, r3, 2
    8ae8:	b810fe7c 	brid	-388		// 8964
    8aec:	33a00001 	addik	r29, r0, 1
    8af0:	e2630001 	lbui	r19, r3, 1
    8af4:	b810fe70 	brid	-400		// 8964
    8af8:	32c30002 	addik	r22, r3, 2
    8afc:	e0960000 	lbui	r4, r22, 0
    8b00:	88a42c00 	pcmpeq	r5, r4, r5
    8b04:	be250014 	bneid	r5, 20		// 8b18
    8b08:	33400010 	addik	r26, r0, 16	// 10 <_vector_interrupt>
    8b0c:	30a00078 	addik	r5, r0, 120
    8b10:	88842c00 	pcmpeq	r4, r4, r5
    8b14:	bc04ff74 	beqi	r4, -140		// 8a88
    8b18:	e2760001 	lbui	r19, r22, 1
    8b1c:	3060000f 	addik	r3, r0, 15
    8b20:	32d60002 	addik	r22, r22, 2
    8b24:	b0000fff 	imm	4095
    8b28:	3300ffff 	addik	r24, r0, -1
    8b2c:	b810fe78 	brid	-392		// 89a4
    8b30:	12fa0000 	addk	r23, r26, r0
    8b34:	32e00008 	addik	r23, r0, 8	// 8 <_vector_sw_exception>
    8b38:	30600007 	addik	r3, r0, 7
    8b3c:	b0001fff 	imm	8191
    8b40:	3300ffff 	addik	r24, r0, -1
    8b44:	b810fe60 	brid	-416		// 89a4
    8b48:	13570000 	addk	r26, r23, r0

00008b4c <strtoul>:
    8b4c:	10850000 	addk	r4, r5, r0
    8b50:	10660000 	addk	r3, r6, r0
    8b54:	11070000 	addk	r8, r7, r0
    8b58:	b0000000 	imm	0
    8b5c:	e8a0e3e8 	lwi	r5, r0, -7192	// e3e8 <_impure_ptr>
    8b60:	10c40000 	addk	r6, r4, r0
    8b64:	3021ffe4 	addik	r1, r1, -28
    8b68:	f9e10000 	swi	r15, r1, 0
    8b6c:	b9f4fd78 	brlid	r15, -648	// 88e4 <_strtoul_r>
    8b70:	10e30000 	addk	r7, r3, r0
    8b74:	e9e10000 	lwi	r15, r1, 0
    8b78:	b60f0008 	rtsd	r15, 8
    8b7c:	3021001c 	addik	r1, r1, 28

00008b80 <__get_current_time_locale>:
    8b80:	b0000000 	imm	0
    8b84:	e880eb20 	lwi	r4, r0, -5344	// eb20 <_time_using_locale>
    8b88:	b0000000 	imm	0
    8b8c:	3060df78 	addik	r3, r0, -8328	// df78 <_C_time_locale>
    8b90:	bc24000c 	bnei	r4, 12		// 8b9c
    8b94:	b60f0008 	rtsd	r15, 8
    8b98:	80000000 	or	r0, r0, r0
    8b9c:	b0000000 	imm	0
    8ba0:	3060eb24 	addik	r3, r0, -5340	// eb24 <_time_locale>
    8ba4:	b60f0008 	rtsd	r15, 8
    8ba8:	80000000 	or	r0, r0, r0

00008bac <__time_load_locale>:
    8bac:	3120003f 	addik	r9, r0, 63
    8bb0:	b0000000 	imm	0
    8bb4:	30c0eb20 	addik	r6, r0, -5344	// eb20 <_time_using_locale>
    8bb8:	b0000000 	imm	0
    8bbc:	e8e0ec20 	lwi	r7, r0, -5088	// ec20 <time_locale_buf>
    8bc0:	b0000000 	imm	0
    8bc4:	3100de14 	addik	r8, r0, -8684
    8bc8:	11490000 	addk	r10, r9, r0
    8bcc:	b0000000 	imm	0
    8bd0:	3060eb24 	addik	r3, r0, -5340	// eb24 <_time_locale>
    8bd4:	3021ffe0 	addik	r1, r1, -32
    8bd8:	f9e10000 	swi	r15, r1, 0
    8bdc:	b0000000 	imm	0
    8be0:	b9f406b8 	brlid	r15, 1720	// 9298 <__part_load_locale>
    8be4:	f861001c 	swi	r3, r1, 28
    8be8:	e9e10000 	lwi	r15, r1, 0
    8bec:	b60f0008 	rtsd	r15, 8
    8bf0:	30210020 	addik	r1, r1, 32

00008bf4 <__tz_lock>:
    8bf4:	b60f0008 	rtsd	r15, 8
    8bf8:	80000000 	or	r0, r0, r0

00008bfc <__tz_unlock>:
    8bfc:	b60f0008 	rtsd	r15, 8
    8c00:	80000000 	or	r0, r0, r0

00008c04 <abs>:
    8c04:	10602800 	addk	r3, r0, r5
    8c08:	90650001 	sra	r3, r5
    8c0c:	90630001 	sra	r3, r3
    8c10:	90630001 	sra	r3, r3
    8c14:	90630001 	sra	r3, r3
    8c18:	90630001 	sra	r3, r3
    8c1c:	90630001 	sra	r3, r3
    8c20:	90630001 	sra	r3, r3
    8c24:	90630001 	sra	r3, r3
    8c28:	90630001 	sra	r3, r3
    8c2c:	90630001 	sra	r3, r3
    8c30:	90630001 	sra	r3, r3
    8c34:	90630001 	sra	r3, r3
    8c38:	90630001 	sra	r3, r3
    8c3c:	90630001 	sra	r3, r3
    8c40:	90630001 	sra	r3, r3
    8c44:	90630001 	sra	r3, r3
    8c48:	90630001 	sra	r3, r3
    8c4c:	90630001 	sra	r3, r3
    8c50:	90630001 	sra	r3, r3
    8c54:	90630001 	sra	r3, r3
    8c58:	90630001 	sra	r3, r3
    8c5c:	90630001 	sra	r3, r3
    8c60:	90630001 	sra	r3, r3
    8c64:	90630001 	sra	r3, r3
    8c68:	90630001 	sra	r3, r3
    8c6c:	90630001 	sra	r3, r3
    8c70:	90630001 	sra	r3, r3
    8c74:	90630001 	sra	r3, r3
    8c78:	90630001 	sra	r3, r3
    8c7c:	90630001 	sra	r3, r3
    8c80:	90630001 	sra	r3, r3
    8c84:	88a32800 	xor	r5, r3, r5
    8c88:	b60f0008 	rtsd	r15, 8
    8c8c:	14632800 	rsubk	r3, r3, r5

00008c90 <_malloc_trim_r>:
    8c90:	3021ffd8 	addik	r1, r1, -40
    8c94:	fa61001c 	swi	r19, r1, 28
    8c98:	fac10020 	swi	r22, r1, 32
    8c9c:	fae10024 	swi	r23, r1, 36
    8ca0:	12650000 	addk	r19, r5, r0
    8ca4:	f9e10000 	swi	r15, r1, 0
    8ca8:	b000ffff 	imm	-1
    8cac:	b9f4ded8 	brlid	r15, -8488	// 6b84 <__malloc_lock>
    8cb0:	12e60000 	addk	r23, r6, r0
    8cb4:	b0000000 	imm	0
    8cb8:	e860e520 	lwi	r3, r0, -6880
    8cbc:	eac30004 	lwi	r22, r3, 4
    8cc0:	a6d6fffc 	andi	r22, r22, -4
    8cc4:	3076006f 	addik	r3, r22, 111
    8cc8:	16f71800 	rsubk	r23, r23, r3
    8ccc:	a6f7ff80 	andi	r23, r23, -128
    8cd0:	32f7ff80 	addik	r23, r23, -128
    8cd4:	3060007f 	addik	r3, r0, 127
    8cd8:	14771801 	cmp	r3, r23, r3
    8cdc:	bea3002c 	bgeid	r3, 44		// 8d08
    8ce0:	10b30000 	addk	r5, r19, r0
    8ce4:	b000ffff 	imm	-1
    8ce8:	b9f4e5d4 	brlid	r15, -6700	// 72bc <_sbrk_r>
    8cec:	10c00000 	addk	r6, r0, r0
    8cf0:	b0000000 	imm	0
    8cf4:	e880e520 	lwi	r4, r0, -6880
    8cf8:	1084b000 	addk	r4, r4, r22
    8cfc:	88632000 	xor	r3, r3, r4
    8d00:	be030030 	beqid	r3, 48		// 8d30
    8d04:	10b30000 	addk	r5, r19, r0
    8d08:	b000ffff 	imm	-1
    8d0c:	b9f4de80 	brlid	r15, -8576	// 6b8c <__malloc_unlock>
    8d10:	80000000 	or	r0, r0, r0
    8d14:	e9e10000 	lwi	r15, r1, 0
    8d18:	ea61001c 	lwi	r19, r1, 28
    8d1c:	eac10020 	lwi	r22, r1, 32
    8d20:	eae10024 	lwi	r23, r1, 36
    8d24:	10600000 	addk	r3, r0, r0
    8d28:	b60f0008 	rtsd	r15, 8
    8d2c:	30210028 	addik	r1, r1, 40
    8d30:	b000ffff 	imm	-1
    8d34:	b9f4e588 	brlid	r15, -6776	// 72bc <_sbrk_r>
    8d38:	14d70000 	rsubk	r6, r23, r0
    8d3c:	a8c3ffff 	xori	r6, r3, -1
    8d40:	be060054 	beqid	r6, 84		// 8d94
    8d44:	16d7b000 	rsubk	r22, r23, r22
    8d48:	b0000000 	imm	0
    8d4c:	e860eaec 	lwi	r3, r0, -5396	// eaec <__malloc_current_mallinfo>
    8d50:	10b30000 	addk	r5, r19, r0
    8d54:	16f71800 	rsubk	r23, r23, r3
    8d58:	b0000000 	imm	0
    8d5c:	e860e520 	lwi	r3, r0, -6880
    8d60:	a2d60001 	ori	r22, r22, 1
    8d64:	b0000000 	imm	0
    8d68:	fae0eaec 	swi	r23, r0, -5396	// eaec <__malloc_current_mallinfo>
    8d6c:	b000ffff 	imm	-1
    8d70:	b9f4de1c 	brlid	r15, -8676	// 6b8c <__malloc_unlock>
    8d74:	fac30004 	swi	r22, r3, 4
    8d78:	e9e10000 	lwi	r15, r1, 0
    8d7c:	ea61001c 	lwi	r19, r1, 28
    8d80:	eac10020 	lwi	r22, r1, 32
    8d84:	eae10024 	lwi	r23, r1, 36
    8d88:	30600001 	addik	r3, r0, 1
    8d8c:	b60f0008 	rtsd	r15, 8
    8d90:	30210028 	addik	r1, r1, 40
    8d94:	b000ffff 	imm	-1
    8d98:	b9f4e524 	brlid	r15, -6876	// 72bc <_sbrk_r>
    8d9c:	10b30000 	addk	r5, r19, r0
    8da0:	b0000000 	imm	0
    8da4:	e880e520 	lwi	r4, r0, -6880
    8da8:	30c0000f 	addik	r6, r0, 15
    8dac:	14a41800 	rsubk	r5, r4, r3
    8db0:	14c53001 	cmp	r6, r5, r6
    8db4:	bca60020 	bgei	r6, 32		// 8dd4
    8db8:	a0a50001 	ori	r5, r5, 1
    8dbc:	f8a40004 	swi	r5, r4, 4
    8dc0:	b0000000 	imm	0
    8dc4:	e880e510 	lwi	r4, r0, -6896	// e510 <__malloc_sbrk_base>
    8dc8:	14641800 	rsubk	r3, r4, r3
    8dcc:	b0000000 	imm	0
    8dd0:	f860eaec 	swi	r3, r0, -5396	// eaec <__malloc_current_mallinfo>
    8dd4:	b810ff34 	brid	-204		// 8d08
    8dd8:	10b30000 	addk	r5, r19, r0

00008ddc <_free_r>:
    8ddc:	3021ffdc 	addik	r1, r1, -36
    8de0:	fa61001c 	swi	r19, r1, 28
    8de4:	fac10020 	swi	r22, r1, 32
    8de8:	f9e10000 	swi	r15, r1, 0
    8dec:	12660000 	addk	r19, r6, r0
    8df0:	be06019c 	beqid	r6, 412		// 8f8c
    8df4:	12c50000 	addk	r22, r5, r0
    8df8:	b000ffff 	imm	-1
    8dfc:	b9f4dd88 	brlid	r15, -8824	// 6b84 <__malloc_lock>
    8e00:	80000000 	or	r0, r0, r0
    8e04:	e913fffc 	lwi	r8, r19, -4
    8e08:	30f3fff8 	addik	r7, r19, -8
    8e0c:	b0000000 	imm	0
    8e10:	e8a0e520 	lwi	r5, r0, -6880
    8e14:	a468fffe 	andi	r3, r8, -2
    8e18:	10871800 	addk	r4, r7, r3
    8e1c:	e8c40004 	lwi	r6, r4, 4
    8e20:	88a52000 	xor	r5, r5, r4
    8e24:	b0000000 	imm	0
    8e28:	3140e520 	addik	r10, r0, -6880
    8e2c:	be0501e4 	beqid	r5, 484		// 9010
    8e30:	a4c6fffc 	andi	r6, r6, -4
    8e34:	f8c40004 	swi	r6, r4, 4
    8e38:	a5080001 	andi	r8, r8, 1
    8e3c:	be280034 	bneid	r8, 52		// 8e70
    8e40:	11200000 	addk	r9, r0, r0
    8e44:	e973fff8 	lwi	r11, r19, -8
    8e48:	14eb3800 	rsubk	r7, r11, r7
    8e4c:	e8a70008 	lwi	r5, r7, 8
    8e50:	10635800 	addk	r3, r3, r11
    8e54:	89655000 	xor	r11, r5, r10
    8e58:	be0b0018 	beqid	r11, 24		// 8e70
    8e5c:	31200001 	addik	r9, r0, 1
    8e60:	e967000c 	lwi	r11, r7, 12
    8e64:	11280000 	addk	r9, r8, r0
    8e68:	f965000c 	swi	r11, r5, 12
    8e6c:	f8ab0008 	swi	r5, r11, 8
    8e70:	10a43000 	addk	r5, r4, r6
    8e74:	e8a50004 	lwi	r5, r5, 4
    8e78:	a4a50001 	andi	r5, r5, 1
    8e7c:	bc25002c 	bnei	r5, 44		// 8ea8
    8e80:	10633000 	addk	r3, r3, r6
    8e84:	be290018 	bneid	r9, 24		// 8e9c
    8e88:	e8a40008 	lwi	r5, r4, 8
    8e8c:	89455000 	xor	r10, r5, r10
    8e90:	b0000000 	imm	0
    8e94:	30c0e520 	addik	r6, r0, -6880
    8e98:	bc0a01d4 	beqi	r10, 468		// 906c
    8e9c:	e884000c 	lwi	r4, r4, 12
    8ea0:	f885000c 	swi	r4, r5, 12
    8ea4:	f8a40008 	swi	r5, r4, 8
    8ea8:	a0830001 	ori	r4, r3, 1
    8eac:	f8870004 	swi	r4, r7, 4
    8eb0:	be2900d0 	bneid	r9, 208		// 8f80
    8eb4:	d8633800 	sw	r3, r3, r7
    8eb8:	308001ff 	addik	r4, r0, 511
    8ebc:	14832003 	cmpu	r4, r3, r4
    8ec0:	bea400e0 	bgeid	r4, 224		// 8fa0
    8ec4:	31000001 	addik	r8, r0, 1
    8ec8:	30a00004 	addik	r5, r0, 4
    8ecc:	10801800 	addk	r4, r0, r3
    8ed0:	90830041 	srl	r4, r3
    8ed4:	90840041 	srl	r4, r4
    8ed8:	90840041 	srl	r4, r4
    8edc:	90840041 	srl	r4, r4
    8ee0:	90840041 	srl	r4, r4
    8ee4:	90840041 	srl	r4, r4
    8ee8:	90840041 	srl	r4, r4
    8eec:	90840041 	srl	r4, r4
    8ef0:	90840041 	srl	r4, r4
    8ef4:	14a42803 	cmpu	r5, r4, r5
    8ef8:	be450194 	bltid	r5, 404		// 908c
    8efc:	30a00014 	addik	r5, r0, 20
    8f00:	10a01800 	addk	r5, r0, r3
    8f04:	90a30041 	srl	r5, r3
    8f08:	90a50041 	srl	r5, r5
    8f0c:	90a50041 	srl	r5, r5
    8f10:	90a50041 	srl	r5, r5
    8f14:	90a50041 	srl	r5, r5
    8f18:	90a50041 	srl	r5, r5
    8f1c:	30a50038 	addik	r5, r5, 56
    8f20:	60c50008 	muli	r6, r5, 8
    8f24:	b0000000 	imm	0
    8f28:	30c6e518 	addik	r6, r6, -6888
    8f2c:	e8860008 	lwi	r4, r6, 8
    8f30:	89043000 	xor	r8, r4, r6
    8f34:	bc08016c 	beqi	r8, 364		// 90a0
    8f38:	e8a40004 	lwi	r5, r4, 4
    8f3c:	a4a5fffc 	andi	r5, r5, -4
    8f40:	14a51803 	cmpu	r5, r5, r3
    8f44:	bc45001c 	blti	r5, 28		// 8f60
    8f48:	b8100028 	brid	40		// 8f70
    8f4c:	e864000c 	lwi	r3, r4, 12
    8f50:	e9040004 	lwi	r8, r4, 4
    8f54:	a508fffc 	andi	r8, r8, -4
    8f58:	15081803 	cmpu	r8, r8, r3
    8f5c:	bca80010 	bgei	r8, 16		// 8f6c
    8f60:	e8840008 	lwi	r4, r4, 8
    8f64:	89062000 	xor	r8, r6, r4
    8f68:	bc28ffe8 	bnei	r8, -24		// 8f50
    8f6c:	e864000c 	lwi	r3, r4, 12
    8f70:	f867000c 	swi	r3, r7, 12
    8f74:	f8870008 	swi	r4, r7, 8
    8f78:	f8e30008 	swi	r7, r3, 8
    8f7c:	f8e4000c 	swi	r7, r4, 12
    8f80:	b000ffff 	imm	-1
    8f84:	b9f4dc08 	brlid	r15, -9208	// 6b8c <__malloc_unlock>
    8f88:	10b60000 	addk	r5, r22, r0
    8f8c:	e9e10000 	lwi	r15, r1, 0
    8f90:	ea61001c 	lwi	r19, r1, 28
    8f94:	eac10020 	lwi	r22, r1, 32
    8f98:	b60f0008 	rtsd	r15, 8
    8f9c:	30210024 	addik	r1, r1, 36
    8fa0:	10a01800 	addk	r5, r0, r3
    8fa4:	90a30041 	srl	r5, r3
    8fa8:	90a50041 	srl	r5, r5
    8fac:	90a50041 	srl	r5, r5
    8fb0:	60650008 	muli	r3, r5, 8
    8fb4:	10c02800 	addk	r6, r0, r5
    8fb8:	90c50001 	sra	r6, r5
    8fbc:	90c60001 	sra	r6, r6
    8fc0:	b0000000 	imm	0
    8fc4:	3063e518 	addik	r3, r3, -6888
    8fc8:	a646001f 	andi	r18, r6, 31
    8fcc:	10a04000 	addk	r5, r0, r8
    8fd0:	be120014 	beqid	r18, 20		// 8fe4
    8fd4:	10a50000 	addk	r5, r5, r0
    8fd8:	3252ffff 	addik	r18, r18, -1
    8fdc:	be32fffc 	bneid	r18, -4		// 8fd8
    8fe0:	10a52800 	addk	r5, r5, r5
    8fe4:	b0000000 	imm	0
    8fe8:	e8c0e51c 	lwi	r6, r0, -6884
    8fec:	e8830008 	lwi	r4, r3, 8
    8ff0:	f867000c 	swi	r3, r7, 12
    8ff4:	80a53000 	or	r5, r5, r6
    8ff8:	f8870008 	swi	r4, r7, 8
    8ffc:	b0000000 	imm	0
    9000:	f8a0e51c 	swi	r5, r0, -6884
    9004:	f8e30008 	swi	r7, r3, 8
    9008:	b810ff78 	brid	-136		// 8f80
    900c:	f8e4000c 	swi	r7, r4, 12
    9010:	a5080001 	andi	r8, r8, 1
    9014:	be280024 	bneid	r8, 36		// 9038
    9018:	10661800 	addk	r3, r6, r3
    901c:	e8b3fff8 	lwi	r5, r19, -8
    9020:	14e53800 	rsubk	r7, r5, r7
    9024:	e887000c 	lwi	r4, r7, 12
    9028:	e8c70008 	lwi	r6, r7, 8
    902c:	10632800 	addk	r3, r3, r5
    9030:	f886000c 	swi	r4, r6, 12
    9034:	f8c40008 	swi	r6, r4, 8
    9038:	b0000000 	imm	0
    903c:	e8c0e514 	lwi	r6, r0, -6892	// e514 <__malloc_trim_threshold>
    9040:	a0830001 	ori	r4, r3, 1
    9044:	f8870004 	swi	r4, r7, 4
    9048:	b0000000 	imm	0
    904c:	f8e0e520 	swi	r7, r0, -6880
    9050:	14661803 	cmpu	r3, r6, r3
    9054:	bc43ff2c 	blti	r3, -212		// 8f80
    9058:	b0000000 	imm	0
    905c:	e8c0eb1c 	lwi	r6, r0, -5348	// eb1c <__malloc_top_pad>
    9060:	b9f4fc30 	brlid	r15, -976	// 8c90 <_malloc_trim_r>
    9064:	10b60000 	addk	r5, r22, r0
    9068:	b800ff18 	bri	-232		// 8f80
    906c:	f8e6000c 	swi	r7, r6, 12
    9070:	f8e60008 	swi	r7, r6, 8
    9074:	a0830001 	ori	r4, r3, 1
    9078:	f8c7000c 	swi	r6, r7, 12
    907c:	f8c70008 	swi	r6, r7, 8
    9080:	f8870004 	swi	r4, r7, 4
    9084:	b810fefc 	brid	-260		// 8f80
    9088:	d8633800 	sw	r3, r3, r7
    908c:	14a42803 	cmpu	r5, r4, r5
    9090:	be450058 	bltid	r5, 88		// 90e8
    9094:	30a4005b 	addik	r5, r4, 91
    9098:	b810fe8c 	brid	-372		// 8f24
    909c:	60c50008 	muli	r6, r5, 8
    90a0:	10c02800 	addk	r6, r0, r5
    90a4:	90c50001 	sra	r6, r5
    90a8:	90c60001 	sra	r6, r6
    90ac:	30a00001 	addik	r5, r0, 1
    90b0:	a646001f 	andi	r18, r6, 31
    90b4:	10602800 	addk	r3, r0, r5
    90b8:	be120014 	beqid	r18, 20		// 90cc
    90bc:	10630000 	addk	r3, r3, r0
    90c0:	3252ffff 	addik	r18, r18, -1
    90c4:	be32fffc 	bneid	r18, -4		// 90c0
    90c8:	10631800 	addk	r3, r3, r3
    90cc:	b0000000 	imm	0
    90d0:	e8a0e51c 	lwi	r5, r0, -6884
    90d4:	80632800 	or	r3, r3, r5
    90d8:	b0000000 	imm	0
    90dc:	f860e51c 	swi	r3, r0, -6884
    90e0:	b810fe90 	brid	-368		// 8f70
    90e4:	10640000 	addk	r3, r4, r0
    90e8:	30a00054 	addik	r5, r0, 84
    90ec:	14a42803 	cmpu	r5, r4, r5
    90f0:	bc450044 	blti	r5, 68		// 9134
    90f4:	10a01800 	addk	r5, r0, r3
    90f8:	90a30041 	srl	r5, r3
    90fc:	90a50041 	srl	r5, r5
    9100:	90a50041 	srl	r5, r5
    9104:	90a50041 	srl	r5, r5
    9108:	90a50041 	srl	r5, r5
    910c:	90a50041 	srl	r5, r5
    9110:	90a50041 	srl	r5, r5
    9114:	90a50041 	srl	r5, r5
    9118:	90a50041 	srl	r5, r5
    911c:	90a50041 	srl	r5, r5
    9120:	90a50041 	srl	r5, r5
    9124:	90a50041 	srl	r5, r5
    9128:	30a5006e 	addik	r5, r5, 110
    912c:	b810fdf8 	brid	-520		// 8f24
    9130:	60c50008 	muli	r6, r5, 8
    9134:	30a00154 	addik	r5, r0, 340
    9138:	14a42803 	cmpu	r5, r4, r5
    913c:	bc450050 	blti	r5, 80		// 918c
    9140:	10a01800 	addk	r5, r0, r3
    9144:	90a30041 	srl	r5, r3
    9148:	90a50041 	srl	r5, r5
    914c:	90a50041 	srl	r5, r5
    9150:	90a50041 	srl	r5, r5
    9154:	90a50041 	srl	r5, r5
    9158:	90a50041 	srl	r5, r5
    915c:	90a50041 	srl	r5, r5
    9160:	90a50041 	srl	r5, r5
    9164:	90a50041 	srl	r5, r5
    9168:	90a50041 	srl	r5, r5
    916c:	90a50041 	srl	r5, r5
    9170:	90a50041 	srl	r5, r5
    9174:	90a50041 	srl	r5, r5
    9178:	90a50041 	srl	r5, r5
    917c:	90a50041 	srl	r5, r5
    9180:	30a50077 	addik	r5, r5, 119
    9184:	b810fda0 	brid	-608		// 8f24
    9188:	60c50008 	muli	r6, r5, 8
    918c:	30a00554 	addik	r5, r0, 1364
    9190:	14842803 	cmpu	r4, r4, r5
    9194:	bc44005c 	blti	r4, 92		// 91f0
    9198:	10a01800 	addk	r5, r0, r3
    919c:	90a30041 	srl	r5, r3
    91a0:	90a50041 	srl	r5, r5
    91a4:	90a50041 	srl	r5, r5
    91a8:	90a50041 	srl	r5, r5
    91ac:	90a50041 	srl	r5, r5
    91b0:	90a50041 	srl	r5, r5
    91b4:	90a50041 	srl	r5, r5
    91b8:	90a50041 	srl	r5, r5
    91bc:	90a50041 	srl	r5, r5
    91c0:	90a50041 	srl	r5, r5
    91c4:	90a50041 	srl	r5, r5
    91c8:	90a50041 	srl	r5, r5
    91cc:	90a50041 	srl	r5, r5
    91d0:	90a50041 	srl	r5, r5
    91d4:	90a50041 	srl	r5, r5
    91d8:	90a50041 	srl	r5, r5
    91dc:	90a50041 	srl	r5, r5
    91e0:	90a50041 	srl	r5, r5
    91e4:	30a5007c 	addik	r5, r5, 124
    91e8:	b810fd3c 	brid	-708		// 8f24
    91ec:	60c50008 	muli	r6, r5, 8
    91f0:	30c003f0 	addik	r6, r0, 1008
    91f4:	b810fd30 	brid	-720		// 8f24
    91f8:	30a0007e 	addik	r5, r0, 126

000091fc <__gettzinfo>:
    91fc:	b0000000 	imm	0
    9200:	3060e928 	addik	r3, r0, -5848	// e928 <tzinfo>
    9204:	b60f0008 	rtsd	r15, 8
    9208:	80000000 	or	r0, r0, r0

0000920c <labs>:
    920c:	10602800 	addk	r3, r0, r5
    9210:	90650001 	sra	r3, r5
    9214:	90630001 	sra	r3, r3
    9218:	90630001 	sra	r3, r3
    921c:	90630001 	sra	r3, r3
    9220:	90630001 	sra	r3, r3
    9224:	90630001 	sra	r3, r3
    9228:	90630001 	sra	r3, r3
    922c:	90630001 	sra	r3, r3
    9230:	90630001 	sra	r3, r3
    9234:	90630001 	sra	r3, r3
    9238:	90630001 	sra	r3, r3
    923c:	90630001 	sra	r3, r3
    9240:	90630001 	sra	r3, r3
    9244:	90630001 	sra	r3, r3
    9248:	90630001 	sra	r3, r3
    924c:	90630001 	sra	r3, r3
    9250:	90630001 	sra	r3, r3
    9254:	90630001 	sra	r3, r3
    9258:	90630001 	sra	r3, r3
    925c:	90630001 	sra	r3, r3
    9260:	90630001 	sra	r3, r3
    9264:	90630001 	sra	r3, r3
    9268:	90630001 	sra	r3, r3
    926c:	90630001 	sra	r3, r3
    9270:	90630001 	sra	r3, r3
    9274:	90630001 	sra	r3, r3
    9278:	90630001 	sra	r3, r3
    927c:	90630001 	sra	r3, r3
    9280:	90630001 	sra	r3, r3
    9284:	90630001 	sra	r3, r3
    9288:	90630001 	sra	r3, r3
    928c:	88a32800 	xor	r5, r3, r5
    9290:	b60f0008 	rtsd	r15, 8
    9294:	14632800 	rsubk	r3, r3, r5

00009298 <__part_load_locale>:
    9298:	3021fb80 	addik	r1, r1, -1152
    929c:	fa610458 	swi	r19, r1, 1112
    92a0:	fac1045c 	swi	r22, r1, 1116
    92a4:	fb010464 	swi	r24, r1, 1124
    92a8:	fb210468 	swi	r25, r1, 1128
    92ac:	fb41046c 	swi	r26, r1, 1132
    92b0:	fb610470 	swi	r27, r1, 1136
    92b4:	fb810474 	swi	r28, r1, 1140
    92b8:	f9e10000 	swi	r15, r1, 0
    92bc:	fae10460 	swi	r23, r1, 1120
    92c0:	fba10478 	swi	r29, r1, 1144
    92c4:	fbc1047c 	swi	r30, r1, 1148
    92c8:	eba60000 	lwi	r29, r6, 0
    92cc:	f8060000 	swi	r0, r6, 0
    92d0:	13060000 	addk	r24, r6, r0
    92d4:	13250000 	addk	r25, r5, r0
    92d8:	13470000 	addk	r26, r7, r0
    92dc:	12c80000 	addk	r22, r8, r0
    92e0:	13690000 	addk	r27, r9, r0
    92e4:	138a0000 	addk	r28, r10, r0
    92e8:	be0502ac 	beqid	r5, 684		// 9594
    92ec:	ea61049c 	lwi	r19, r1, 1180
    92f0:	b0000000 	imm	0
    92f4:	30c0e078 	addik	r6, r0, -8072
    92f8:	b0000000 	imm	0
    92fc:	b9f40bb8 	brlid	r15, 3000	// 9eb4 <strcmp>
    9300:	80000000 	or	r0, r0, r0
    9304:	bc230038 	bnei	r3, 56		// 933c
    9308:	e9e10000 	lwi	r15, r1, 0
    930c:	ea610458 	lwi	r19, r1, 1112
    9310:	eac1045c 	lwi	r22, r1, 1116
    9314:	eae10460 	lwi	r23, r1, 1120
    9318:	eb010464 	lwi	r24, r1, 1124
    931c:	eb210468 	lwi	r25, r1, 1128
    9320:	eb41046c 	lwi	r26, r1, 1132
    9324:	eb610470 	lwi	r27, r1, 1136
    9328:	eb810474 	lwi	r28, r1, 1140
    932c:	eba10478 	lwi	r29, r1, 1144
    9330:	ebc1047c 	lwi	r30, r1, 1148
    9334:	b60f0008 	rtsd	r15, 8
    9338:	30210480 	addik	r1, r1, 1152
    933c:	b0000000 	imm	0
    9340:	30c0e07c 	addik	r6, r0, -8068
    9344:	b0000000 	imm	0
    9348:	b9f40b6c 	brlid	r15, 2924	// 9eb4 <strcmp>
    934c:	10b90000 	addk	r5, r25, r0
    9350:	be03ffbc 	beqid	r3, -68		// 930c
    9354:	e9e10000 	lwi	r15, r1, 0
    9358:	be1a0064 	beqid	r26, 100		// 93bc
    935c:	10b90000 	addk	r5, r25, r0
    9360:	b0000000 	imm	0
    9364:	b9f40b50 	brlid	r15, 2896	// 9eb4 <strcmp>
    9368:	10da0000 	addk	r6, r26, r0
    936c:	bc230050 	bnei	r3, 80		// 93bc
    9370:	b0000000 	imm	0
    9374:	eb20ec2c 	lwi	r25, r0, -5076	// ec2c <num_lines.1882>
    9378:	be790034 	bleid	r25, 52		// 93ac
    937c:	12da0000 	addk	r22, r26, r0
    9380:	12e30000 	addk	r23, r3, r0
    9384:	10b60000 	addk	r5, r22, r0
    9388:	b000ffff 	imm	-1
    938c:	b9f4f4fc 	brlid	r15, -2820	// 8888 <strlen>
    9390:	32f70001 	addik	r23, r23, 1
    9394:	30630001 	addik	r3, r3, 1
    9398:	12d61800 	addk	r22, r22, r3
    939c:	fad30000 	swi	r22, r19, 0
    93a0:	1479b801 	cmp	r3, r25, r23
    93a4:	be43ffe0 	bltid	r3, -32		// 9384
    93a8:	32730004 	addik	r19, r19, 4
    93ac:	30600001 	addik	r3, r0, 1
    93b0:	f8780000 	swi	r3, r24, 0
    93b4:	b810ff54 	brid	-172		// 9308
    93b8:	10600000 	addk	r3, r0, r0
    93bc:	b000ffff 	imm	-1
    93c0:	b9f4f4c8 	brlid	r15, -2872	// 8888 <strlen>
    93c4:	10b90000 	addk	r5, r25, r0
    93c8:	b0000000 	imm	0
    93cc:	e8c0ec30 	lwi	r6, r0, -5072	// ec30 <_PathLocale>
    93d0:	be0601c4 	beqid	r6, 452		// 9594
    93d4:	12e30000 	addk	r23, r3, r0
    93d8:	b0000000 	imm	0
    93dc:	b9f40b88 	brlid	r15, 2952	// 9f64 <strcpy>
    93e0:	30a10058 	addik	r5, r1, 88
    93e4:	b0000000 	imm	0
    93e8:	30c0e084 	addik	r6, r0, -8060
    93ec:	b0000000 	imm	0
    93f0:	b9f40848 	brlid	r15, 2120	// 9c38 <strcat>
    93f4:	30a10058 	addik	r5, r1, 88
    93f8:	10d90000 	addk	r6, r25, r0
    93fc:	b0000000 	imm	0
    9400:	b9f40838 	brlid	r15, 2104	// 9c38 <strcat>
    9404:	30a10058 	addik	r5, r1, 88
    9408:	b0000000 	imm	0
    940c:	30c0e084 	addik	r6, r0, -8060
    9410:	b0000000 	imm	0
    9414:	b9f40824 	brlid	r15, 2084	// 9c38 <strcat>
    9418:	30a10058 	addik	r5, r1, 88
    941c:	10d60000 	addk	r6, r22, r0
    9420:	b0000000 	imm	0
    9424:	b9f40814 	brlid	r15, 2068	// 9c38 <strcat>
    9428:	30a10058 	addik	r5, r1, 88
    942c:	30a10058 	addik	r5, r1, 88
    9430:	b0000000 	imm	0
    9434:	b9f4216c 	brlid	r15, 8556	// b5a0 <open>
    9438:	10c00000 	addk	r6, r0, r0
    943c:	be430158 	bltid	r3, 344		// 9594
    9440:	13c30000 	addk	r30, r3, r0
    9444:	10a30000 	addk	r5, r3, r0
    9448:	b0000000 	imm	0
    944c:	b9f42140 	brlid	r15, 8512	// b58c <fstat>
    9450:	30c1001c 	addik	r6, r1, 28
    9454:	be230134 	bneid	r3, 308		// 9588
    9458:	e8c1002c 	lwi	r6, r1, 44
    945c:	be66012c 	bleid	r6, 300		// 9588
    9460:	32f70001 	addik	r23, r23, 1
    9464:	be1a0110 	beqid	r26, 272		// 9574
    9468:	10d73000 	addk	r6, r23, r6
    946c:	b0000000 	imm	0
    9470:	3060e968 	addik	r3, r0, -5784	// e968 <locale_buf_C.1881>
    9474:	887a1800 	xor	r3, r26, r3
    9478:	bc0300fc 	beqi	r3, 252		// 9574
    947c:	b000ffff 	imm	-1
    9480:	b9f4d714 	brlid	r15, -10476	// 6b94 <realloc>
    9484:	10ba0000 	addk	r5, r26, r0
    9488:	be030138 	beqid	r3, 312		// 95c0
    948c:	12c30000 	addk	r22, r3, r0
    9490:	10b60000 	addk	r5, r22, r0
    9494:	10d90000 	addk	r6, r25, r0
    9498:	b0000000 	imm	0
    949c:	b9f40ac8 	brlid	r15, 2760	// 9f64 <strcpy>
    94a0:	12f6b800 	addk	r23, r22, r23
    94a4:	eb41002c 	lwi	r26, r1, 44
    94a8:	10be0000 	addk	r5, r30, r0
    94ac:	10d70000 	addk	r6, r23, r0
    94b0:	b000ffff 	imm	-1
    94b4:	b9f4a0fc 	brlid	r15, -24324	// 35b0 <read>
    94b8:	10fa0000 	addk	r7, r26, r0
    94bc:	e881002c 	lwi	r4, r1, 44
    94c0:	88632000 	xor	r3, r3, r4
    94c4:	bc2300ec 	bnei	r3, 236		// 95b0
    94c8:	b0000000 	imm	0
    94cc:	b9f42164 	brlid	r15, 8548	// b630 <close>
    94d0:	10be0000 	addk	r5, r30, r0
    94d4:	be2300dc 	bneid	r3, 220		// 95b0
    94d8:	1357d000 	addk	r26, r23, r26
    94dc:	e33affff 	lbui	r25, r26, -1
    94e0:	93390060 	sext8	r25, r25
    94e4:	ab39000a 	xori	r25, r25, 10
    94e8:	bc3900c8 	bnei	r25, 200		// 95b0
    94ec:	147ab803 	cmpu	r3, r26, r23
    94f0:	bca30028 	bgei	r3, 40		// 9518
    94f4:	10b70000 	addk	r5, r23, r0
    94f8:	30c0000a 	addik	r6, r0, 10
    94fc:	b0000000 	imm	0
    9500:	b9f407e4 	brlid	r15, 2020	// 9ce4 <strchr>
    9504:	33390001 	addik	r25, r25, 1
    9508:	32e30001 	addik	r23, r3, 1
    950c:	149ab803 	cmpu	r4, r26, r23
    9510:	be44ffe4 	bltid	r4, -28		// 94f4
    9514:	f0030000 	sbi	r0, r3, 0
    9518:	b0000000 	imm	0
    951c:	fb20ec2c 	swi	r25, r0, -5076	// ec2c <num_lines.1882>
    9520:	147bc801 	cmp	r3, r27, r25
    9524:	bea3007c 	bgeid	r3, 124		// 95a0
    9528:	173cc801 	cmp	r25, r28, r25
    952c:	be590080 	bltid	r25, 128		// 95ac
    9530:	137c0000 	addk	r27, r28, r0
    9534:	b0000000 	imm	0
    9538:	fb80ec2c 	swi	r28, r0, -5076	// ec2c <num_lines.1882>
    953c:	be7bfe70 	bleid	r27, -400		// 93ac
    9540:	12e00000 	addk	r23, r0, r0
    9544:	10b60000 	addk	r5, r22, r0
    9548:	b000ffff 	imm	-1
    954c:	b9f4f33c 	brlid	r15, -3268	// 8888 <strlen>
    9550:	32f70001 	addik	r23, r23, 1
    9554:	30630001 	addik	r3, r3, 1
    9558:	12d61800 	addk	r22, r22, r3
    955c:	fad30000 	swi	r22, r19, 0
    9560:	147bb801 	cmp	r3, r27, r23
    9564:	be43ffe0 	bltid	r3, -32		// 9544
    9568:	32730004 	addik	r19, r19, 4
    956c:	b810fe44 	brid	-444		// 93b0
    9570:	30600001 	addik	r3, r0, 1
    9574:	b000ffff 	imm	-1
    9578:	b9f4b9c0 	brlid	r15, -17984	// 4f38 <malloc>
    957c:	10a60000 	addk	r5, r6, r0
    9580:	be23ff10 	bneid	r3, -240		// 9490
    9584:	12c30000 	addk	r22, r3, r0
    9588:	b0000000 	imm	0
    958c:	b9f420a4 	brlid	r15, 8356	// b630 <close>
    9590:	10be0000 	addk	r5, r30, r0
    9594:	fbb80000 	swi	r29, r24, 0
    9598:	b810fd70 	brid	-656		// 9308
    959c:	3060ffff 	addik	r3, r0, -1
    95a0:	b0000000 	imm	0
    95a4:	fb60ec2c 	swi	r27, r0, -5076	// ec2c <num_lines.1882>
    95a8:	b800ff94 	bri	-108		// 953c
    95ac:	13a00000 	addk	r29, r0, r0
    95b0:	b000ffff 	imm	-1
    95b4:	b9f4b9b0 	brlid	r15, -18000	// 4f64 <free>
    95b8:	10b60000 	addk	r5, r22, r0
    95bc:	b800ffcc 	bri	-52		// 9588
    95c0:	b000ffff 	imm	-1
    95c4:	b9f4b9a0 	brlid	r15, -18016	// 4f64 <free>
    95c8:	10ba0000 	addk	r5, r26, r0
    95cc:	b800ffbc 	bri	-68		// 9588

000095d0 <_setlocale_r>:
    95d0:	3021ffdc 	addik	r1, r1, -36
    95d4:	fa61001c 	swi	r19, r1, 28
    95d8:	fac10020 	swi	r22, r1, 32
    95dc:	f9e10000 	swi	r15, r1, 0
    95e0:	b0000000 	imm	0
    95e4:	32c0e088 	addik	r22, r0, -8056
    95e8:	be070020 	beqid	r7, 32		// 9608
    95ec:	12670000 	addk	r19, r7, r0
    95f0:	b0000000 	imm	0
    95f4:	30c0e08c 	addik	r6, r0, -8052
    95f8:	b0000000 	imm	0
    95fc:	b9f408b8 	brlid	r15, 2232	// 9eb4 <strcmp>
    9600:	10a70000 	addk	r5, r7, r0
    9604:	bc23001c 	bnei	r3, 28		// 9620
    9608:	10760000 	addk	r3, r22, r0
    960c:	e9e10000 	lwi	r15, r1, 0
    9610:	ea61001c 	lwi	r19, r1, 28
    9614:	eac10020 	lwi	r22, r1, 32
    9618:	b60f0008 	rtsd	r15, 8
    961c:	30210024 	addik	r1, r1, 36
    9620:	10b30000 	addk	r5, r19, r0
    9624:	b0000000 	imm	0
    9628:	b9f4088c 	brlid	r15, 2188	// 9eb4 <strcmp>
    962c:	10d60000 	addk	r6, r22, r0
    9630:	be03ffdc 	beqid	r3, -36		// 960c
    9634:	10760000 	addk	r3, r22, r0
    9638:	10b30000 	addk	r5, r19, r0
    963c:	b0000000 	imm	0
    9640:	30c0e094 	addik	r6, r0, -8044
    9644:	b0000000 	imm	0
    9648:	b9f4086c 	brlid	r15, 2156	// 9eb4 <strcmp>
    964c:	12c00000 	addk	r22, r0, r0
    9650:	bc23ffb8 	bnei	r3, -72		// 9608
    9654:	b0000000 	imm	0
    9658:	32c0e088 	addik	r22, r0, -8056
    965c:	b810ffb0 	brid	-80		// 960c
    9660:	10760000 	addk	r3, r22, r0

00009664 <__locale_charset>:
    9664:	b0000000 	imm	0
    9668:	3060e970 	addik	r3, r0, -5776	// e970 <lc_ctype_charset>
    966c:	b60f0008 	rtsd	r15, 8
    9670:	80000000 	or	r0, r0, r0

00009674 <__locale_mb_cur_max>:
    9674:	b0000000 	imm	0
    9678:	e860e96c 	lwi	r3, r0, -5780	// e96c <__mb_cur_max>
    967c:	b60f0008 	rtsd	r15, 8
    9680:	80000000 	or	r0, r0, r0

00009684 <__locale_msgcharset>:
    9684:	b0000000 	imm	0
    9688:	3060e990 	addik	r3, r0, -5744	// e990 <lc_message_charset>
    968c:	b60f0008 	rtsd	r15, 8
    9690:	80000000 	or	r0, r0, r0

00009694 <__locale_cjk_lang>:
    9694:	b60f0008 	rtsd	r15, 8
    9698:	10600000 	addk	r3, r0, r0

0000969c <_localeconv_r>:
    969c:	b0000000 	imm	0
    96a0:	3060e9b0 	addik	r3, r0, -5712	// e9b0 <lconv>
    96a4:	b60f0008 	rtsd	r15, 8
    96a8:	80000000 	or	r0, r0, r0

000096ac <setlocale>:
    96ac:	3021ffdc 	addik	r1, r1, -36
    96b0:	fa61001c 	swi	r19, r1, 28
    96b4:	fac10020 	swi	r22, r1, 32
    96b8:	f9e10000 	swi	r15, r1, 0
    96bc:	b0000000 	imm	0
    96c0:	32c0e088 	addik	r22, r0, -8056
    96c4:	be060028 	beqid	r6, 40		// 96ec
    96c8:	12660000 	addk	r19, r6, r0
    96cc:	10a60000 	addk	r5, r6, r0
    96d0:	b0000000 	imm	0
    96d4:	30c0e08c 	addik	r6, r0, -8052
    96d8:	b0000000 	imm	0
    96dc:	b9f407d8 	brlid	r15, 2008	// 9eb4 <strcmp>
    96e0:	80000000 	or	r0, r0, r0
    96e4:	be230020 	bneid	r3, 32		// 9704
    96e8:	10b30000 	addk	r5, r19, r0
    96ec:	10760000 	addk	r3, r22, r0
    96f0:	e9e10000 	lwi	r15, r1, 0
    96f4:	ea61001c 	lwi	r19, r1, 28
    96f8:	eac10020 	lwi	r22, r1, 32
    96fc:	b60f0008 	rtsd	r15, 8
    9700:	30210024 	addik	r1, r1, 36
    9704:	b0000000 	imm	0
    9708:	b9f407ac 	brlid	r15, 1964	// 9eb4 <strcmp>
    970c:	10d60000 	addk	r6, r22, r0
    9710:	be03ffe0 	beqid	r3, -32		// 96f0
    9714:	10760000 	addk	r3, r22, r0
    9718:	10b30000 	addk	r5, r19, r0
    971c:	b0000000 	imm	0
    9720:	30c0e094 	addik	r6, r0, -8044
    9724:	b0000000 	imm	0
    9728:	b9f4078c 	brlid	r15, 1932	// 9eb4 <strcmp>
    972c:	12c00000 	addk	r22, r0, r0
    9730:	bc23ffbc 	bnei	r3, -68		// 96ec
    9734:	b0000000 	imm	0
    9738:	32c0e088 	addik	r22, r0, -8056
    973c:	b810ffb4 	brid	-76		// 96f0
    9740:	10760000 	addk	r3, r22, r0

00009744 <localeconv>:
    9744:	b0000000 	imm	0
    9748:	3060e9b0 	addik	r3, r0, -5712	// e9b0 <lconv>
    974c:	b60f0008 	rtsd	r15, 8
    9750:	80000000 	or	r0, r0, r0

00009754 <cleanup_glue>:
    9754:	3021ffbc 	addik	r1, r1, -68
    9758:	fa61001c 	swi	r19, r1, 28
    975c:	fb21002c 	swi	r25, r1, 44
    9760:	f9e10000 	swi	r15, r1, 0
    9764:	fac10020 	swi	r22, r1, 32
    9768:	fae10024 	swi	r23, r1, 36
    976c:	fb010028 	swi	r24, r1, 40
    9770:	fb410030 	swi	r26, r1, 48
    9774:	fb610034 	swi	r27, r1, 52
    9778:	fb810038 	swi	r28, r1, 56
    977c:	fba1003c 	swi	r29, r1, 60
    9780:	fbc10040 	swi	r30, r1, 64
    9784:	eac60000 	lwi	r22, r6, 0
    9788:	13260000 	addk	r25, r6, r0
    978c:	be1600d0 	beqid	r22, 208		// 985c
    9790:	12650000 	addk	r19, r5, r0
    9794:	eaf60000 	lwi	r23, r22, 0
    9798:	bc1700b4 	beqi	r23, 180		// 984c
    979c:	eb170000 	lwi	r24, r23, 0
    97a0:	bc18009c 	beqi	r24, 156		// 983c
    97a4:	eb580000 	lwi	r26, r24, 0
    97a8:	bc1a0084 	beqi	r26, 132		// 982c
    97ac:	eb7a0000 	lwi	r27, r26, 0
    97b0:	bc1b006c 	beqi	r27, 108		// 981c
    97b4:	eb9b0000 	lwi	r28, r27, 0
    97b8:	bc1c0054 	beqi	r28, 84		// 980c
    97bc:	ebbc0000 	lwi	r29, r28, 0
    97c0:	bc1d003c 	beqi	r29, 60		// 97fc
    97c4:	ebdd0000 	lwi	r30, r29, 0
    97c8:	bc1e0024 	beqi	r30, 36		// 97ec
    97cc:	e8de0000 	lwi	r6, r30, 0
    97d0:	bc06000c 	beqi	r6, 12		// 97dc
    97d4:	b9f4ff80 	brlid	r15, -128	// 9754 <cleanup_glue>
    97d8:	80000000 	or	r0, r0, r0
    97dc:	10b30000 	addk	r5, r19, r0
    97e0:	b000ffff 	imm	-1
    97e4:	b9f4f5f8 	brlid	r15, -2568	// 8ddc <_free_r>
    97e8:	10de0000 	addk	r6, r30, r0
    97ec:	10b30000 	addk	r5, r19, r0
    97f0:	b000ffff 	imm	-1
    97f4:	b9f4f5e8 	brlid	r15, -2584	// 8ddc <_free_r>
    97f8:	10dd0000 	addk	r6, r29, r0
    97fc:	10b30000 	addk	r5, r19, r0
    9800:	b000ffff 	imm	-1
    9804:	b9f4f5d8 	brlid	r15, -2600	// 8ddc <_free_r>
    9808:	10dc0000 	addk	r6, r28, r0
    980c:	10b30000 	addk	r5, r19, r0
    9810:	b000ffff 	imm	-1
    9814:	b9f4f5c8 	brlid	r15, -2616	// 8ddc <_free_r>
    9818:	10db0000 	addk	r6, r27, r0
    981c:	10b30000 	addk	r5, r19, r0
    9820:	b000ffff 	imm	-1
    9824:	b9f4f5b8 	brlid	r15, -2632	// 8ddc <_free_r>
    9828:	10da0000 	addk	r6, r26, r0
    982c:	10b30000 	addk	r5, r19, r0
    9830:	b000ffff 	imm	-1
    9834:	b9f4f5a8 	brlid	r15, -2648	// 8ddc <_free_r>
    9838:	10d80000 	addk	r6, r24, r0
    983c:	10b30000 	addk	r5, r19, r0
    9840:	b000ffff 	imm	-1
    9844:	b9f4f598 	brlid	r15, -2664	// 8ddc <_free_r>
    9848:	10d70000 	addk	r6, r23, r0
    984c:	10b30000 	addk	r5, r19, r0
    9850:	b000ffff 	imm	-1
    9854:	b9f4f588 	brlid	r15, -2680	// 8ddc <_free_r>
    9858:	10d60000 	addk	r6, r22, r0
    985c:	10b30000 	addk	r5, r19, r0
    9860:	b000ffff 	imm	-1
    9864:	b9f4f578 	brlid	r15, -2696	// 8ddc <_free_r>
    9868:	10d90000 	addk	r6, r25, r0
    986c:	e9e10000 	lwi	r15, r1, 0
    9870:	ea61001c 	lwi	r19, r1, 28
    9874:	eac10020 	lwi	r22, r1, 32
    9878:	eae10024 	lwi	r23, r1, 36
    987c:	eb010028 	lwi	r24, r1, 40
    9880:	eb21002c 	lwi	r25, r1, 44
    9884:	eb410030 	lwi	r26, r1, 48
    9888:	eb610034 	lwi	r27, r1, 52
    988c:	eb810038 	lwi	r28, r1, 56
    9890:	eba1003c 	lwi	r29, r1, 60
    9894:	ebc10040 	lwi	r30, r1, 64
    9898:	b60f0008 	rtsd	r15, 8
    989c:	30210044 	addik	r1, r1, 68

000098a0 <_reclaim_reent>:
    98a0:	b0000000 	imm	0
    98a4:	e860e3e8 	lwi	r3, r0, -7192	// e3e8 <_impure_ptr>
    98a8:	3021ffd4 	addik	r1, r1, -44
    98ac:	fa61001c 	swi	r19, r1, 28
    98b0:	f9e10000 	swi	r15, r1, 0
    98b4:	fac10020 	swi	r22, r1, 32
    98b8:	fae10024 	swi	r23, r1, 36
    98bc:	fb010028 	swi	r24, r1, 40
    98c0:	88651800 	xor	r3, r5, r3
    98c4:	be030124 	beqid	r3, 292		// 99e8
    98c8:	12650000 	addk	r19, r5, r0
    98cc:	e8650024 	lwi	r3, r5, 36
    98d0:	bc03007c 	beqi	r3, 124		// 994c
    98d4:	e883000c 	lwi	r4, r3, 12
    98d8:	bc040060 	beqi	r4, 96		// 9938
    98dc:	10600000 	addk	r3, r0, r0
    98e0:	13030000 	addk	r24, r3, r0
    98e4:	32e00020 	addik	r23, r0, 32	// 20 <_vector_hw_exception>
    98e8:	60630004 	muli	r3, r3, 4
    98ec:	c8c32000 	lw	r6, r3, r4
    98f0:	bc060024 	beqi	r6, 36		// 9914
    98f4:	10b30000 	addk	r5, r19, r0
    98f8:	b000ffff 	imm	-1
    98fc:	b9f4f4e0 	brlid	r15, -2848	// 8ddc <_free_r>
    9900:	eac60000 	lwi	r22, r6, 0
    9904:	be36fff0 	bneid	r22, -16		// 98f4
    9908:	10d60000 	addk	r6, r22, r0
    990c:	e8730024 	lwi	r3, r19, 36
    9910:	e883000c 	lwi	r4, r3, 12
    9914:	33180001 	addik	r24, r24, 1
    9918:	32f7ffff 	addik	r23, r23, -1
    991c:	be37ffcc 	bneid	r23, -52		// 98e8
    9920:	10780000 	addk	r3, r24, r0
    9924:	10b30000 	addk	r5, r19, r0
    9928:	b000ffff 	imm	-1
    992c:	b9f4f4b0 	brlid	r15, -2896	// 8ddc <_free_r>
    9930:	10c40000 	addk	r6, r4, r0
    9934:	e8730024 	lwi	r3, r19, 36
    9938:	e8c30000 	lwi	r6, r3, 0
    993c:	bc060010 	beqi	r6, 16		// 994c
    9940:	b000ffff 	imm	-1
    9944:	b9f4f498 	brlid	r15, -2920	// 8ddc <_free_r>
    9948:	10b30000 	addk	r5, r19, r0
    994c:	e8d30014 	lwi	r6, r19, 20
    9950:	bc060010 	beqi	r6, 16		// 9960
    9954:	b000ffff 	imm	-1
    9958:	b9f4f484 	brlid	r15, -2940	// 8ddc <_free_r>
    995c:	10b30000 	addk	r5, r19, r0
    9960:	e8d30024 	lwi	r6, r19, 36
    9964:	bc060010 	beqi	r6, 16		// 9974
    9968:	b000ffff 	imm	-1
    996c:	b9f4f470 	brlid	r15, -2960	// 8ddc <_free_r>
    9970:	10b30000 	addk	r5, r19, r0
    9974:	e8d30038 	lwi	r6, r19, 56
    9978:	bc060010 	beqi	r6, 16		// 9988
    997c:	b000ffff 	imm	-1
    9980:	b9f4f45c 	brlid	r15, -2980	// 8ddc <_free_r>
    9984:	10b30000 	addk	r5, r19, r0
    9988:	e8d3003c 	lwi	r6, r19, 60
    998c:	bc060010 	beqi	r6, 16		// 999c
    9990:	b000ffff 	imm	-1
    9994:	b9f4f448 	brlid	r15, -3000	// 8ddc <_free_r>
    9998:	10b30000 	addk	r5, r19, r0
    999c:	e8d30040 	lwi	r6, r19, 64
    99a0:	bc060010 	beqi	r6, 16		// 99b0
    99a4:	b000ffff 	imm	-1
    99a8:	b9f4f434 	brlid	r15, -3020	// 8ddc <_free_r>
    99ac:	10b30000 	addk	r5, r19, r0
    99b0:	e8730048 	lwi	r3, r19, 72
    99b4:	bc030018 	beqi	r3, 24		// 99cc
    99b8:	e8c30088 	lwi	r6, r3, 136
    99bc:	bc060010 	beqi	r6, 16		// 99cc
    99c0:	b000ffff 	imm	-1
    99c4:	b9f4f418 	brlid	r15, -3048	// 8ddc <_free_r>
    99c8:	10b30000 	addk	r5, r19, r0
    99cc:	e8d30034 	lwi	r6, r19, 52
    99d0:	bc060010 	beqi	r6, 16		// 99e0
    99d4:	b000ffff 	imm	-1
    99d8:	b9f4f404 	brlid	r15, -3068	// 8ddc <_free_r>
    99dc:	10b30000 	addk	r5, r19, r0
    99e0:	e8730018 	lwi	r3, r19, 24
    99e4:	bc230020 	bnei	r3, 32		// 9a04
    99e8:	e9e10000 	lwi	r15, r1, 0
    99ec:	ea61001c 	lwi	r19, r1, 28
    99f0:	eac10020 	lwi	r22, r1, 32
    99f4:	eae10024 	lwi	r23, r1, 36
    99f8:	eb010028 	lwi	r24, r1, 40
    99fc:	b60f0008 	rtsd	r15, 8
    9a00:	3021002c 	addik	r1, r1, 44
    9a04:	e8730028 	lwi	r3, r19, 40
    9a08:	99fc1800 	brald	r15, r3
    9a0c:	10b30000 	addk	r5, r19, r0
    9a10:	e8d300d8 	lwi	r6, r19, 216
    9a14:	be06ffd8 	beqid	r6, -40		// 99ec
    9a18:	e9e10000 	lwi	r15, r1, 0
    9a1c:	b9f4fd38 	brlid	r15, -712	// 9754 <cleanup_glue>
    9a20:	10b30000 	addk	r5, r19, r0
    9a24:	e9e10000 	lwi	r15, r1, 0
    9a28:	ea61001c 	lwi	r19, r1, 28
    9a2c:	eac10020 	lwi	r22, r1, 32
    9a30:	eae10024 	lwi	r23, r1, 36
    9a34:	eb010028 	lwi	r24, r1, 40
    9a38:	b60f0008 	rtsd	r15, 8
    9a3c:	3021002c 	addik	r1, r1, 44

00009a40 <_wrapup_reent>:
    9a40:	3021ffd8 	addik	r1, r1, -40
    9a44:	fae10024 	swi	r23, r1, 36
    9a48:	f9e10000 	swi	r15, r1, 0
    9a4c:	fa61001c 	swi	r19, r1, 28
    9a50:	fac10020 	swi	r22, r1, 32
    9a54:	be050064 	beqid	r5, 100		// 9ab8
    9a58:	12e50000 	addk	r23, r5, r0
    9a5c:	ead70048 	lwi	r22, r23, 72
    9a60:	bc16002c 	beqi	r22, 44		// 9a8c
    9a64:	ea760004 	lwi	r19, r22, 4
    9a68:	3273ffff 	addik	r19, r19, -1
    9a6c:	be530020 	bltid	r19, 32		// 9a8c
    9a70:	30730002 	addik	r3, r19, 2
    9a74:	60630004 	muli	r3, r3, 4
    9a78:	c863b000 	lw	r3, r3, r22
    9a7c:	99fc1800 	brald	r15, r3
    9a80:	3273ffff 	addik	r19, r19, -1
    9a84:	beb3fff0 	bgeid	r19, -16		// 9a74
    9a88:	30730002 	addik	r3, r19, 2
    9a8c:	e8770028 	lwi	r3, r23, 40
    9a90:	be030014 	beqid	r3, 20		// 9aa4
    9a94:	e9e10000 	lwi	r15, r1, 0
    9a98:	99fc1800 	brald	r15, r3
    9a9c:	10b70000 	addk	r5, r23, r0
    9aa0:	e9e10000 	lwi	r15, r1, 0
    9aa4:	ea61001c 	lwi	r19, r1, 28
    9aa8:	eac10020 	lwi	r22, r1, 32
    9aac:	eae10024 	lwi	r23, r1, 36
    9ab0:	b60f0008 	rtsd	r15, 8
    9ab4:	30210028 	addik	r1, r1, 40
    9ab8:	b0000000 	imm	0
    9abc:	eae0e3e8 	lwi	r23, r0, -7192	// e3e8 <_impure_ptr>
    9ac0:	b810ffa0 	brid	-96		// 9a60
    9ac4:	ead70048 	lwi	r22, r23, 72

00009ac8 <_sniprintf_r>:
    9ac8:	f9010010 	swi	r8, r1, 16
    9acc:	f9210014 	swi	r9, r1, 20
    9ad0:	f9410018 	swi	r10, r1, 24
    9ad4:	3021ff74 	addik	r1, r1, -140
    9ad8:	fa610084 	swi	r19, r1, 132
    9adc:	fac10088 	swi	r22, r1, 136
    9ae0:	f9e10000 	swi	r15, r1, 0
    9ae4:	12670000 	addk	r19, r7, r0
    9ae8:	12c50000 	addk	r22, r5, r0
    9aec:	be470080 	bltid	r7, 128		// 9b6c
    9af0:	10660000 	addk	r3, r6, r0
    9af4:	10e80000 	addk	r7, r8, r0
    9af8:	10800000 	addk	r4, r0, r0
    9afc:	8c932400 	pcmpne	r4, r19, r4
    9b00:	14849800 	rsubk	r4, r4, r19
    9b04:	31200208 	addik	r9, r0, 520
    9b08:	f861001c 	swi	r3, r1, 28
    9b0c:	f861002c 	swi	r3, r1, 44
    9b10:	30c1001c 	addik	r6, r1, 28
    9b14:	3060ffff 	addik	r3, r0, -1
    9b18:	310100a0 	addik	r8, r1, 160
    9b1c:	f8810024 	swi	r4, r1, 36
    9b20:	f8810030 	swi	r4, r1, 48
    9b24:	f5210028 	shi	r9, r1, 40
    9b28:	b0000000 	imm	0
    9b2c:	b9f40748 	brlid	r15, 1864	// a274 <_svfiprintf_r>
    9b30:	f461002a 	shi	r3, r1, 42
    9b34:	3080ffff 	addik	r4, r0, -1
    9b38:	14841801 	cmp	r4, r4, r3
    9b3c:	be440028 	bltid	r4, 40		// 9b64
    9b40:	3080008b 	addik	r4, r0, 139
    9b44:	be13000c 	beqid	r19, 12		// 9b50
    9b48:	e881001c 	lwi	r4, r1, 28
    9b4c:	f0040000 	sbi	r0, r4, 0
    9b50:	e9e10000 	lwi	r15, r1, 0
    9b54:	ea610084 	lwi	r19, r1, 132
    9b58:	eac10088 	lwi	r22, r1, 136
    9b5c:	b60f0008 	rtsd	r15, 8
    9b60:	3021008c 	addik	r1, r1, 140
    9b64:	b810ffe0 	brid	-32		// 9b44
    9b68:	f8960000 	swi	r4, r22, 0
    9b6c:	3060008b 	addik	r3, r0, 139
    9b70:	f8650000 	swi	r3, r5, 0
    9b74:	b810ffdc 	brid	-36		// 9b50
    9b78:	3060ffff 	addik	r3, r0, -1

00009b7c <sniprintf>:
    9b7c:	f8e1000c 	swi	r7, r1, 12
    9b80:	f9010010 	swi	r8, r1, 16
    9b84:	f9210014 	swi	r9, r1, 20
    9b88:	f9410018 	swi	r10, r1, 24
    9b8c:	3021ff74 	addik	r1, r1, -140
    9b90:	fa610084 	swi	r19, r1, 132
    9b94:	fac10088 	swi	r22, r1, 136
    9b98:	f9e10000 	swi	r15, r1, 0
    9b9c:	12660000 	addk	r19, r6, r0
    9ba0:	b0000000 	imm	0
    9ba4:	eac0e3e8 	lwi	r22, r0, -7192	// e3e8 <_impure_ptr>
    9ba8:	be460080 	bltid	r6, 128		// 9c28
    9bac:	10650000 	addk	r3, r5, r0
    9bb0:	10b60000 	addk	r5, r22, r0
    9bb4:	10800000 	addk	r4, r0, r0
    9bb8:	8c862400 	pcmpne	r4, r6, r4
    9bbc:	14843000 	rsubk	r4, r4, r6
    9bc0:	31200208 	addik	r9, r0, 520
    9bc4:	f861001c 	swi	r3, r1, 28
    9bc8:	f861002c 	swi	r3, r1, 44
    9bcc:	30c1001c 	addik	r6, r1, 28
    9bd0:	3060ffff 	addik	r3, r0, -1
    9bd4:	3101009c 	addik	r8, r1, 156
    9bd8:	f8810024 	swi	r4, r1, 36
    9bdc:	f8810030 	swi	r4, r1, 48
    9be0:	f5210028 	shi	r9, r1, 40
    9be4:	b0000000 	imm	0
    9be8:	b9f4068c 	brlid	r15, 1676	// a274 <_svfiprintf_r>
    9bec:	f461002a 	shi	r3, r1, 42
    9bf0:	3080ffff 	addik	r4, r0, -1
    9bf4:	14841801 	cmp	r4, r4, r3
    9bf8:	be440028 	bltid	r4, 40		// 9c20
    9bfc:	3080008b 	addik	r4, r0, 139
    9c00:	be13000c 	beqid	r19, 12		// 9c0c
    9c04:	e881001c 	lwi	r4, r1, 28
    9c08:	f0040000 	sbi	r0, r4, 0
    9c0c:	e9e10000 	lwi	r15, r1, 0
    9c10:	ea610084 	lwi	r19, r1, 132
    9c14:	eac10088 	lwi	r22, r1, 136
    9c18:	b60f0008 	rtsd	r15, 8
    9c1c:	3021008c 	addik	r1, r1, 140
    9c20:	b810ffe0 	brid	-32		// 9c00
    9c24:	f8960000 	swi	r4, r22, 0
    9c28:	3060008b 	addik	r3, r0, 139
    9c2c:	f8760000 	swi	r3, r22, 0
    9c30:	b810ffdc 	brid	-36		// 9c0c
    9c34:	3060ffff 	addik	r3, r0, -1

00009c38 <strcat>:
    9c38:	3021ffe0 	addik	r1, r1, -32
    9c3c:	fa61001c 	swi	r19, r1, 28
    9c40:	f9e10000 	swi	r15, r1, 0
    9c44:	a4650003 	andi	r3, r5, 3
    9c48:	12650000 	addk	r19, r5, r0
    9c4c:	be230054 	bneid	r3, 84		// 9ca0
    9c50:	10850000 	addk	r4, r5, r0
    9c54:	e8650000 	lwi	r3, r5, 0
    9c58:	b000fefe 	imm	-258
    9c5c:	3083feff 	addik	r4, r3, -257
    9c60:	a863ffff 	xori	r3, r3, -1
    9c64:	84641800 	and	r3, r4, r3
    9c68:	b0008080 	imm	-32640
    9c6c:	a4638080 	andi	r3, r3, -32640
    9c70:	be23006c 	bneid	r3, 108		// 9cdc
    9c74:	10e50000 	addk	r7, r5, r0
    9c78:	e9070004 	lwi	r8, r7, 4
    9c7c:	30870004 	addik	r4, r7, 4
    9c80:	b000fefe 	imm	-258
    9c84:	3128feff 	addik	r9, r8, -257
    9c88:	a908ffff 	xori	r8, r8, -1
    9c8c:	85094000 	and	r8, r9, r8
    9c90:	b0008080 	imm	-32640
    9c94:	a5088080 	andi	r8, r8, -32640
    9c98:	be08ffe0 	beqid	r8, -32		// 9c78
    9c9c:	10e40000 	addk	r7, r4, r0
    9ca0:	e0640000 	lbui	r3, r4, 0
    9ca4:	be030018 	beqid	r3, 24		// 9cbc
    9ca8:	10a40000 	addk	r5, r4, r0
    9cac:	e0e40001 	lbui	r7, r4, 1
    9cb0:	30a40001 	addik	r5, r4, 1
    9cb4:	be27fff8 	bneid	r7, -8		// 9cac
    9cb8:	10850000 	addk	r4, r5, r0
    9cbc:	b0000000 	imm	0
    9cc0:	b9f402a4 	brlid	r15, 676	// 9f64 <strcpy>
    9cc4:	80000000 	or	r0, r0, r0
    9cc8:	10730000 	addk	r3, r19, r0
    9ccc:	e9e10000 	lwi	r15, r1, 0
    9cd0:	ea61001c 	lwi	r19, r1, 28
    9cd4:	b60f0008 	rtsd	r15, 8
    9cd8:	30210020 	addik	r1, r1, 32
    9cdc:	b810ffc4 	brid	-60		// 9ca0
    9ce0:	10850000 	addk	r4, r5, r0

00009ce4 <strchr>:
    9ce4:	a4c600ff 	andi	r6, r6, 255
    9ce8:	be06011c 	beqid	r6, 284		// 9e04
    9cec:	a4650003 	andi	r3, r5, 3
    9cf0:	bc0301b4 	beqi	r3, 436		// 9ea4
    9cf4:	e0850000 	lbui	r4, r5, 0
    9cf8:	be04019c 	beqid	r4, 412		// 9e94
    9cfc:	10640000 	addk	r3, r4, r0
    9d00:	88862000 	xor	r4, r6, r4
    9d04:	be240020 	bneid	r4, 32		// 9d24
    9d08:	10650000 	addk	r3, r5, r0
    9d0c:	b80001a0 	bri	416		// 9eac
    9d10:	e0850001 	lbui	r4, r5, 1
    9d14:	10a30000 	addk	r5, r3, r0
    9d18:	be040184 	beqid	r4, 388		// 9e9c
    9d1c:	88e62000 	xor	r7, r6, r4
    9d20:	bc07018c 	beqi	r7, 396		// 9eac
    9d24:	30650001 	addik	r3, r5, 1
    9d28:	a4830003 	andi	r4, r3, 3
    9d2c:	bc24ffe4 	bnei	r4, -28		// 9d10
    9d30:	e8830000 	lwi	r4, r3, 0
    9d34:	60a60100 	muli	r5, r6, 256
    9d38:	80a53000 	or	r5, r5, r6
    9d3c:	b000fefe 	imm	-258
    9d40:	3104feff 	addik	r8, r4, -257
    9d44:	a8e4ffff 	xori	r7, r4, -1
    9d48:	84e83800 	and	r7, r8, r7
    9d4c:	b0000001 	imm	1
    9d50:	61450000 	muli	r10, r5, 0
    9d54:	b0008080 	imm	-32640
    9d58:	a4e78080 	andi	r7, r7, -32640
    9d5c:	be270078 	bneid	r7, 120		// 9dd4
    9d60:	814a2800 	or	r10, r10, r5
    9d64:	888a2000 	xor	r4, r10, r4
    9d68:	b000fefe 	imm	-258
    9d6c:	30a4feff 	addik	r5, r4, -257
    9d70:	a884ffff 	xori	r4, r4, -1
    9d74:	84852000 	and	r4, r5, r4
    9d78:	b0008080 	imm	-32640
    9d7c:	a4848080 	andi	r4, r4, -32640
    9d80:	bc040010 	beqi	r4, 16		// 9d90
    9d84:	b8100054 	brid	84		// 9dd8
    9d88:	e0830000 	lbui	r4, r3, 0
    9d8c:	bc250048 	bnei	r5, 72		// 9dd4
    9d90:	e8830004 	lwi	r4, r3, 4
    9d94:	30e30004 	addik	r7, r3, 4
    9d98:	88aa2000 	xor	r5, r10, r4
    9d9c:	b000fefe 	imm	-258
    9da0:	3124feff 	addik	r9, r4, -257
    9da4:	a884ffff 	xori	r4, r4, -1
    9da8:	b000fefe 	imm	-258
    9dac:	3105feff 	addik	r8, r5, -257
    9db0:	84892000 	and	r4, r9, r4
    9db4:	a8a5ffff 	xori	r5, r5, -1
    9db8:	84a82800 	and	r5, r8, r5
    9dbc:	b0008080 	imm	-32640
    9dc0:	a4848080 	andi	r4, r4, -32640
    9dc4:	b0008080 	imm	-32640
    9dc8:	a4a58080 	andi	r5, r5, -32640
    9dcc:	be04ffc0 	beqid	r4, -64		// 9d8c
    9dd0:	10670000 	addk	r3, r7, r0
    9dd4:	e0830000 	lbui	r4, r3, 0
    9dd8:	bc0400c4 	beqi	r4, 196		// 9e9c
    9ddc:	88862000 	xor	r4, r6, r4
    9de0:	bc24000c 	bnei	r4, 12		// 9dec
    9de4:	b80000c8 	bri	200		// 9eac
    9de8:	bc0500c4 	beqi	r5, 196		// 9eac
    9dec:	e0830001 	lbui	r4, r3, 1
    9df0:	30630001 	addik	r3, r3, 1
    9df4:	be24fff4 	bneid	r4, -12		// 9de8
    9df8:	88a62000 	xor	r5, r6, r4
    9dfc:	b60f0008 	rtsd	r15, 8
    9e00:	10640000 	addk	r3, r4, r0
    9e04:	be03002c 	beqid	r3, 44		// 9e30
    9e08:	10650000 	addk	r3, r5, r0
    9e0c:	e0850000 	lbui	r4, r5, 0
    9e10:	bc240014 	bnei	r4, 20		// 9e24
    9e14:	b8000098 	bri	152		// 9eac
    9e18:	e0850001 	lbui	r4, r5, 1
    9e1c:	be040078 	beqid	r4, 120		// 9e94
    9e20:	10a30000 	addk	r5, r3, r0
    9e24:	30650001 	addik	r3, r5, 1
    9e28:	a4830003 	andi	r4, r3, 3
    9e2c:	bc24ffec 	bnei	r4, -20		// 9e18
    9e30:	e8a30000 	lwi	r5, r3, 0
    9e34:	a8c5ffff 	xori	r6, r5, -1
    9e38:	b000fefe 	imm	-258
    9e3c:	30a5feff 	addik	r5, r5, -257
    9e40:	84a62800 	and	r5, r6, r5
    9e44:	b0008080 	imm	-32640
    9e48:	a4a58080 	andi	r5, r5, -32640
    9e4c:	be250030 	bneid	r5, 48		// 9e7c
    9e50:	10830000 	addk	r4, r3, r0
    9e54:	e8830004 	lwi	r4, r3, 4
    9e58:	b000fefe 	imm	-258
    9e5c:	30a4feff 	addik	r5, r4, -257
    9e60:	a884ffff 	xori	r4, r4, -1
    9e64:	84852000 	and	r4, r5, r4
    9e68:	b0008080 	imm	-32640
    9e6c:	a4848080 	andi	r4, r4, -32640
    9e70:	be04ffe4 	beqid	r4, -28		// 9e54
    9e74:	30630004 	addik	r3, r3, 4
    9e78:	10830000 	addk	r4, r3, r0
    9e7c:	e0a30000 	lbui	r5, r3, 0
    9e80:	bc05002c 	beqi	r5, 44		// 9eac
    9e84:	e0a40001 	lbui	r5, r4, 1
    9e88:	30640001 	addik	r3, r4, 1
    9e8c:	be25fff8 	bneid	r5, -8		// 9e84
    9e90:	10830000 	addk	r4, r3, r0
    9e94:	b60f0008 	rtsd	r15, 8
    9e98:	80000000 	or	r0, r0, r0
    9e9c:	b60f0008 	rtsd	r15, 8
    9ea0:	10640000 	addk	r3, r4, r0
    9ea4:	b810fe8c 	brid	-372		// 9d30
    9ea8:	10650000 	addk	r3, r5, r0
    9eac:	b60f0008 	rtsd	r15, 8
    9eb0:	80000000 	or	r0, r0, r0

00009eb4 <strcmp>:
    9eb4:	81200000 	or	r9, r0, r0

00009eb8 <check_alignment>:
    9eb8:	a4650003 	andi	r3, r5, 3
    9ebc:	a4860003 	andi	r4, r6, 3
    9ec0:	bc230048 	bnei	r3, 72	// 9f08 <try_align_args>
    9ec4:	bc240074 	bnei	r4, 116	// 9f38 <regular_strcmp>

00009ec8 <cmp_loop>:
    9ec8:	c8654a00 	lwr	r3, r5, r9
    9ecc:	c8864a00 	lwr	r4, r6, r9
    9ed0:	80e30400 	pcmpbf	r7, r3, r0
    9ed4:	bc270014 	bnei	r7, 20	// 9ee8 <end_cmp_loop>
    9ed8:	14e41803 	cmpu	r7, r4, r3
    9edc:	bc270078 	bnei	r7, 120	// 9f54 <end_cmp>
    9ee0:	b810ffe8 	brid	-24	// 9ec8 <cmp_loop>
    9ee4:	31290004 	addik	r9, r9, 4

00009ee8 <end_cmp_loop>:
    9ee8:	c0654800 	lbu	r3, r5, r9
    9eec:	c0864800 	lbu	r4, r6, r9
    9ef0:	14e41803 	cmpu	r7, r4, r3
    9ef4:	bc27000c 	bnei	r7, 12	// 9f00 <end_cmp_early>
    9ef8:	be23fff0 	bneid	r3, -16	// 9ee8 <end_cmp_loop>
    9efc:	31290001 	addik	r9, r9, 1

00009f00 <end_cmp_early>:
    9f00:	b60f0008 	rtsd	r15, 8
    9f04:	80603800 	or	r3, r0, r7

00009f08 <try_align_args>:
    9f08:	88e41800 	xor	r7, r4, r3
    9f0c:	bc27002c 	bnei	r7, 44	// 9f38 <regular_strcmp>
    9f10:	35430004 	rsubik	r10, r3, 4

00009f14 <align_loop>:
    9f14:	c0654800 	lbu	r3, r5, r9
    9f18:	c0864800 	lbu	r4, r6, r9
    9f1c:	14e41803 	cmpu	r7, r4, r3
    9f20:	bc270034 	bnei	r7, 52	// 9f54 <end_cmp>
    9f24:	bc030030 	beqi	r3, 48	// 9f54 <end_cmp>
    9f28:	314affff 	addik	r10, r10, -1
    9f2c:	be0aff9c 	beqid	r10, -100	// 9ec8 <cmp_loop>
    9f30:	31290001 	addik	r9, r9, 1
    9f34:	b800ffe0 	bri	-32	// 9f14 <align_loop>

00009f38 <regular_strcmp>:
    9f38:	c0654800 	lbu	r3, r5, r9
    9f3c:	c0864800 	lbu	r4, r6, r9
    9f40:	14e41803 	cmpu	r7, r4, r3
    9f44:	bc270010 	bnei	r7, 16	// 9f54 <end_cmp>
    9f48:	bc03000c 	beqi	r3, 12	// 9f54 <end_cmp>
    9f4c:	b810ffec 	brid	-20	// 9f38 <regular_strcmp>
    9f50:	31290001 	addik	r9, r9, 1

00009f54 <end_cmp>:
    9f54:	b60f0008 	rtsd	r15, 8
    9f58:	80603800 	or	r3, r0, r7
    9f5c:	b60f0008 	rtsd	r15, 8
    9f60:	80000000 	or	r0, r0, r0

00009f64 <strcpy>:
    9f64:	81200000 	or	r9, r0, r0

00009f68 <check_alignment>:
    9f68:	a4650003 	andi	r3, r5, 3
    9f6c:	a4860003 	andi	r4, r6, 3
    9f70:	bc23003c 	bnei	r3, 60	// 9fac <try_align_args>
    9f74:	bc240060 	bnei	r4, 96	// 9fd4 <regular_strcpy>

00009f78 <cpy_loop>:
    9f78:	c8664a00 	lwr	r3, r6, r9
    9f7c:	80801c00 	pcmpbf	r4, r0, r3
    9f80:	bc240010 	bnei	r4, 16	// 9f90 <cpy_bytes>
    9f84:	d8654a00 	swr	r3, r5, r9
    9f88:	b810fff0 	brid	-16	// 9f78 <cpy_loop>
    9f8c:	31290004 	addik	r9, r9, 4

00009f90 <cpy_bytes>:
    9f90:	c0664800 	lbu	r3, r6, r9
    9f94:	d0654800 	sb	r3, r5, r9
    9f98:	3084ffff 	addik	r4, r4, -1
    9f9c:	be24fff4 	bneid	r4, -12	// 9f90 <cpy_bytes>
    9fa0:	31290001 	addik	r9, r9, 1

00009fa4 <cpy_null>:
    9fa4:	b60f0008 	rtsd	r15, 8
    9fa8:	80602800 	or	r3, r0, r5

00009fac <try_align_args>:
    9fac:	88e41800 	xor	r7, r4, r3
    9fb0:	bc270024 	bnei	r7, 36	// 9fd4 <regular_strcpy>
    9fb4:	35430004 	rsubik	r10, r3, 4

00009fb8 <align_loop>:
    9fb8:	c0664800 	lbu	r3, r6, r9
    9fbc:	d0654800 	sb	r3, r5, r9
    9fc0:	be030024 	beqid	r3, 36	// 9fe4 <end_cpy>
    9fc4:	314affff 	addik	r10, r10, -1
    9fc8:	be2afff0 	bneid	r10, -16	// 9fb8 <align_loop>
    9fcc:	31290001 	addik	r9, r9, 1
    9fd0:	b800ffa8 	bri	-88	// 9f78 <cpy_loop>

00009fd4 <regular_strcpy>:
    9fd4:	c0664800 	lbu	r3, r6, r9
    9fd8:	d0654800 	sb	r3, r5, r9
    9fdc:	be23fff8 	bneid	r3, -8	// 9fd4 <regular_strcpy>
    9fe0:	31290001 	addik	r9, r9, 1

00009fe4 <end_cpy>:
    9fe4:	b60f0008 	rtsd	r15, 8
    9fe8:	80602800 	or	r3, r0, r5
    9fec:	b60f0008 	rtsd	r15, 8
    9ff0:	80000000 	or	r0, r0, r0

00009ff4 <__ssprint_r>:
    9ff4:	3021ffb8 	addik	r1, r1, -72
    9ff8:	fa61001c 	swi	r19, r1, 28
    9ffc:	fb010028 	swi	r24, r1, 40
    a000:	fbe10044 	swi	r31, r1, 68
    a004:	f9e10000 	swi	r15, r1, 0
    a008:	fac10020 	swi	r22, r1, 32
    a00c:	fae10024 	swi	r23, r1, 36
    a010:	fb21002c 	swi	r25, r1, 44
    a014:	fb410030 	swi	r26, r1, 48
    a018:	fb610034 	swi	r27, r1, 52
    a01c:	fb810038 	swi	r28, r1, 56
    a020:	fba1003c 	swi	r29, r1, 60
    a024:	fbc10040 	swi	r30, r1, 64
    a028:	e8670008 	lwi	r3, r7, 8
    a02c:	13070000 	addk	r24, r7, r0
    a030:	13e50000 	addk	r31, r5, r0
    a034:	12660000 	addk	r19, r6, r0
    a038:	be030234 	beqid	r3, 564		// a26c
    a03c:	eb270000 	lwi	r25, r7, 0
    a040:	13600000 	addk	r27, r0, r0
    a044:	e8a60000 	lwi	r5, r6, 0
    a048:	12db0000 	addk	r22, r27, r0
    a04c:	e8860008 	lwi	r4, r6, 8
    a050:	be160054 	beqid	r22, 84		// a0a4
    a054:	12e40000 	addk	r23, r4, r0
    a058:	1464b003 	cmpu	r3, r4, r22
    a05c:	bea30058 	bgeid	r3, 88		// a0b4
    a060:	13440000 	addk	r26, r4, r0
    a064:	12f60000 	addk	r23, r22, r0
    a068:	13560000 	addk	r26, r22, r0
    a06c:	10db0000 	addk	r6, r27, r0
    a070:	b000ffff 	imm	-1
    a074:	b9f4bce4 	brlid	r15, -17180	// 5d58 <memmove>
    a078:	10fa0000 	addk	r7, r26, r0
    a07c:	e8930008 	lwi	r4, r19, 8
    a080:	e8d30000 	lwi	r6, r19, 0
    a084:	e8780008 	lwi	r3, r24, 8
    a088:	14972000 	rsubk	r4, r23, r4
    a08c:	10a6d000 	addk	r5, r6, r26
    a090:	f8930008 	swi	r4, r19, 8
    a094:	f8b30000 	swi	r5, r19, 0
    a098:	16d61800 	rsubk	r22, r22, r3
    a09c:	be160190 	beqid	r22, 400		// a22c
    a0a0:	fad80008 	swi	r22, r24, 8
    a0a4:	eb790000 	lwi	r27, r25, 0
    a0a8:	ead90004 	lwi	r22, r25, 4
    a0ac:	b810ffa4 	brid	-92		// a050
    a0b0:	33390008 	addik	r25, r25, 8
    a0b4:	e473000c 	lhui	r3, r19, 12
    a0b8:	a4830480 	andi	r4, r3, 1152
    a0bc:	be04ffb4 	beqid	r4, -76		// a070
    a0c0:	10db0000 	addk	r6, r27, r0
    a0c4:	e8930014 	lwi	r4, r19, 20
    a0c8:	e8d30010 	lwi	r6, r19, 16
    a0cc:	30f60001 	addik	r7, r22, 1
    a0d0:	13842000 	addk	r28, r4, r4
    a0d4:	109c2000 	addk	r4, r28, r4
    a0d8:	13802000 	addk	r28, r0, r4
    a0dc:	93840041 	srl	r28, r4
    a0e0:	939c0041 	srl	r28, r28
    a0e4:	939c0041 	srl	r28, r28
    a0e8:	939c0041 	srl	r28, r28
    a0ec:	939c0041 	srl	r28, r28
    a0f0:	939c0041 	srl	r28, r28
    a0f4:	939c0041 	srl	r28, r28
    a0f8:	939c0041 	srl	r28, r28
    a0fc:	939c0041 	srl	r28, r28
    a100:	939c0041 	srl	r28, r28
    a104:	939c0041 	srl	r28, r28
    a108:	939c0041 	srl	r28, r28
    a10c:	939c0041 	srl	r28, r28
    a110:	939c0041 	srl	r28, r28
    a114:	939c0041 	srl	r28, r28
    a118:	939c0041 	srl	r28, r28
    a11c:	939c0041 	srl	r28, r28
    a120:	939c0041 	srl	r28, r28
    a124:	939c0041 	srl	r28, r28
    a128:	939c0041 	srl	r28, r28
    a12c:	939c0041 	srl	r28, r28
    a130:	939c0041 	srl	r28, r28
    a134:	939c0041 	srl	r28, r28
    a138:	939c0041 	srl	r28, r28
    a13c:	939c0041 	srl	r28, r28
    a140:	939c0041 	srl	r28, r28
    a144:	939c0041 	srl	r28, r28
    a148:	939c0041 	srl	r28, r28
    a14c:	939c0041 	srl	r28, r28
    a150:	939c0041 	srl	r28, r28
    a154:	939c0041 	srl	r28, r28
    a158:	17c62800 	rsubk	r30, r6, r5
    a15c:	139c2000 	addk	r28, r28, r4
    a160:	939c0001 	sra	r28, r28
    a164:	1087f000 	addk	r4, r7, r30
    a168:	1504e003 	cmpu	r8, r4, r28
    a16c:	bea80010 	bgeid	r8, 16		// a17c
    a170:	10fc0000 	addk	r7, r28, r0
    a174:	13840000 	addk	r28, r4, r0
    a178:	10e40000 	addk	r7, r4, r0
    a17c:	a4630400 	andi	r3, r3, 1024
    a180:	be030064 	beqid	r3, 100		// a1e4
    a184:	10bf0000 	addk	r5, r31, r0
    a188:	b000ffff 	imm	-1
    a18c:	b9f4ae04 	brlid	r15, -20988	// 4f90 <_malloc_r>
    a190:	10c70000 	addk	r6, r7, r0
    a194:	be030074 	beqid	r3, 116		// a208
    a198:	13a30000 	addk	r29, r3, r0
    a19c:	10a30000 	addk	r5, r3, r0
    a1a0:	e8d30010 	lwi	r6, r19, 16
    a1a4:	b000ffff 	imm	-1
    a1a8:	b9f4b970 	brlid	r15, -18064	// 5b18 <memcpy>
    a1ac:	10fe0000 	addk	r7, r30, r0
    a1b0:	e473000c 	lhui	r3, r19, 12
    a1b4:	a463fb7f 	andi	r3, r3, -1153
    a1b8:	a0630080 	ori	r3, r3, 128
    a1bc:	f473000c 	shi	r3, r19, 12
    a1c0:	10bdf000 	addk	r5, r29, r30
    a1c4:	17dee000 	rsubk	r30, r30, r28
    a1c8:	12f60000 	addk	r23, r22, r0
    a1cc:	13560000 	addk	r26, r22, r0
    a1d0:	fbb30010 	swi	r29, r19, 16
    a1d4:	f8b30000 	swi	r5, r19, 0
    a1d8:	fb930014 	swi	r28, r19, 20
    a1dc:	b810fe90 	brid	-368		// a06c
    a1e0:	fbd30008 	swi	r30, r19, 8
    a1e4:	b000ffff 	imm	-1
    a1e8:	b9f4c9dc 	brlid	r15, -13860	// 6bc4 <_realloc_r>
    a1ec:	80000000 	or	r0, r0, r0
    a1f0:	be23ffd0 	bneid	r3, -48		// a1c0
    a1f4:	13a30000 	addk	r29, r3, r0
    a1f8:	10bf0000 	addk	r5, r31, r0
    a1fc:	b000ffff 	imm	-1
    a200:	b9f4ebdc 	brlid	r15, -5156	// 8ddc <_free_r>
    a204:	e8d30010 	lwi	r6, r19, 16
    a208:	e493000c 	lhui	r4, r19, 12
    a20c:	3060000c 	addik	r3, r0, 12
    a210:	f87f0000 	swi	r3, r31, 0
    a214:	a0840040 	ori	r4, r4, 64
    a218:	f493000c 	shi	r4, r19, 12
    a21c:	3060ffff 	addik	r3, r0, -1
    a220:	f8180008 	swi	r0, r24, 8
    a224:	b8100010 	brid	16		// a234
    a228:	f8180004 	swi	r0, r24, 4
    a22c:	10760000 	addk	r3, r22, r0
    a230:	fad80004 	swi	r22, r24, 4
    a234:	e9e10000 	lwi	r15, r1, 0
    a238:	ea61001c 	lwi	r19, r1, 28
    a23c:	eac10020 	lwi	r22, r1, 32
    a240:	eae10024 	lwi	r23, r1, 36
    a244:	eb010028 	lwi	r24, r1, 40
    a248:	eb21002c 	lwi	r25, r1, 44
    a24c:	eb410030 	lwi	r26, r1, 48
    a250:	eb610034 	lwi	r27, r1, 52
    a254:	eb810038 	lwi	r28, r1, 56
    a258:	eba1003c 	lwi	r29, r1, 60
    a25c:	ebc10040 	lwi	r30, r1, 64
    a260:	ebe10044 	lwi	r31, r1, 68
    a264:	b60f0008 	rtsd	r15, 8
    a268:	30210048 	addik	r1, r1, 72
    a26c:	b810ffc8 	brid	-56		// a234
    a270:	f8670004 	swi	r3, r7, 4

0000a274 <_svfiprintf_r>:
    a274:	3021ff04 	addik	r1, r1, -252
    a278:	f9e10000 	swi	r15, r1, 0
    a27c:	fa6100d0 	swi	r19, r1, 208
    a280:	fac100d4 	swi	r22, r1, 212
    a284:	fae100d8 	swi	r23, r1, 216
    a288:	fb0100dc 	swi	r24, r1, 220
    a28c:	fb2100e0 	swi	r25, r1, 224
    a290:	fb4100e4 	swi	r26, r1, 228
    a294:	fb6100e8 	swi	r27, r1, 232
    a298:	fb8100ec 	swi	r28, r1, 236
    a29c:	fba100f0 	swi	r29, r1, 240
    a2a0:	fbc100f4 	swi	r30, r1, 244
    a2a4:	fbe100f8 	swi	r31, r1, 248
    a2a8:	e486000c 	lhui	r4, r6, 12
    a2ac:	f8c10104 	swi	r6, r1, 260
    a2b0:	f8a10100 	swi	r5, r1, 256
    a2b4:	a4840080 	andi	r4, r4, 128
    a2b8:	be040014 	beqid	r4, 20		// a2cc
    a2bc:	f901010c 	swi	r8, r1, 268
    a2c0:	e8660010 	lwi	r3, r6, 16
    a2c4:	be031074 	beqid	r3, 4212		// b338
    a2c8:	30c00040 	addik	r6, r0, 64
    a2cc:	30c10058 	addik	r6, r1, 88
    a2d0:	30810057 	addik	r4, r1, 87
    a2d4:	13e70000 	addk	r31, r7, r0
    a2d8:	13460000 	addk	r26, r6, r0
    a2dc:	10600000 	addk	r3, r0, r0
    a2e0:	14a43000 	rsubk	r5, r4, r6
    a2e4:	f8c10098 	swi	r6, r1, 152
    a2e8:	f86100bc 	swi	r3, r1, 188
    a2ec:	f86100b0 	swi	r3, r1, 176
    a2f0:	f881009c 	swi	r4, r1, 156
    a2f4:	f8c10024 	swi	r6, r1, 36
    a2f8:	f861002c 	swi	r3, r1, 44
    a2fc:	f8610028 	swi	r3, r1, 40
    a300:	f8a100c8 	swi	r5, r1, 200
    a304:	e09f0000 	lbui	r4, r31, 0
    a308:	90840060 	sext8	r4, r4
    a30c:	be04008c 	beqid	r4, 140		// a398
    a310:	12df0000 	addk	r22, r31, r0
    a314:	31200025 	addik	r9, r0, 37
    a318:	8ce44c00 	pcmpne	r7, r4, r9
    a31c:	be070ac8 	beqid	r7, 2760		// ade4
    a320:	11600000 	addk	r11, r0, r0
    a324:	b8100018 	brid	24		// a33c
    a328:	127f0000 	addk	r19, r31, r0
    a32c:	8c645c00 	pcmpne	r3, r4, r11
    a330:	be030024 	beqid	r3, 36		// a354
    a334:	16ffb000 	rsubk	r23, r31, r22
    a338:	12760000 	addk	r19, r22, r0
    a33c:	e0f30001 	lbui	r7, r19, 1
    a340:	90870060 	sext8	r4, r7
    a344:	8c644c00 	pcmpne	r3, r4, r9
    a348:	be23ffe4 	bneid	r3, -28		// a32c
    a34c:	32d30001 	addik	r22, r19, 1
    a350:	16ffb000 	rsubk	r23, r31, r22
    a354:	be170044 	beqid	r23, 68		// a398
    a358:	eb21002c 	lwi	r25, r1, 44
    a35c:	e9610028 	lwi	r11, r1, 40
    a360:	fbfa0000 	swi	r31, r26, 0
    a364:	1119b800 	addk	r8, r25, r23
    a368:	316b0001 	addik	r11, r11, 1
    a36c:	f901002c 	swi	r8, r1, 44
    a370:	31000007 	addik	r8, r0, 7
    a374:	fafa0004 	swi	r23, r26, 4
    a378:	f9610028 	swi	r11, r1, 40
    a37c:	156b4001 	cmp	r11, r11, r8
    a380:	be4b0c74 	bltid	r11, 3188		// aff4
    a384:	335a0008 	addik	r26, r26, 8
    a388:	e8c100b0 	lwi	r6, r1, 176
    a38c:	90870060 	sext8	r4, r7
    a390:	10c6b800 	addk	r6, r6, r23
    a394:	f8c100b0 	swi	r6, r1, 176
    a398:	be040ecc 	beqid	r4, 3788		// b264
    a39c:	11600000 	addk	r11, r0, r0
    a3a0:	e1160001 	lbui	r8, r22, 1
    a3a4:	33f60001 	addik	r31, r22, 1
    a3a8:	f001001c 	sbi	r0, r1, 28
    a3ac:	91080060 	sext8	r8, r8
    a3b0:	3300ffff 	addik	r24, r0, -1
    a3b4:	f96100b4 	swi	r11, r1, 180
    a3b8:	f96100a0 	swi	r11, r1, 160
    a3bc:	32600058 	addik	r19, r0, 88
    a3c0:	33ff0001 	addik	r31, r31, 1
    a3c4:	3068ffe0 	addik	r3, r8, -32
    a3c8:	14839803 	cmpu	r4, r3, r19
    a3cc:	be4407f0 	bltid	r4, 2032		// abbc
    a3d0:	60630004 	muli	r3, r3, 4
    a3d4:	b0000000 	imm	0
    a3d8:	3063e0cc 	addik	r3, r3, -7988
    a3dc:	e8630000 	lwi	r3, r3, 0
    a3e0:	98081800 	bra	r3
    a3e4:	e8a100a0 	lwi	r5, r1, 160
    a3e8:	a0a50010 	ori	r5, r5, 16
    a3ec:	f8a100a0 	swi	r5, r1, 160
    a3f0:	e8c100a0 	lwi	r6, r1, 160
    a3f4:	a4860020 	andi	r4, r6, 32
    a3f8:	be040cb0 	beqid	r4, 3248		// b0a8
    a3fc:	a4660010 	andi	r3, r6, 16
    a400:	e861010c 	lwi	r3, r1, 268
    a404:	31000001 	addik	r8, r0, 1
    a408:	f001001c 	sbi	r0, r1, 28
    a40c:	eb830000 	lwi	r28, r3, 0
    a410:	eba30004 	lwi	r29, r3, 4
    a414:	30630008 	addik	r3, r3, 8
    a418:	f861010c 	swi	r3, r1, 268
    a41c:	813ce800 	or	r9, r28, r29
    a420:	10600000 	addk	r3, r0, r0
    a424:	8d291c00 	pcmpne	r9, r9, r3
    a428:	be580010 	bltid	r24, 16		// a438
    a42c:	e8a100a0 	lwi	r5, r1, 160
    a430:	a4a5ff7f 	andi	r5, r5, -129
    a434:	f8a100a0 	swi	r5, r1, 160
    a438:	bc380008 	bnei	r24, 8		// a440
    a43c:	bc0909b0 	beqi	r9, 2480		// adec
    a440:	a8880001 	xori	r4, r8, 1
    a444:	be240b14 	bneid	r4, 2836		// af58
    a448:	a8880002 	xori	r4, r8, 2
    a44c:	be1d0d0c 	beqid	r29, 3340		// b158
    a450:	30a00009 	addik	r5, r0, 9
    a454:	32610058 	addik	r19, r1, 88
    a458:	10bc0000 	addk	r5, r28, r0
    a45c:	31000000 	addik	r8, r0, 0
    a460:	30e0000a 	addik	r7, r0, 10
    a464:	b0000000 	imm	0
    a468:	b9f41dc4 	brlid	r15, 7620	// c22c <__umoddi3>
    a46c:	10dd0000 	addk	r6, r29, r0
    a470:	10bc0000 	addk	r5, r28, r0
    a474:	10dd0000 	addk	r6, r29, r0
    a478:	30630030 	addik	r3, r3, 48
    a47c:	31000000 	addik	r8, r0, 0
    a480:	30e0000a 	addik	r7, r0, 10
    a484:	b0000000 	imm	0
    a488:	b9f411c0 	brlid	r15, 4544	// b648 <__udivdi3>
    a48c:	f073ffff 	sbi	r3, r19, -1
    a490:	13830000 	addk	r28, r3, r0
    a494:	80632000 	or	r3, r3, r4
    a498:	3273ffff 	addik	r19, r19, -1
    a49c:	be23ffbc 	bneid	r3, -68		// a458
    a4a0:	13a40000 	addk	r29, r4, r0
    a4a4:	e8a10098 	lwi	r5, r1, 152
    a4a8:	fa6100b8 	swi	r19, r1, 184
    a4ac:	16732800 	rsubk	r19, r19, r5
    a4b0:	15789801 	cmp	r11, r24, r19
    a4b4:	beab0970 	bgeid	r11, 2416		// ae24
    a4b8:	fa6100a4 	swi	r19, r1, 164
    a4bc:	b8100968 	brid	2408		// ae24
    a4c0:	fb0100a4 	swi	r24, r1, 164
    a4c4:	e8a100a0 	lwi	r5, r1, 160
    a4c8:	a0a50010 	ori	r5, r5, 16
    a4cc:	f8a100a0 	swi	r5, r1, 160
    a4d0:	e8c100a0 	lwi	r6, r1, 160
    a4d4:	a4860020 	andi	r4, r6, 32
    a4d8:	be040c04 	beqid	r4, 3076		// b0dc
    a4dc:	a4660010 	andi	r3, r6, 16
    a4e0:	e861010c 	lwi	r3, r1, 268
    a4e4:	e881010c 	lwi	r4, r1, 268
    a4e8:	f001001c 	sbi	r0, r1, 28
    a4ec:	eb830000 	lwi	r28, r3, 0
    a4f0:	eba30004 	lwi	r29, r3, 4
    a4f4:	30840008 	addik	r4, r4, 8
    a4f8:	10600000 	addk	r3, r0, r0
    a4fc:	813ce800 	or	r9, r28, r29
    a500:	f881010c 	swi	r4, r1, 268
    a504:	8d291c00 	pcmpne	r9, r9, r3
    a508:	b810ff20 	brid	-224		// a428
    a50c:	11030000 	addk	r8, r3, r0
    a510:	e8c1010c 	lwi	r6, r1, 268
    a514:	e881010c 	lwi	r4, r1, 268
    a518:	e8c60000 	lwi	r6, r6, 0
    a51c:	30640004 	addik	r3, r4, 4
    a520:	bea60c1c 	bgeid	r6, 3100		// b13c
    a524:	f8c100b4 	swi	r6, r1, 180
    a528:	14a60000 	rsubk	r5, r6, r0
    a52c:	f861010c 	swi	r3, r1, 268
    a530:	f8a100b4 	swi	r5, r1, 180
    a534:	e8c100a0 	lwi	r6, r1, 160
    a538:	e11f0000 	lbui	r8, r31, 0
    a53c:	a0c60004 	ori	r6, r6, 4
    a540:	f8c100a0 	swi	r6, r1, 160
    a544:	b810fe7c 	brid	-388		// a3c0
    a548:	91080060 	sext8	r8, r8
    a54c:	e861010c 	lwi	r3, r1, 268
    a550:	f001001c 	sbi	r0, r1, 28
    a554:	30830004 	addik	r4, r3, 4
    a558:	e8630000 	lwi	r3, r3, 0
    a55c:	f881010c 	swi	r4, r1, 268
    a560:	be030e2c 	beqid	r3, 3628		// b38c
    a564:	f86100b8 	swi	r3, r1, 184
    a568:	be580ce8 	bltid	r24, 3304		// b250
    a56c:	e8a100b8 	lwi	r5, r1, 184
    a570:	10f80000 	addk	r7, r24, r0
    a574:	b0000000 	imm	0
    a578:	b9f40f18 	brlid	r15, 3864	// b490 <memchr>
    a57c:	10c00000 	addk	r6, r0, r0
    a580:	be030eb8 	beqid	r3, 3768		// b438
    a584:	e88100b8 	lwi	r4, r1, 184
    a588:	16641800 	rsubk	r19, r4, r3
    a58c:	1493c001 	cmp	r4, r19, r24
    a590:	bca40008 	bgei	r4, 8		// a598
    a594:	12780000 	addk	r19, r24, r0
    a598:	b8100880 	brid	2176		// ae18
    a59c:	13000000 	addk	r24, r0, r0
    a5a0:	e8c100a0 	lwi	r6, r1, 160
    a5a4:	e11f0000 	lbui	r8, r31, 0
    a5a8:	a0c60020 	ori	r6, r6, 32
    a5ac:	f8c100a0 	swi	r6, r1, 160
    a5b0:	b810fe10 	brid	-496		// a3c0
    a5b4:	91080060 	sext8	r8, r8
    a5b8:	e861010c 	lwi	r3, r1, 268
    a5bc:	e88100a0 	lwi	r4, r1, 160
    a5c0:	30a00030 	addik	r5, r0, 48
    a5c4:	eb830000 	lwi	r28, r3, 0
    a5c8:	30630004 	addik	r3, r3, 4
    a5cc:	f861010c 	swi	r3, r1, 268
    a5d0:	b0000000 	imm	0
    a5d4:	3060e0b0 	addik	r3, r0, -8016
    a5d8:	a0840002 	ori	r4, r4, 2
    a5dc:	13a00000 	addk	r29, r0, r0
    a5e0:	30c00078 	addik	r6, r0, 120
    a5e4:	f88100a0 	swi	r4, r1, 160
    a5e8:	f0a10020 	sbi	r5, r1, 32
    a5ec:	f0c10021 	sbi	r6, r1, 33
    a5f0:	8d3de400 	pcmpne	r9, r29, r28
    a5f4:	f86100bc 	swi	r3, r1, 188
    a5f8:	31000002 	addik	r8, r0, 2
    a5fc:	b810fe2c 	brid	-468		// a428
    a600:	f001001c 	sbi	r0, r1, 28
    a604:	e8c100a0 	lwi	r6, r1, 160
    a608:	a4660020 	andi	r3, r6, 32
    a60c:	be03063c 	beqid	r3, 1596		// ac48
    a610:	f161001c 	sbi	r11, r1, 28
    a614:	e861010c 	lwi	r3, r1, 268
    a618:	e8830004 	lwi	r4, r3, 4
    a61c:	eb830000 	lwi	r28, r3, 0
    a620:	30630008 	addik	r3, r3, 8
    a624:	13a40000 	addk	r29, r4, r0
    a628:	f861010c 	swi	r3, r1, 268
    a62c:	bc440660 	blti	r4, 1632		// ac8c
    a630:	813ce800 	or	r9, r28, r29
    a634:	10600000 	addk	r3, r0, r0
    a638:	8d291c00 	pcmpne	r9, r9, r3
    a63c:	b810fdec 	brid	-532		// a428
    a640:	31000001 	addik	r8, r0, 1
    a644:	e8a1010c 	lwi	r5, r1, 268
    a648:	e8c1010c 	lwi	r6, r1, 268
    a64c:	30800001 	addik	r4, r0, 1
    a650:	e0a50000 	lbui	r5, r5, 0
    a654:	f88100a4 	swi	r4, r1, 164
    a658:	30c60004 	addik	r6, r6, 4
    a65c:	12640000 	addk	r19, r4, r0
    a660:	30810030 	addik	r4, r1, 48
    a664:	f0a10030 	sbi	r5, r1, 48
    a668:	f001001c 	sbi	r0, r1, 28
    a66c:	f8c1010c 	swi	r6, r1, 268
    a670:	f88100b8 	swi	r4, r1, 184
    a674:	11400000 	addk	r10, r0, r0
    a678:	130a0000 	addk	r24, r10, r0
    a67c:	e8a100a0 	lwi	r5, r1, 160
    a680:	a6c50002 	andi	r22, r5, 2
    a684:	be160018 	beqid	r22, 24		// a69c
    a688:	e88100a0 	lwi	r4, r1, 160
    a68c:	e88100a4 	lwi	r4, r1, 164
    a690:	30840002 	addik	r4, r4, 2
    a694:	f88100a4 	swi	r4, r1, 164
    a698:	e88100a0 	lwi	r4, r1, 160
    a69c:	a4840084 	andi	r4, r4, 132
    a6a0:	be2406dc 	bneid	r4, 1756		// ad7c
    a6a4:	f88100a8 	swi	r4, r1, 168
    a6a8:	e8a100b4 	lwi	r5, r1, 180
    a6ac:	e88100a4 	lwi	r4, r1, 164
    a6b0:	17642800 	rsubk	r27, r4, r5
    a6b4:	be7b06cc 	bleid	r27, 1740		// ad80
    a6b8:	eb21002c 	lwi	r25, r1, 44
    a6bc:	32e00010 	addik	r23, r0, 16	// 10 <_vector_interrupt>
    a6c0:	155bb801 	cmp	r10, r27, r23
    a6c4:	beaa0098 	bgeid	r10, 152		// a75c
    a6c8:	e9610028 	lwi	r11, r1, 40
    a6cc:	fb8100c0 	swi	r28, r1, 192
    a6d0:	fba100c4 	swi	r29, r1, 196
    a6d4:	33c00007 	addik	r30, r0, 7
    a6d8:	13930000 	addk	r28, r19, r0
    a6dc:	eba10100 	lwi	r29, r1, 256
    a6e0:	b8100014 	brid	20		// a6f4
    a6e4:	ea610104 	lwi	r19, r1, 260
    a6e8:	337bfff0 	addik	r27, r27, -16
    a6ec:	147bb801 	cmp	r3, r27, r23
    a6f0:	bca30060 	bgei	r3, 96		// a750
    a6f4:	b0000000 	imm	0
    a6f8:	30a0e230 	addik	r5, r0, -7632	// e230 <blanks.3827>
    a6fc:	316b0001 	addik	r11, r11, 1
    a700:	33390010 	addik	r25, r25, 16
    a704:	30c00010 	addik	r6, r0, 16	// 10 <_vector_interrupt>
    a708:	f8ba0000 	swi	r5, r26, 0
    a70c:	f8da0004 	swi	r6, r26, 4
    a710:	fb21002c 	swi	r25, r1, 44
    a714:	f9610028 	swi	r11, r1, 40
    a718:	146bf001 	cmp	r3, r11, r30
    a71c:	bea3ffcc 	bgeid	r3, -52		// a6e8
    a720:	335a0008 	addik	r26, r26, 8
    a724:	10bd0000 	addk	r5, r29, r0
    a728:	10d30000 	addk	r6, r19, r0
    a72c:	b9f4f8c8 	brlid	r15, -1848	// 9ff4 <__ssprint_r>
    a730:	30e10024 	addik	r7, r1, 36
    a734:	be23031c 	bneid	r3, 796		// aa50
    a738:	337bfff0 	addik	r27, r27, -16
    a73c:	147bb801 	cmp	r3, r27, r23
    a740:	33410058 	addik	r26, r1, 88
    a744:	eb21002c 	lwi	r25, r1, 44
    a748:	be43ffac 	bltid	r3, -84		// a6f4
    a74c:	e9610028 	lwi	r11, r1, 40
    a750:	127c0000 	addk	r19, r28, r0
    a754:	eb8100c0 	lwi	r28, r1, 192
    a758:	eba100c4 	lwi	r29, r1, 196
    a75c:	b0000000 	imm	0
    a760:	3060e230 	addik	r3, r0, -7632	// e230 <blanks.3827>
    a764:	316b0001 	addik	r11, r11, 1
    a768:	1339d800 	addk	r25, r25, r27
    a76c:	31400007 	addik	r10, r0, 7
    a770:	f87a0000 	swi	r3, r26, 0
    a774:	fb7a0004 	swi	r27, r26, 4
    a778:	fb21002c 	swi	r25, r1, 44
    a77c:	154b5001 	cmp	r10, r11, r10
    a780:	be4a0990 	bltid	r10, 2448		// b110
    a784:	f9610028 	swi	r11, r1, 40
    a788:	e141001c 	lbui	r10, r1, 28
    a78c:	335a0008 	addik	r26, r26, 8
    a790:	914a0060 	sext8	r10, r10
    a794:	be0a0034 	beqid	r10, 52		// a7c8
    a798:	3141001c 	addik	r10, r1, 28
    a79c:	316b0001 	addik	r11, r11, 1
    a7a0:	f95a0000 	swi	r10, r26, 0
    a7a4:	33390001 	addik	r25, r25, 1
    a7a8:	30800001 	addik	r4, r0, 1
    a7ac:	31400007 	addik	r10, r0, 7
    a7b0:	f89a0004 	swi	r4, r26, 4
    a7b4:	fb21002c 	swi	r25, r1, 44
    a7b8:	f9610028 	swi	r11, r1, 40
    a7bc:	154b5001 	cmp	r10, r11, r10
    a7c0:	be4a05c8 	bltid	r10, 1480		// ad88
    a7c4:	335a0008 	addik	r26, r26, 8
    a7c8:	be16003c 	beqid	r22, 60		// a804
    a7cc:	e88100a8 	lwi	r4, r1, 168
    a7d0:	31410020 	addik	r10, r1, 32
    a7d4:	316b0001 	addik	r11, r11, 1
    a7d8:	f95a0000 	swi	r10, r26, 0
    a7dc:	33390002 	addik	r25, r25, 2
    a7e0:	30a00002 	addik	r5, r0, 2
    a7e4:	31400007 	addik	r10, r0, 7
    a7e8:	f8ba0004 	swi	r5, r26, 4
    a7ec:	fb21002c 	swi	r25, r1, 44
    a7f0:	f9610028 	swi	r11, r1, 40
    a7f4:	154b5001 	cmp	r10, r11, r10
    a7f8:	be4a081c 	bltid	r10, 2076		// b014
    a7fc:	335a0008 	addik	r26, r26, 8
    a800:	e88100a8 	lwi	r4, r1, 168
    a804:	aae40080 	xori	r23, r4, 128
    a808:	be17063c 	beqid	r23, 1596		// ae44
    a80c:	e8a100b4 	lwi	r5, r1, 180
    a810:	16d3c000 	rsubk	r22, r19, r24
    a814:	be7600f0 	bleid	r22, 240		// a904
    a818:	e88100b8 	lwi	r4, r1, 184
    a81c:	33000010 	addik	r24, r0, 16	// 10 <_vector_interrupt>
    a820:	14f6c001 	cmp	r7, r22, r24
    a824:	bca7008c 	bgei	r7, 140		// a8b0
    a828:	fb8100a8 	swi	r28, r1, 168
    a82c:	fba100ac 	swi	r29, r1, 172
    a830:	32e00007 	addik	r23, r0, 7
    a834:	eb610100 	lwi	r27, r1, 256
    a838:	b8100014 	brid	20		// a84c
    a83c:	eba10104 	lwi	r29, r1, 260
    a840:	32d6fff0 	addik	r22, r22, -16
    a844:	1476c001 	cmp	r3, r22, r24
    a848:	bca30060 	bgei	r3, 96		// a8a8
    a84c:	b0000000 	imm	0
    a850:	3080e240 	addik	r4, r0, -7616	// e240 <zeroes.3828>
    a854:	316b0001 	addik	r11, r11, 1
    a858:	33390010 	addik	r25, r25, 16
    a85c:	30a00010 	addik	r5, r0, 16	// 10 <_vector_interrupt>
    a860:	f89a0000 	swi	r4, r26, 0
    a864:	f8ba0004 	swi	r5, r26, 4
    a868:	fb21002c 	swi	r25, r1, 44
    a86c:	f9610028 	swi	r11, r1, 40
    a870:	146bb801 	cmp	r3, r11, r23
    a874:	bea3ffcc 	bgeid	r3, -52		// a840
    a878:	335a0008 	addik	r26, r26, 8
    a87c:	10bb0000 	addk	r5, r27, r0
    a880:	10dd0000 	addk	r6, r29, r0
    a884:	b9f4f770 	brlid	r15, -2192	// 9ff4 <__ssprint_r>
    a888:	30e10024 	addik	r7, r1, 36
    a88c:	be2301c4 	bneid	r3, 452		// aa50
    a890:	32d6fff0 	addik	r22, r22, -16
    a894:	1476c001 	cmp	r3, r22, r24
    a898:	33410058 	addik	r26, r1, 88
    a89c:	eb21002c 	lwi	r25, r1, 44
    a8a0:	be43ffac 	bltid	r3, -84		// a84c
    a8a4:	e9610028 	lwi	r11, r1, 40
    a8a8:	eb8100a8 	lwi	r28, r1, 168
    a8ac:	eba100ac 	lwi	r29, r1, 172
    a8b0:	b0000000 	imm	0
    a8b4:	30c0e240 	addik	r6, r0, -7616	// e240 <zeroes.3828>
    a8b8:	316b0001 	addik	r11, r11, 1
    a8bc:	1339b000 	addk	r25, r25, r22
    a8c0:	fada0004 	swi	r22, r26, 4
    a8c4:	32c00007 	addik	r22, r0, 7
    a8c8:	f8da0000 	swi	r6, r26, 0
    a8cc:	fb21002c 	swi	r25, r1, 44
    a8d0:	f9610028 	swi	r11, r1, 40
    a8d4:	16cbb001 	cmp	r22, r11, r22
    a8d8:	beb60028 	bgeid	r22, 40		// a900
    a8dc:	335a0008 	addik	r26, r26, 8
    a8e0:	e8a10100 	lwi	r5, r1, 256
    a8e4:	e8c10104 	lwi	r6, r1, 260
    a8e8:	b9f4f70c 	brlid	r15, -2292	// 9ff4 <__ssprint_r>
    a8ec:	30e10024 	addik	r7, r1, 36
    a8f0:	be230160 	bneid	r3, 352		// aa50
    a8f4:	eb21002c 	lwi	r25, r1, 44
    a8f8:	e9610028 	lwi	r11, r1, 40
    a8fc:	33410058 	addik	r26, r1, 88
    a900:	e88100b8 	lwi	r4, r1, 184
    a904:	316b0001 	addik	r11, r11, 1
    a908:	13399800 	addk	r25, r25, r19
    a90c:	31200007 	addik	r9, r0, 7
    a910:	f89a0000 	swi	r4, r26, 0
    a914:	f9610028 	swi	r11, r1, 40
    a918:	fa7a0004 	swi	r19, r26, 4
    a91c:	fb21002c 	swi	r25, r1, 44
    a920:	156b4801 	cmp	r11, r11, r9
    a924:	be4b0614 	bltid	r11, 1556		// af38
    a928:	309a0008 	addik	r4, r26, 8
    a92c:	e8a100a0 	lwi	r5, r1, 160
    a930:	a5050004 	andi	r8, r5, 4
    a934:	be080478 	beqid	r8, 1144		// adac
    a938:	10f90000 	addk	r7, r25, r0
    a93c:	e8c100b4 	lwi	r6, r1, 180
    a940:	e86100a4 	lwi	r3, r1, 164
    a944:	16633000 	rsubk	r19, r3, r6
    a948:	be730464 	bleid	r19, 1124		// adac
    a94c:	32e00010 	addik	r23, r0, 16	// 10 <_vector_interrupt>
    a950:	14f3b801 	cmp	r7, r19, r23
    a954:	bea70080 	bgeid	r7, 128		// a9d4
    a958:	e9610028 	lwi	r11, r1, 40
    a95c:	32c00007 	addik	r22, r0, 7
    a960:	eb010100 	lwi	r24, r1, 256
    a964:	b8100014 	brid	20		// a978
    a968:	eb410104 	lwi	r26, r1, 260
    a96c:	3273fff0 	addik	r19, r19, -16
    a970:	1473b801 	cmp	r3, r19, r23
    a974:	bca30060 	bgei	r3, 96		// a9d4
    a978:	b0000000 	imm	0
    a97c:	30a0e230 	addik	r5, r0, -7632	// e230 <blanks.3827>
    a980:	316b0001 	addik	r11, r11, 1
    a984:	33390010 	addik	r25, r25, 16
    a988:	30c00010 	addik	r6, r0, 16	// 10 <_vector_interrupt>
    a98c:	f8a40000 	swi	r5, r4, 0
    a990:	f8c40004 	swi	r6, r4, 4
    a994:	fb21002c 	swi	r25, r1, 44
    a998:	f9610028 	swi	r11, r1, 40
    a99c:	146bb001 	cmp	r3, r11, r22
    a9a0:	bea3ffcc 	bgeid	r3, -52		// a96c
    a9a4:	30840008 	addik	r4, r4, 8
    a9a8:	10b80000 	addk	r5, r24, r0
    a9ac:	10da0000 	addk	r6, r26, r0
    a9b0:	b9f4f644 	brlid	r15, -2492	// 9ff4 <__ssprint_r>
    a9b4:	30e10024 	addik	r7, r1, 36
    a9b8:	be230098 	bneid	r3, 152		// aa50
    a9bc:	3273fff0 	addik	r19, r19, -16
    a9c0:	1473b801 	cmp	r3, r19, r23
    a9c4:	30810058 	addik	r4, r1, 88
    a9c8:	eb21002c 	lwi	r25, r1, 44
    a9cc:	be43ffac 	bltid	r3, -84		// a978
    a9d0:	e9610028 	lwi	r11, r1, 40
    a9d4:	b0000000 	imm	0
    a9d8:	3060e230 	addik	r3, r0, -7632	// e230 <blanks.3827>
    a9dc:	316b0001 	addik	r11, r11, 1
    a9e0:	10f3c800 	addk	r7, r19, r25
    a9e4:	31000007 	addik	r8, r0, 7
    a9e8:	f9610028 	swi	r11, r1, 40
    a9ec:	f8640000 	swi	r3, r4, 0
    a9f0:	fa640004 	swi	r19, r4, 4
    a9f4:	156b4001 	cmp	r11, r11, r8
    a9f8:	beab03b4 	bgeid	r11, 948		// adac
    a9fc:	f8e1002c 	swi	r7, r1, 44
    aa00:	e8a10100 	lwi	r5, r1, 256
    aa04:	e8c10104 	lwi	r6, r1, 260
    aa08:	b9f4f5ec 	brlid	r15, -2580	// 9ff4 <__ssprint_r>
    aa0c:	30e10024 	addik	r7, r1, 36
    aa10:	be230040 	bneid	r3, 64		// aa50
    aa14:	e88100a4 	lwi	r4, r1, 164
    aa18:	e8a100b4 	lwi	r5, r1, 180
    aa1c:	15052001 	cmp	r8, r5, r4
    aa20:	bea803a0 	bgeid	r8, 928		// adc0
    aa24:	e8e1002c 	lwi	r7, r1, 44
    aa28:	e8c100b0 	lwi	r6, r1, 176
    aa2c:	10850000 	addk	r4, r5, r0
    aa30:	10c62000 	addk	r6, r6, r4
    aa34:	be07039c 	beqid	r7, 924		// add0
    aa38:	f8c100b0 	swi	r6, r1, 176
    aa3c:	e8a10100 	lwi	r5, r1, 256
    aa40:	e8c10104 	lwi	r6, r1, 260
    aa44:	b9f4f5b0 	brlid	r15, -2640	// 9ff4 <__ssprint_r>
    aa48:	30e10024 	addik	r7, r1, 36
    aa4c:	bc030384 	beqi	r3, 900		// add0
    aa50:	e8610104 	lwi	r3, r1, 260
    aa54:	e483000c 	lhui	r4, r3, 12
    aa58:	a4840040 	andi	r4, r4, 64
    aa5c:	be040014 	beqid	r4, 20		// aa70
    aa60:	e86100b0 	lwi	r3, r1, 176
    aa64:	3080ffff 	addik	r4, r0, -1
    aa68:	f88100b0 	swi	r4, r1, 176
    aa6c:	e86100b0 	lwi	r3, r1, 176
    aa70:	e9e10000 	lwi	r15, r1, 0
    aa74:	ea6100d0 	lwi	r19, r1, 208
    aa78:	eac100d4 	lwi	r22, r1, 212
    aa7c:	eae100d8 	lwi	r23, r1, 216
    aa80:	eb0100dc 	lwi	r24, r1, 220
    aa84:	eb2100e0 	lwi	r25, r1, 224
    aa88:	eb4100e4 	lwi	r26, r1, 228
    aa8c:	eb6100e8 	lwi	r27, r1, 232
    aa90:	eb8100ec 	lwi	r28, r1, 236
    aa94:	eba100f0 	lwi	r29, r1, 240
    aa98:	ebc100f4 	lwi	r30, r1, 244
    aa9c:	ebe100f8 	lwi	r31, r1, 248
    aaa0:	b60f0008 	rtsd	r15, 8
    aaa4:	302100fc 	addik	r1, r1, 252
    aaa8:	b0000000 	imm	0
    aaac:	3080e09c 	addik	r4, r0, -8036
    aab0:	e8a100a0 	lwi	r5, r1, 160
    aab4:	f161001c 	sbi	r11, r1, 28
    aab8:	f88100bc 	swi	r4, r1, 188
    aabc:	a4850020 	andi	r4, r5, 32
    aac0:	be040144 	beqid	r4, 324		// ac04
    aac4:	30600058 	addik	r3, r0, 88
    aac8:	e8c1010c 	lwi	r6, r1, 268
    aacc:	eb860000 	lwi	r28, r6, 0
    aad0:	eba60004 	lwi	r29, r6, 4
    aad4:	30c60008 	addik	r6, r6, 8
    aad8:	f8c1010c 	swi	r6, r1, 268
    aadc:	813ce800 	or	r9, r28, r29
    aae0:	10800000 	addk	r4, r0, r0
    aae4:	8d292400 	pcmpne	r9, r9, r4
    aae8:	be09028c 	beqid	r9, 652		// ad74
    aaec:	31000002 	addik	r8, r0, 2
    aaf0:	e8c100a0 	lwi	r6, r1, 160
    aaf4:	a4860001 	andi	r4, r6, 1
    aaf8:	bc04027c 	beqi	r4, 636		// ad74
    aafc:	30800030 	addik	r4, r0, 48
    ab00:	a0c60002 	ori	r6, r6, 2
    ab04:	f0810020 	sbi	r4, r1, 32
    ab08:	f0610021 	sbi	r3, r1, 33
    ab0c:	f8c100a0 	swi	r6, r1, 160
    ab10:	31200001 	addik	r9, r0, 1
    ab14:	b810f914 	brid	-1772		// a428
    ab18:	f001001c 	sbi	r0, r1, 28
    ab1c:	e11f0000 	lbui	r8, r31, 0
    ab20:	91080060 	sext8	r8, r8
    ab24:	a868006c 	xori	r3, r8, 108
    ab28:	be03070c 	beqid	r3, 1804		// b234
    ab2c:	e8a100a0 	lwi	r5, r1, 160
    ab30:	a0a50010 	ori	r5, r5, 16
    ab34:	b810f88c 	brid	-1908		// a3c0
    ab38:	f8a100a0 	swi	r5, r1, 160
    ab3c:	e88100a0 	lwi	r4, r1, 160
    ab40:	a4640020 	andi	r3, r4, 32
    ab44:	be23063c 	bneid	r3, 1596		// b180
    ab48:	f161001c 	sbi	r11, r1, 28
    ab4c:	10640000 	addk	r3, r4, r0
    ab50:	a4840010 	andi	r4, r4, 16
    ab54:	be04079c 	beqid	r4, 1948		// b2f0
    ab58:	a4630040 	andi	r3, r3, 64
    ab5c:	e881010c 	lwi	r4, r1, 268
    ab60:	e8a100b0 	lwi	r5, r1, 176
    ab64:	e8640000 	lwi	r3, r4, 0
    ab68:	30840004 	addik	r4, r4, 4
    ab6c:	f881010c 	swi	r4, r1, 268
    ab70:	b810f794 	brid	-2156		// a304
    ab74:	f8a30000 	swi	r5, r3, 0
    ab78:	e86100a0 	lwi	r3, r1, 160
    ab7c:	e11f0000 	lbui	r8, r31, 0
    ab80:	a0630040 	ori	r3, r3, 64
    ab84:	f86100a0 	swi	r3, r1, 160
    ab88:	b810f838 	brid	-1992		// a3c0
    ab8c:	91080060 	sext8	r8, r8
    ab90:	e8a100a0 	lwi	r5, r1, 160
    ab94:	e11f0000 	lbui	r8, r31, 0
    ab98:	a0a50001 	ori	r5, r5, 1
    ab9c:	f8a100a0 	swi	r5, r1, 160
    aba0:	b810f820 	brid	-2016		// a3c0
    aba4:	91080060 	sext8	r8, r8
    aba8:	be2b05d0 	bneid	r11, 1488		// b178
    abac:	e11f0000 	lbui	r8, r31, 0
    abb0:	31600020 	addik	r11, r0, 32	// 20 <_vector_hw_exception>
    abb4:	b810f80c 	brid	-2036		// a3c0
    abb8:	91080060 	sext8	r8, r8
    abbc:	be0806a8 	beqid	r8, 1704		// b264
    abc0:	f161001c 	sbi	r11, r1, 28
    abc4:	30800001 	addik	r4, r0, 1
    abc8:	f88100a4 	swi	r4, r1, 164
    abcc:	12640000 	addk	r19, r4, r0
    abd0:	30810030 	addik	r4, r1, 48
    abd4:	f1010030 	sbi	r8, r1, 48
    abd8:	f001001c 	sbi	r0, r1, 28
    abdc:	b810fa98 	brid	-1384		// a674
    abe0:	f88100b8 	swi	r4, r1, 184
    abe4:	b0000000 	imm	0
    abe8:	3060e0b0 	addik	r3, r0, -8016
    abec:	e8a100a0 	lwi	r5, r1, 160
    abf0:	f161001c 	sbi	r11, r1, 28
    abf4:	f86100bc 	swi	r3, r1, 188
    abf8:	a4850020 	andi	r4, r5, 32
    abfc:	be24fecc 	bneid	r4, -308		// aac8
    ac00:	30600078 	addik	r3, r0, 120
    ac04:	a4e50010 	andi	r7, r5, 16
    ac08:	be2705f8 	bneid	r7, 1528		// b200
    ac0c:	e8c1010c 	lwi	r6, r1, 268
    ac10:	a4850040 	andi	r4, r5, 64
    ac14:	bc040700 	beqi	r4, 1792		// b314
    ac18:	13a70000 	addk	r29, r7, r0
    ac1c:	e7860000 	lhui	r28, r6, 0
    ac20:	30c60004 	addik	r6, r6, 4
    ac24:	b810feb8 	brid	-328		// aadc
    ac28:	f8c1010c 	swi	r6, r1, 268
    ac2c:	e8a100a0 	lwi	r5, r1, 160
    ac30:	f161001c 	sbi	r11, r1, 28
    ac34:	a0a50010 	ori	r5, r5, 16
    ac38:	10c50000 	addk	r6, r5, r0
    ac3c:	a4660020 	andi	r3, r6, 32
    ac40:	be23f9d4 	bneid	r3, -1580		// a614
    ac44:	f8a100a0 	swi	r5, r1, 160
    ac48:	a4660010 	andi	r3, r6, 16
    ac4c:	bc23056c 	bnei	r3, 1388		// b1b8
    ac50:	a4860040 	andi	r4, r6, 64
    ac54:	be040630 	beqid	r4, 1584		// b284
    ac58:	e881010c 	lwi	r4, r1, 268
    ac5c:	e861010c 	lwi	r3, r1, 268
    ac60:	eb830000 	lwi	r28, r3, 0
    ac64:	30630004 	addik	r3, r3, 4
    ac68:	939c0061 	sext16	r28, r28
    ac6c:	1380e000 	addk	r28, r0, r28
    ac70:	03bce000 	add	r29, r28, r28
    ac74:	0ba00000 	addc	r29, r0, r0
    ac78:	bc1d0008 	beqi	r29, 8		// ac80
    ac7c:	23a0ffff 	addi	r29, r0, -1
    ac80:	109d0000 	addk	r4, r29, r0
    ac84:	bea4f9ac 	bgeid	r4, -1620		// a630
    ac88:	f861010c 	swi	r3, r1, 268
    ac8c:	079c0000 	rsub	r28, r28, r0
    ac90:	0fbd0000 	rsubc	r29, r29, r0
    ac94:	813ce800 	or	r9, r28, r29
    ac98:	30c0002d 	addik	r6, r0, 45
    ac9c:	10800000 	addk	r4, r0, r0
    aca0:	f0c1001c 	sbi	r6, r1, 28
    aca4:	8d292400 	pcmpne	r9, r9, r4
    aca8:	b810f780 	brid	-2176		// a428
    acac:	31000001 	addik	r8, r0, 1
    acb0:	10800000 	addk	r4, r0, r0
    acb4:	3068ffd0 	addik	r3, r8, -48
    acb8:	e11f0000 	lbui	r8, r31, 0
    acbc:	60a40004 	muli	r5, r4, 4
    acc0:	10852000 	addk	r4, r5, r4
    acc4:	10842000 	addk	r4, r4, r4
    acc8:	91080060 	sext8	r8, r8
    accc:	10841800 	addk	r4, r4, r3
    acd0:	30c00009 	addik	r6, r0, 9
    acd4:	3068ffd0 	addik	r3, r8, -48
    acd8:	14a33003 	cmpu	r5, r3, r6
    acdc:	bea5ffdc 	bgeid	r5, -36		// acb8
    ace0:	33ff0001 	addik	r31, r31, 1
    ace4:	b810f6e0 	brid	-2336		// a3c4
    ace8:	f88100b4 	swi	r4, r1, 180
    acec:	e86100a0 	lwi	r3, r1, 160
    acf0:	e11f0000 	lbui	r8, r31, 0
    acf4:	a0630080 	ori	r3, r3, 128
    acf8:	f86100a0 	swi	r3, r1, 160
    acfc:	b810f6c4 	brid	-2364		// a3c0
    ad00:	91080060 	sext8	r8, r8
    ad04:	e11f0000 	lbui	r8, r31, 0
    ad08:	3160002b 	addik	r11, r0, 43
    ad0c:	b810f6b4 	brid	-2380		// a3c0
    ad10:	91080060 	sext8	r8, r8
    ad14:	e11f0000 	lbui	r8, r31, 0
    ad18:	91080060 	sext8	r8, r8
    ad1c:	a868002a 	xori	r3, r8, 42
    ad20:	be030730 	beqid	r3, 1840		// b450
    ad24:	309f0001 	addik	r4, r31, 1
    ad28:	3068ffd0 	addik	r3, r8, -48
    ad2c:	30c00009 	addik	r6, r0, 9
    ad30:	14a33003 	cmpu	r5, r3, r6
    ad34:	be450038 	bltid	r5, 56		// ad6c
    ad38:	13000000 	addk	r24, r0, r0
    ad3c:	e1040000 	lbui	r8, r4, 0
    ad40:	60b80004 	muli	r5, r24, 4
    ad44:	1305c000 	addk	r24, r5, r24
    ad48:	1318c000 	addk	r24, r24, r24
    ad4c:	91080060 	sext8	r8, r8
    ad50:	1303c000 	addk	r24, r3, r24
    ad54:	30c00009 	addik	r6, r0, 9
    ad58:	3068ffd0 	addik	r3, r8, -48
    ad5c:	14a33003 	cmpu	r5, r3, r6
    ad60:	bea5ffdc 	bgeid	r5, -36		// ad3c
    ad64:	30840001 	addik	r4, r4, 1
    ad68:	bc5805c4 	blti	r24, 1476		// b32c
    ad6c:	b810f658 	brid	-2472		// a3c4
    ad70:	13e40000 	addk	r31, r4, r0
    ad74:	b810f6b4 	brid	-2380		// a428
    ad78:	f001001c 	sbi	r0, r1, 28
    ad7c:	eb21002c 	lwi	r25, r1, 44
    ad80:	b810fa14 	brid	-1516		// a794
    ad84:	e9610028 	lwi	r11, r1, 40
    ad88:	e8a10100 	lwi	r5, r1, 256
    ad8c:	e8c10104 	lwi	r6, r1, 260
    ad90:	b9f4f264 	brlid	r15, -3484	// 9ff4 <__ssprint_r>
    ad94:	30e10024 	addik	r7, r1, 36
    ad98:	be23fcb8 	bneid	r3, -840		// aa50
    ad9c:	33410058 	addik	r26, r1, 88
    ada0:	eb21002c 	lwi	r25, r1, 44
    ada4:	b810fa24 	brid	-1500		// a7c8
    ada8:	e9610028 	lwi	r11, r1, 40
    adac:	e88100a4 	lwi	r4, r1, 164
    adb0:	e8a100b4 	lwi	r5, r1, 180
    adb4:	15052001 	cmp	r8, r5, r4
    adb8:	be48fc74 	bltid	r8, -908		// aa2c
    adbc:	e8c100b0 	lwi	r6, r1, 176
    adc0:	e8c100b0 	lwi	r6, r1, 176
    adc4:	10c62000 	addk	r6, r6, r4
    adc8:	be27fc74 	bneid	r7, -908		// aa3c
    adcc:	f8c100b0 	swi	r6, r1, 176
    add0:	e09f0000 	lbui	r4, r31, 0
    add4:	f8010028 	swi	r0, r1, 40
    add8:	90840060 	sext8	r4, r4
    addc:	be24f538 	bneid	r4, -2760		// a314
    ade0:	33410058 	addik	r26, r1, 88
    ade4:	b810f5b4 	brid	-2636		// a398
    ade8:	12df0000 	addk	r22, r31, r0
    adec:	be2801fc 	bneid	r8, 508		// afe8
    adf0:	30810058 	addik	r4, r1, 88
    adf4:	e86100a0 	lwi	r3, r1, 160
    adf8:	a4830001 	andi	r4, r3, 1
    adfc:	be0402a0 	beqid	r4, 672		// b09c
    ae00:	30810058 	addik	r4, r1, 88
    ae04:	30800030 	addik	r4, r0, 48
    ae08:	ea6100c8 	lwi	r19, r1, 200
    ae0c:	f0810057 	sbi	r4, r1, 87
    ae10:	30810057 	addik	r4, r1, 87
    ae14:	f88100b8 	swi	r4, r1, 184
    ae18:	15789801 	cmp	r11, r24, r19
    ae1c:	be4bf6a0 	bltid	r11, -2400		// a4bc
    ae20:	fa6100a4 	swi	r19, r1, 164
    ae24:	e161001c 	lbui	r11, r1, 28
    ae28:	e88100a4 	lwi	r4, r1, 164
    ae2c:	914b0060 	sext8	r10, r11
    ae30:	11600000 	addk	r11, r0, r0
    ae34:	8d6a5c00 	pcmpne	r11, r10, r11
    ae38:	10845800 	addk	r4, r4, r11
    ae3c:	b810f840 	brid	-1984		// a67c
    ae40:	f88100a4 	swi	r4, r1, 164
    ae44:	e88100a4 	lwi	r4, r1, 164
    ae48:	16e42800 	rsubk	r23, r4, r5
    ae4c:	be77f9c4 	bleid	r23, -1596		// a810
    ae50:	33600010 	addik	r27, r0, 16	// 10 <_vector_interrupt>
    ae54:	1557d801 	cmp	r10, r23, r27
    ae58:	bcaa008c 	bgei	r10, 140		// aee4
    ae5c:	fb8100a8 	swi	r28, r1, 168
    ae60:	fba100ac 	swi	r29, r1, 172
    ae64:	33c00007 	addik	r30, r0, 7
    ae68:	eac10100 	lwi	r22, r1, 256
    ae6c:	b8100014 	brid	20		// ae80
    ae70:	eba10104 	lwi	r29, r1, 260
    ae74:	32f7fff0 	addik	r23, r23, -16
    ae78:	1477d801 	cmp	r3, r23, r27
    ae7c:	bca30060 	bgei	r3, 96		// aedc
    ae80:	b0000000 	imm	0
    ae84:	30a0e240 	addik	r5, r0, -7616	// e240 <zeroes.3828>
    ae88:	316b0001 	addik	r11, r11, 1
    ae8c:	33390010 	addik	r25, r25, 16
    ae90:	30c00010 	addik	r6, r0, 16	// 10 <_vector_interrupt>
    ae94:	f8ba0000 	swi	r5, r26, 0
    ae98:	f8da0004 	swi	r6, r26, 4
    ae9c:	fb21002c 	swi	r25, r1, 44
    aea0:	f9610028 	swi	r11, r1, 40
    aea4:	146bf001 	cmp	r3, r11, r30
    aea8:	bea3ffcc 	bgeid	r3, -52		// ae74
    aeac:	335a0008 	addik	r26, r26, 8
    aeb0:	10b60000 	addk	r5, r22, r0
    aeb4:	10dd0000 	addk	r6, r29, r0
    aeb8:	b9f4f13c 	brlid	r15, -3780	// 9ff4 <__ssprint_r>
    aebc:	30e10024 	addik	r7, r1, 36
    aec0:	be23fb90 	bneid	r3, -1136		// aa50
    aec4:	32f7fff0 	addik	r23, r23, -16
    aec8:	1477d801 	cmp	r3, r23, r27
    aecc:	33410058 	addik	r26, r1, 88
    aed0:	eb21002c 	lwi	r25, r1, 44
    aed4:	be43ffac 	bltid	r3, -84		// ae80
    aed8:	e9610028 	lwi	r11, r1, 40
    aedc:	eb8100a8 	lwi	r28, r1, 168
    aee0:	eba100ac 	lwi	r29, r1, 172
    aee4:	b0000000 	imm	0
    aee8:	3060e240 	addik	r3, r0, -7616	// e240 <zeroes.3828>
    aeec:	316b0001 	addik	r11, r11, 1
    aef0:	1339b800 	addk	r25, r25, r23
    aef4:	31400007 	addik	r10, r0, 7
    aef8:	f87a0000 	swi	r3, r26, 0
    aefc:	fafa0004 	swi	r23, r26, 4
    af00:	fb21002c 	swi	r25, r1, 44
    af04:	f9610028 	swi	r11, r1, 40
    af08:	154b5001 	cmp	r10, r11, r10
    af0c:	beaaf904 	bgeid	r10, -1788		// a810
    af10:	335a0008 	addik	r26, r26, 8
    af14:	e8a10100 	lwi	r5, r1, 256
    af18:	e8c10104 	lwi	r6, r1, 260
    af1c:	b9f4f0d8 	brlid	r15, -3880	// 9ff4 <__ssprint_r>
    af20:	30e10024 	addik	r7, r1, 36
    af24:	be23fb2c 	bneid	r3, -1236		// aa50
    af28:	33410058 	addik	r26, r1, 88
    af2c:	eb21002c 	lwi	r25, r1, 44
    af30:	b810f8e0 	brid	-1824		// a810
    af34:	e9610028 	lwi	r11, r1, 40
    af38:	e8a10100 	lwi	r5, r1, 256
    af3c:	e8c10104 	lwi	r6, r1, 260
    af40:	b9f4f0b4 	brlid	r15, -3916	// 9ff4 <__ssprint_r>
    af44:	30e10024 	addik	r7, r1, 36
    af48:	be23fb08 	bneid	r3, -1272		// aa50
    af4c:	30810058 	addik	r4, r1, 88
    af50:	b810f9dc 	brid	-1572		// a92c
    af54:	eb21002c 	lwi	r25, r1, 44
    af58:	be0400e0 	beqid	r4, 224		// b038
    af5c:	32610058 	addik	r19, r1, 88
    af60:	b810000c 	brid	12		// af6c
    af64:	10930000 	addk	r4, r19, r0
    af68:	10850000 	addk	r4, r5, r0
    af6c:	b0002000 	imm	8192
    af70:	60dd0000 	muli	r6, r29, 0
    af74:	a53c0007 	andi	r9, r28, 7
    af78:	10a0e000 	addk	r5, r0, r28
    af7c:	90bc0041 	srl	r5, r28
    af80:	90a50041 	srl	r5, r5
    af84:	90a50041 	srl	r5, r5
    af88:	31290030 	addik	r9, r9, 48
    af8c:	83862800 	or	r28, r6, r5
    af90:	1060e800 	addk	r3, r0, r29
    af94:	907d0041 	srl	r3, r29
    af98:	90630041 	srl	r3, r3
    af9c:	90630041 	srl	r3, r3
    afa0:	f124ffff 	sbi	r9, r4, -1
    afa4:	13a30000 	addk	r29, r3, r0
    afa8:	807c1800 	or	r3, r28, r3
    afac:	be23ffbc 	bneid	r3, -68		// af68
    afb0:	30a4ffff 	addik	r5, r4, -1
    afb4:	e8c100a0 	lwi	r6, r1, 160
    afb8:	a4660001 	andi	r3, r6, 1
    afbc:	be030190 	beqid	r3, 400		// b14c
    afc0:	f8a100b8 	swi	r5, r1, 184
    afc4:	a9290030 	xori	r9, r9, 48
    afc8:	be0903b4 	beqid	r9, 948		// b37c
    afcc:	30600030 	addik	r3, r0, 48
    afd0:	30c4fffe 	addik	r6, r4, -2
    afd4:	f064fffe 	sbi	r3, r4, -2
    afd8:	e8810098 	lwi	r4, r1, 152
    afdc:	f8c100b8 	swi	r6, r1, 184
    afe0:	b810fe38 	brid	-456		// ae18
    afe4:	16662000 	rsubk	r19, r6, r4
    afe8:	12690000 	addk	r19, r9, r0
    afec:	b810fe2c 	brid	-468		// ae18
    aff0:	f88100b8 	swi	r4, r1, 184
    aff4:	e8a10100 	lwi	r5, r1, 256
    aff8:	e8c10104 	lwi	r6, r1, 260
    affc:	b9f4eff8 	brlid	r15, -4104	// 9ff4 <__ssprint_r>
    b000:	30e10024 	addik	r7, r1, 36
    b004:	be23fa4c 	bneid	r3, -1460		// aa50
    b008:	33410058 	addik	r26, r1, 88
    b00c:	b810f37c 	brid	-3204		// a388
    b010:	e0f30001 	lbui	r7, r19, 1
    b014:	e8a10100 	lwi	r5, r1, 256
    b018:	e8c10104 	lwi	r6, r1, 260
    b01c:	b9f4efd8 	brlid	r15, -4136	// 9ff4 <__ssprint_r>
    b020:	30e10024 	addik	r7, r1, 36
    b024:	be23fa2c 	bneid	r3, -1492		// aa50
    b028:	33410058 	addik	r26, r1, 88
    b02c:	eb21002c 	lwi	r25, r1, 44
    b030:	b810f7d0 	brid	-2096		// a800
    b034:	e9610028 	lwi	r11, r1, 40
    b038:	e8e100bc 	lwi	r7, r1, 188
    b03c:	a4bc000f 	andi	r5, r28, 15
    b040:	c0a53800 	lbu	r5, r5, r7
    b044:	b0001000 	imm	4096
    b048:	60dd0000 	muli	r6, r29, 0
    b04c:	1080e000 	addk	r4, r0, r28
    b050:	909c0041 	srl	r4, r28
    b054:	90840041 	srl	r4, r4
    b058:	90840041 	srl	r4, r4
    b05c:	90840041 	srl	r4, r4
    b060:	83862000 	or	r28, r6, r4
    b064:	1060e800 	addk	r3, r0, r29
    b068:	907d0041 	srl	r3, r29
    b06c:	90630041 	srl	r3, r3
    b070:	90630041 	srl	r3, r3
    b074:	90630041 	srl	r3, r3
    b078:	f0b3ffff 	sbi	r5, r19, -1
    b07c:	13a30000 	addk	r29, r3, r0
    b080:	807c1800 	or	r3, r28, r3
    b084:	be23ffb8 	bneid	r3, -72		// b03c
    b088:	3273ffff 	addik	r19, r19, -1
    b08c:	e8c10098 	lwi	r6, r1, 152
    b090:	fa6100b8 	swi	r19, r1, 184
    b094:	b810fd84 	brid	-636		// ae18
    b098:	16733000 	rsubk	r19, r19, r6
    b09c:	12680000 	addk	r19, r8, r0
    b0a0:	b810fd78 	brid	-648		// ae18
    b0a4:	f88100b8 	swi	r4, r1, 184
    b0a8:	be230138 	bneid	r3, 312		// b1e0
    b0ac:	31000001 	addik	r8, r0, 1
    b0b0:	a5260040 	andi	r9, r6, 64
    b0b4:	be09021c 	beqid	r9, 540		// b2d0
    b0b8:	e8a1010c 	lwi	r5, r1, 268
    b0bc:	31000001 	addik	r8, r0, 1
    b0c0:	13a30000 	addk	r29, r3, r0
    b0c4:	e7850000 	lhui	r28, r5, 0
    b0c8:	30a50004 	addik	r5, r5, 4
    b0cc:	f8a1010c 	swi	r5, r1, 268
    b0d0:	8d23e400 	pcmpne	r9, r3, r28
    b0d4:	b810f354 	brid	-3244		// a428
    b0d8:	f001001c 	sbi	r0, r1, 28
    b0dc:	be230138 	bneid	r3, 312		// b214
    b0e0:	11040000 	addk	r8, r4, r0
    b0e4:	a5260040 	andi	r9, r6, 64
    b0e8:	be0901c4 	beqid	r9, 452		// b2ac
    b0ec:	e8a1010c 	lwi	r5, r1, 268
    b0f0:	11030000 	addk	r8, r3, r0
    b0f4:	13a30000 	addk	r29, r3, r0
    b0f8:	e7850000 	lhui	r28, r5, 0
    b0fc:	30a50004 	addik	r5, r5, 4
    b100:	f8a1010c 	swi	r5, r1, 268
    b104:	8d23e400 	pcmpne	r9, r3, r28
    b108:	b810f320 	brid	-3296		// a428
    b10c:	f001001c 	sbi	r0, r1, 28
    b110:	e8a10100 	lwi	r5, r1, 256
    b114:	e8c10104 	lwi	r6, r1, 260
    b118:	b9f4eedc 	brlid	r15, -4388	// 9ff4 <__ssprint_r>
    b11c:	30e10024 	addik	r7, r1, 36
    b120:	be23f930 	bneid	r3, -1744		// aa50
    b124:	e141001c 	lbui	r10, r1, 28
    b128:	33410058 	addik	r26, r1, 88
    b12c:	eb21002c 	lwi	r25, r1, 44
    b130:	e9610028 	lwi	r11, r1, 40
    b134:	b810f660 	brid	-2464		// a794
    b138:	914a0060 	sext8	r10, r10
    b13c:	e11f0000 	lbui	r8, r31, 0
    b140:	f861010c 	swi	r3, r1, 268
    b144:	b810f27c 	brid	-3460		// a3c0
    b148:	91080060 	sext8	r8, r8
    b14c:	e8610098 	lwi	r3, r1, 152
    b150:	b810fcc8 	brid	-824		// ae18
    b154:	16651800 	rsubk	r19, r5, r3
    b158:	147c2803 	cmpu	r3, r28, r5
    b15c:	be43f2f8 	bltid	r3, -3336		// a454
    b160:	309c0030 	addik	r4, r28, 48
    b164:	f0810057 	sbi	r4, r1, 87
    b168:	30810057 	addik	r4, r1, 87
    b16c:	ea6100c8 	lwi	r19, r1, 200
    b170:	b810fca8 	brid	-856		// ae18
    b174:	f88100b8 	swi	r4, r1, 184
    b178:	b810f248 	brid	-3512		// a3c0
    b17c:	91080060 	sext8	r8, r8
    b180:	e8a1010c 	lwi	r5, r1, 268
    b184:	e8c1010c 	lwi	r6, r1, 268
    b188:	e8e50000 	lwi	r7, r5, 0
    b18c:	30c60004 	addik	r6, r6, 4
    b190:	e88100b0 	lwi	r4, r1, 176
    b194:	00a42000 	add	r5, r4, r4
    b198:	08a00000 	addc	r5, r0, r0
    b19c:	bc050008 	beqi	r5, 8		// b1a4
    b1a0:	20a0ffff 	addi	r5, r0, -1
    b1a4:	f8c1010c 	swi	r6, r1, 268
    b1a8:	f8870000 	swi	r4, r7, 0
    b1ac:	f8a70004 	swi	r5, r7, 4
    b1b0:	b810f158 	brid	-3752		// a308
    b1b4:	e09f0000 	lbui	r4, r31, 0
    b1b8:	e8a1010c 	lwi	r5, r1, 268
    b1bc:	eb850000 	lwi	r28, r5, 0
    b1c0:	03bce000 	add	r29, r28, r28
    b1c4:	0ba00000 	addc	r29, r0, r0
    b1c8:	bc1d0008 	beqi	r29, 8		// b1d0
    b1cc:	23a0ffff 	addi	r29, r0, -1
    b1d0:	30a50004 	addik	r5, r5, 4
    b1d4:	f8a1010c 	swi	r5, r1, 268
    b1d8:	b810f454 	brid	-2988		// a62c
    b1dc:	109d0000 	addk	r4, r29, r0
    b1e0:	e8c1010c 	lwi	r6, r1, 268
    b1e4:	13a40000 	addk	r29, r4, r0
    b1e8:	eb860000 	lwi	r28, r6, 0
    b1ec:	30c60004 	addik	r6, r6, 4
    b1f0:	f8c1010c 	swi	r6, r1, 268
    b1f4:	8d24e400 	pcmpne	r9, r4, r28
    b1f8:	b810f230 	brid	-3536		// a428
    b1fc:	f001001c 	sbi	r0, r1, 28
    b200:	13a40000 	addk	r29, r4, r0
    b204:	eb860000 	lwi	r28, r6, 0
    b208:	30c60004 	addik	r6, r6, 4
    b20c:	b810f8d0 	brid	-1840		// aadc
    b210:	f8c1010c 	swi	r6, r1, 268
    b214:	e8c1010c 	lwi	r6, r1, 268
    b218:	13a40000 	addk	r29, r4, r0
    b21c:	eb860000 	lwi	r28, r6, 0
    b220:	30c60004 	addik	r6, r6, 4
    b224:	f8c1010c 	swi	r6, r1, 268
    b228:	8d24e400 	pcmpne	r9, r4, r28
    b22c:	b810f1fc 	brid	-3588		// a428
    b230:	f001001c 	sbi	r0, r1, 28
    b234:	e88100a0 	lwi	r4, r1, 160
    b238:	e11f0001 	lbui	r8, r31, 1
    b23c:	33ff0001 	addik	r31, r31, 1
    b240:	a0840020 	ori	r4, r4, 32
    b244:	f88100a0 	swi	r4, r1, 160
    b248:	b810f178 	brid	-3720		// a3c0
    b24c:	91080060 	sext8	r8, r8
    b250:	b000ffff 	imm	-1
    b254:	b9f4d634 	brlid	r15, -10700	// 8888 <strlen>
    b258:	13000000 	addk	r24, r0, r0
    b25c:	b810fbbc 	brid	-1092		// ae18
    b260:	12630000 	addk	r19, r3, r0
    b264:	e861002c 	lwi	r3, r1, 44
    b268:	be03f7e8 	beqid	r3, -2072		// aa50
    b26c:	e8a10100 	lwi	r5, r1, 256
    b270:	e8c10104 	lwi	r6, r1, 260
    b274:	b9f4ed80 	brlid	r15, -4736	// 9ff4 <__ssprint_r>
    b278:	30e10024 	addik	r7, r1, 36
    b27c:	b810f7d8 	brid	-2088		// aa54
    b280:	e8610104 	lwi	r3, r1, 260
    b284:	e8a1010c 	lwi	r5, r1, 268
    b288:	30a50004 	addik	r5, r5, 4
    b28c:	eb840000 	lwi	r28, r4, 0
    b290:	03bce000 	add	r29, r28, r28
    b294:	0ba00000 	addc	r29, r0, r0
    b298:	bc1d0008 	beqi	r29, 8		// b2a0
    b29c:	23a0ffff 	addi	r29, r0, -1
    b2a0:	f8a1010c 	swi	r5, r1, 268
    b2a4:	b810f388 	brid	-3192		// a62c
    b2a8:	109d0000 	addk	r4, r29, r0
    b2ac:	e8c1010c 	lwi	r6, r1, 268
    b2b0:	11090000 	addk	r8, r9, r0
    b2b4:	13a90000 	addk	r29, r9, r0
    b2b8:	eb860000 	lwi	r28, r6, 0
    b2bc:	30c60004 	addik	r6, r6, 4
    b2c0:	f8c1010c 	swi	r6, r1, 268
    b2c4:	8d29e400 	pcmpne	r9, r9, r28
    b2c8:	b810f160 	brid	-3744		// a428
    b2cc:	f001001c 	sbi	r0, r1, 28
    b2d0:	e8c1010c 	lwi	r6, r1, 268
    b2d4:	13a90000 	addk	r29, r9, r0
    b2d8:	eb860000 	lwi	r28, r6, 0
    b2dc:	30c60004 	addik	r6, r6, 4
    b2e0:	f8c1010c 	swi	r6, r1, 268
    b2e4:	8d29e400 	pcmpne	r9, r9, r28
    b2e8:	b810f140 	brid	-3776		// a428
    b2ec:	f001001c 	sbi	r0, r1, 28
    b2f0:	be030074 	beqid	r3, 116		// b364
    b2f4:	e8c1010c 	lwi	r6, r1, 268
    b2f8:	e881010c 	lwi	r4, r1, 268
    b2fc:	e8a100b0 	lwi	r5, r1, 176
    b300:	e8640000 	lwi	r3, r4, 0
    b304:	30840004 	addik	r4, r4, 4
    b308:	f881010c 	swi	r4, r1, 268
    b30c:	b810eff8 	brid	-4104		// a304
    b310:	f4a30000 	shi	r5, r3, 0
    b314:	e8a1010c 	lwi	r5, r1, 268
    b318:	13a40000 	addk	r29, r4, r0
    b31c:	eb850000 	lwi	r28, r5, 0
    b320:	30a50004 	addik	r5, r5, 4
    b324:	b810f7b8 	brid	-2120		// aadc
    b328:	f8a1010c 	swi	r5, r1, 268
    b32c:	3300ffff 	addik	r24, r0, -1
    b330:	b810f094 	brid	-3948		// a3c4
    b334:	13e40000 	addk	r31, r4, r0
    b338:	b000ffff 	imm	-1
    b33c:	b9f49c54 	brlid	r15, -25516	// 4f90 <_malloc_r>
    b340:	f8e100cc 	swi	r7, r1, 204
    b344:	e8810104 	lwi	r4, r1, 260
    b348:	e8e100cc 	lwi	r7, r1, 204
    b34c:	f8640000 	swi	r3, r4, 0
    b350:	be030128 	beqid	r3, 296		// b478
    b354:	f8640010 	swi	r3, r4, 16
    b358:	30a00040 	addik	r5, r0, 64
    b35c:	b810ef70 	brid	-4240		// a2cc
    b360:	f8a40014 	swi	r5, r4, 20
    b364:	e88100b0 	lwi	r4, r1, 176
    b368:	e8660000 	lwi	r3, r6, 0
    b36c:	30c60004 	addik	r6, r6, 4
    b370:	f8c1010c 	swi	r6, r1, 268
    b374:	b810ef90 	brid	-4208		// a304
    b378:	f8830000 	swi	r4, r3, 0
    b37c:	e8810098 	lwi	r4, r1, 152
    b380:	e8a100b8 	lwi	r5, r1, 184
    b384:	b810fa94 	brid	-1388		// ae18
    b388:	16652000 	rsubk	r19, r5, r4
    b38c:	30800006 	addik	r4, r0, 6
    b390:	14782003 	cmpu	r3, r24, r4
    b394:	be4300b0 	bltid	r3, 176		// b444
    b398:	12780000 	addk	r19, r24, r0
    b39c:	a898ffff 	xori	r4, r24, -1
    b3a0:	10602000 	addk	r3, r0, r4
    b3a4:	90640001 	sra	r3, r4
    b3a8:	90630001 	sra	r3, r3
    b3ac:	90630001 	sra	r3, r3
    b3b0:	90630001 	sra	r3, r3
    b3b4:	90630001 	sra	r3, r3
    b3b8:	90630001 	sra	r3, r3
    b3bc:	90630001 	sra	r3, r3
    b3c0:	90630001 	sra	r3, r3
    b3c4:	90630001 	sra	r3, r3
    b3c8:	90630001 	sra	r3, r3
    b3cc:	90630001 	sra	r3, r3
    b3d0:	90630001 	sra	r3, r3
    b3d4:	90630001 	sra	r3, r3
    b3d8:	90630001 	sra	r3, r3
    b3dc:	90630001 	sra	r3, r3
    b3e0:	90630001 	sra	r3, r3
    b3e4:	90630001 	sra	r3, r3
    b3e8:	90630001 	sra	r3, r3
    b3ec:	90630001 	sra	r3, r3
    b3f0:	90630001 	sra	r3, r3
    b3f4:	90630001 	sra	r3, r3
    b3f8:	90630001 	sra	r3, r3
    b3fc:	90630001 	sra	r3, r3
    b400:	90630001 	sra	r3, r3
    b404:	90630001 	sra	r3, r3
    b408:	90630001 	sra	r3, r3
    b40c:	90630001 	sra	r3, r3
    b410:	90630001 	sra	r3, r3
    b414:	90630001 	sra	r3, r3
    b418:	90630001 	sra	r3, r3
    b41c:	90630001 	sra	r3, r3
    b420:	84781800 	and	r3, r24, r3
    b424:	f86100a4 	swi	r3, r1, 164
    b428:	b0000000 	imm	0
    b42c:	3080e0c4 	addik	r4, r0, -7996
    b430:	b810f244 	brid	-3516		// a674
    b434:	f88100b8 	swi	r4, r1, 184
    b438:	12780000 	addk	r19, r24, r0
    b43c:	b810f9dc 	brid	-1572		// ae18
    b440:	13030000 	addk	r24, r3, r0
    b444:	12640000 	addk	r19, r4, r0
    b448:	b810ffe0 	brid	-32		// b428
    b44c:	f88100a4 	swi	r4, r1, 164
    b450:	e861010c 	lwi	r3, r1, 268
    b454:	e11f0001 	lbui	r8, r31, 1
    b458:	13e40000 	addk	r31, r4, r0
    b45c:	eb030000 	lwi	r24, r3, 0
    b460:	30630004 	addik	r3, r3, 4
    b464:	f861010c 	swi	r3, r1, 268
    b468:	beb8ef58 	bgeid	r24, -4264		// a3c0
    b46c:	91080060 	sext8	r8, r8
    b470:	b810ef50 	brid	-4272		// a3c0
    b474:	3300ffff 	addik	r24, r0, -1
    b478:	e8a10100 	lwi	r5, r1, 256
    b47c:	30c0000c 	addik	r6, r0, 12
    b480:	3060ffff 	addik	r3, r0, -1
    b484:	f8c50000 	swi	r6, r5, 0
    b488:	b810f5e4 	brid	-2588		// aa6c
    b48c:	f86100b0 	swi	r3, r1, 176

0000b490 <memchr>:
    b490:	a4650003 	andi	r3, r5, 3
    b494:	be0300f0 	beqid	r3, 240		// b584
    b498:	a4c600ff 	andi	r6, r6, 255
    b49c:	be070098 	beqid	r7, 152		// b534
    b4a0:	10670000 	addk	r3, r7, r0
    b4a4:	e0850000 	lbui	r4, r5, 0
    b4a8:	10650000 	addk	r3, r5, r0
    b4ac:	88843000 	xor	r4, r4, r6
    b4b0:	be240028 	bneid	r4, 40		// b4d8
    b4b4:	30e7ffff 	addik	r7, r7, -1
    b4b8:	b800007c 	bri	124		// b534
    b4bc:	be070070 	beqid	r7, 112		// b52c
    b4c0:	3087ffff 	addik	r4, r7, -1
    b4c4:	e1050001 	lbui	r8, r5, 1
    b4c8:	10e40000 	addk	r7, r4, r0
    b4cc:	88883000 	xor	r4, r8, r6
    b4d0:	be040064 	beqid	r4, 100		// b534
    b4d4:	10a30000 	addk	r5, r3, r0
    b4d8:	30650001 	addik	r3, r5, 1
    b4dc:	a4830003 	andi	r4, r3, 3
    b4e0:	bc24ffdc 	bnei	r4, -36		// b4bc
    b4e4:	31200003 	addik	r9, r0, 3
    b4e8:	14874803 	cmpu	r4, r7, r9
    b4ec:	be440050 	bltid	r4, 80		// b53c
    b4f0:	60860100 	muli	r4, r6, 256
    b4f4:	bc070038 	beqi	r7, 56		// b52c
    b4f8:	e0830000 	lbui	r4, r3, 0
    b4fc:	88843000 	xor	r4, r4, r6
    b500:	be240024 	bneid	r4, 36		// b524
    b504:	30e7ffff 	addik	r7, r7, -1
    b508:	b800002c 	bri	44		// b534
    b50c:	e0a30001 	lbui	r5, r3, 1
    b510:	10e40000 	addk	r7, r4, r0
    b514:	30830001 	addik	r4, r3, 1
    b518:	88a53000 	xor	r5, r5, r6
    b51c:	be050018 	beqid	r5, 24		// b534
    b520:	10640000 	addk	r3, r4, r0
    b524:	be27ffe8 	bneid	r7, -24		// b50c
    b528:	3087ffff 	addik	r4, r7, -1
    b52c:	b60f0008 	rtsd	r15, 8
    b530:	10670000 	addk	r3, r7, r0
    b534:	b60f0008 	rtsd	r15, 8
    b538:	80000000 	or	r0, r0, r0
    b53c:	80843000 	or	r4, r4, r6
    b540:	b0000001 	imm	1
    b544:	61040000 	muli	r8, r4, 0
    b548:	81082000 	or	r8, r8, r4
    b54c:	e8830000 	lwi	r4, r3, 0
    b550:	88882000 	xor	r4, r8, r4
    b554:	b000fefe 	imm	-258
    b558:	30a4feff 	addik	r5, r4, -257
    b55c:	a884ffff 	xori	r4, r4, -1
    b560:	84852000 	and	r4, r5, r4
    b564:	b0008080 	imm	-32640
    b568:	a4848080 	andi	r4, r4, -32640
    b56c:	bc24ff88 	bnei	r4, -120		// b4f4
    b570:	30e7fffc 	addik	r7, r7, -4
    b574:	14874803 	cmpu	r4, r7, r9
    b578:	be44ffd4 	bltid	r4, -44		// b54c
    b57c:	30630004 	addik	r3, r3, 4
    b580:	b800ff74 	bri	-140		// b4f4
    b584:	b810ff60 	brid	-160		// b4e4
    b588:	10650000 	addk	r3, r5, r0

0000b58c <fstat>:
    b58c:	10600000 	addk	r3, r0, r0
    b590:	30802000 	addik	r4, r0, 8192
    b594:	f8860004 	swi	r4, r6, 4
    b598:	b60f0008 	rtsd	r15, 8
    b59c:	f866002c 	swi	r3, r6, 44

0000b5a0 <open>:
    b5a0:	3021ffe4 	addik	r1, r1, -28
    b5a4:	f9e10000 	swi	r15, r1, 0
    b5a8:	b0000000 	imm	0
    b5ac:	b9f4008c 	brlid	r15, 140	// b638 <__errno>
    b5b0:	80000000 	or	r0, r0, r0
    b5b4:	30800005 	addik	r4, r0, 5
    b5b8:	f8830000 	swi	r4, r3, 0
    b5bc:	e9e10000 	lwi	r15, r1, 0
    b5c0:	3060ffff 	addik	r3, r0, -1
    b5c4:	b60f0008 	rtsd	r15, 8
    b5c8:	3021001c 	addik	r1, r1, 28

0000b5cc <sbrk>:
    b5cc:	b0000000 	imm	0
    b5d0:	e860ec3c 	lwi	r3, r0, -5060	// ec3c <heap_ptr>
    b5d4:	3021ffe4 	addik	r1, r1, -28
    b5d8:	be03004c 	beqid	r3, 76		// b624
    b5dc:	f9e10000 	swi	r15, r1, 0
    b5e0:	b0000000 	imm	0
    b5e4:	3080f0c1 	addik	r4, r0, -3903
    b5e8:	10a32800 	addk	r5, r3, r5
    b5ec:	b0000000 	imm	0
    b5f0:	f8a0ec3c 	swi	r5, r0, -5060	// ec3c <heap_ptr>
    b5f4:	14a52003 	cmpu	r5, r5, r4
    b5f8:	bea50024 	bgeid	r5, 36		// b61c
    b5fc:	e9e10000 	lwi	r15, r1, 0
    b600:	b0000000 	imm	0
    b604:	b9f40034 	brlid	r15, 52	// b638 <__errno>
    b608:	80000000 	or	r0, r0, r0
    b60c:	3080000c 	addik	r4, r0, 12
    b610:	f8830000 	swi	r4, r3, 0
    b614:	3060ffff 	addik	r3, r0, -1
    b618:	e9e10000 	lwi	r15, r1, 0
    b61c:	b60f0008 	rtsd	r15, 8
    b620:	3021001c 	addik	r1, r1, 28
    b624:	b0000000 	imm	0
    b628:	3060ecc0 	addik	r3, r0, -4928	// ecc0 <__bss_end>
    b62c:	b800ffb4 	bri	-76		// b5e0

0000b630 <close>:
    b630:	b60f0008 	rtsd	r15, 8
    b634:	10600000 	addk	r3, r0, r0

0000b638 <__errno>:

int *
__errno ()
{
  return &_REENT->_errno;
}
    b638:	b0000000 	imm	0
    b63c:	e860e3e8 	lwi	r3, r0, -7192	// e3e8 <_impure_ptr>
    b640:	b60f0008 	rtsd	r15, 8
    b644:	80000000 	or	r0, r0, r0

0000b648 <__udivdi3>:
    b648:	3021ffb4 	addik	r1, r1, -76
    b64c:	fa610024 	swi	r19, r1, 36
    b650:	fac10028 	swi	r22, r1, 40
    b654:	fae1002c 	swi	r23, r1, 44
    b658:	fb010030 	swi	r24, r1, 48
    b65c:	fb210034 	swi	r25, r1, 52
    b660:	f9e10000 	swi	r15, r1, 0
    b664:	fb410038 	swi	r26, r1, 56
    b668:	fb61003c 	swi	r27, r1, 60
    b66c:	fb810040 	swi	r28, r1, 64
    b670:	fba10044 	swi	r29, r1, 68
    b674:	fbc10048 	swi	r30, r1, 72
    b678:	12e50000 	addk	r23, r5, r0
    b67c:	12c60000 	addk	r22, r6, r0
    b680:	13250000 	addk	r25, r5, r0
    b684:	12670000 	addk	r19, r7, r0
    b688:	be280254 	bneid	r8, 596		// b8dc
    b68c:	13060000 	addk	r24, r6, r0
    b690:	14673003 	cmpu	r3, r7, r6
    b694:	bca302cc 	bgei	r3, 716		// b960
    b698:	b0000000 	imm	0
    b69c:	3060ffff 	addik	r3, r0, -1
    b6a0:	14671803 	cmpu	r3, r7, r3
    b6a4:	bea30504 	bgeid	r3, 1284		// bba8
    b6a8:	306000ff 	addik	r3, r0, 255
    b6ac:	b00000ff 	imm	255
    b6b0:	3060ffff 	addik	r3, r0, -1
    b6b4:	14671803 	cmpu	r3, r7, r3
    b6b8:	be430acc 	bltid	r3, 2764		// c184
    b6bc:	31000018 	addik	r8, r0, 24
    b6c0:	31000010 	addik	r8, r0, 16	// 10 <_vector_interrupt>
    b6c4:	10680000 	addk	r3, r8, r0
    b6c8:	a648001f 	andi	r18, r8, 31
    b6cc:	10803800 	addk	r4, r0, r7
    b6d0:	be120014 	beqid	r18, 20		// b6e4
    b6d4:	10840000 	addk	r4, r4, r0
    b6d8:	3252ffff 	addik	r18, r18, -1
    b6dc:	be32fffc 	bneid	r18, -4		// b6d8
    b6e0:	90840041 	srl	r4, r4
    b6e4:	b0000000 	imm	0
    b6e8:	e084e250 	lbui	r4, r4, -7600
    b6ec:	30a00020 	addik	r5, r0, 32	// 20 <_vector_hw_exception>
    b6f0:	10841800 	addk	r4, r4, r3
    b6f4:	14642800 	rsubk	r3, r4, r5
    b6f8:	bc030078 	beqi	r3, 120		// b770
    b6fc:	a643001f 	andi	r18, r3, 31
    b700:	1300b000 	addk	r24, r0, r22
    b704:	be120014 	beqid	r18, 20		// b718
    b708:	13180000 	addk	r24, r24, r0
    b70c:	3252ffff 	addik	r18, r18, -1
    b710:	be32fffc 	bneid	r18, -4		// b70c
    b714:	1318c000 	addk	r24, r24, r24
    b718:	a644001f 	andi	r18, r4, 31
    b71c:	10a0b800 	addk	r5, r0, r23
    b720:	be120014 	beqid	r18, 20		// b734
    b724:	10a50000 	addk	r5, r5, r0
    b728:	3252ffff 	addik	r18, r18, -1
    b72c:	be32fffc 	bneid	r18, -4		// b728
    b730:	90a50041 	srl	r5, r5
    b734:	83182800 	or	r24, r24, r5
    b738:	a643001f 	andi	r18, r3, 31
    b73c:	12603800 	addk	r19, r0, r7
    b740:	be120014 	beqid	r18, 20		// b754
    b744:	12730000 	addk	r19, r19, r0
    b748:	3252ffff 	addik	r18, r18, -1
    b74c:	be32fffc 	bneid	r18, -4		// b748
    b750:	12739800 	addk	r19, r19, r19
    b754:	a643001f 	andi	r18, r3, 31
    b758:	1320b800 	addk	r25, r0, r23
    b75c:	be120014 	beqid	r18, 20		// b770
    b760:	13390000 	addk	r25, r25, r0
    b764:	3252ffff 	addik	r18, r18, -1
    b768:	be32fffc 	bneid	r18, -4		// b764
    b76c:	1339c800 	addk	r25, r25, r25
    b770:	12e09800 	addk	r23, r0, r19
    b774:	92f30041 	srl	r23, r19
    b778:	92f70041 	srl	r23, r23
    b77c:	92f70041 	srl	r23, r23
    b780:	92f70041 	srl	r23, r23
    b784:	92f70041 	srl	r23, r23
    b788:	92f70041 	srl	r23, r23
    b78c:	92f70041 	srl	r23, r23
    b790:	92f70041 	srl	r23, r23
    b794:	92f70041 	srl	r23, r23
    b798:	92f70041 	srl	r23, r23
    b79c:	92f70041 	srl	r23, r23
    b7a0:	92f70041 	srl	r23, r23
    b7a4:	92f70041 	srl	r23, r23
    b7a8:	92f70041 	srl	r23, r23
    b7ac:	92f70041 	srl	r23, r23
    b7b0:	92f70041 	srl	r23, r23
    b7b4:	10b80000 	addk	r5, r24, r0
    b7b8:	b0000000 	imm	0
    b7bc:	a753ffff 	andi	r26, r19, -1
    b7c0:	b0000000 	imm	0
    b7c4:	b9f419b8 	brlid	r15, 6584	// d17c <__umodsi3>
    b7c8:	10d70000 	addk	r6, r23, r0
    b7cc:	10b80000 	addk	r5, r24, r0
    b7d0:	10d70000 	addk	r6, r23, r0
    b7d4:	b0000000 	imm	0
    b7d8:	b9f418fc 	brlid	r15, 6396	// d0d4 <__udivsi3>
    b7dc:	13630000 	addk	r27, r3, r0
    b7e0:	40a3d000 	mul	r5, r3, r26
    b7e4:	b0000001 	imm	1
    b7e8:	609b0000 	muli	r4, r27, 0
    b7ec:	10c0c800 	addk	r6, r0, r25
    b7f0:	90d90041 	srl	r6, r25
    b7f4:	90c60041 	srl	r6, r6
    b7f8:	90c60041 	srl	r6, r6
    b7fc:	90c60041 	srl	r6, r6
    b800:	90c60041 	srl	r6, r6
    b804:	90c60041 	srl	r6, r6
    b808:	90c60041 	srl	r6, r6
    b80c:	90c60041 	srl	r6, r6
    b810:	90c60041 	srl	r6, r6
    b814:	90c60041 	srl	r6, r6
    b818:	90c60041 	srl	r6, r6
    b81c:	90c60041 	srl	r6, r6
    b820:	90c60041 	srl	r6, r6
    b824:	90c60041 	srl	r6, r6
    b828:	90c60041 	srl	r6, r6
    b82c:	90c60041 	srl	r6, r6
    b830:	80843000 	or	r4, r4, r6
    b834:	12c30000 	addk	r22, r3, r0
    b838:	14652003 	cmpu	r3, r5, r4
    b83c:	bca30024 	bgei	r3, 36		// b860
    b840:	10849800 	addk	r4, r4, r19
    b844:	14732003 	cmpu	r3, r19, r4
    b848:	be430014 	bltid	r3, 20		// b85c
    b84c:	30d6ffff 	addik	r6, r22, -1
    b850:	14652003 	cmpu	r3, r5, r4
    b854:	be4309b4 	bltid	r3, 2484		// c208
    b858:	32d6fffe 	addik	r22, r22, -2
    b85c:	12c60000 	addk	r22, r6, r0
    b860:	17052000 	rsubk	r24, r5, r4
    b864:	10b80000 	addk	r5, r24, r0
    b868:	b0000000 	imm	0
    b86c:	a739ffff 	andi	r25, r25, -1
    b870:	b0000000 	imm	0
    b874:	b9f41908 	brlid	r15, 6408	// d17c <__umodsi3>
    b878:	10d70000 	addk	r6, r23, r0
    b87c:	10b80000 	addk	r5, r24, r0
    b880:	10d70000 	addk	r6, r23, r0
    b884:	b0000000 	imm	0
    b888:	b9f4184c 	brlid	r15, 6220	// d0d4 <__udivsi3>
    b88c:	13630000 	addk	r27, r3, r0
    b890:	10830000 	addk	r4, r3, r0
    b894:	b0000001 	imm	1
    b898:	607b0000 	muli	r3, r27, 0
    b89c:	8323c800 	or	r25, r3, r25
    b8a0:	4344d000 	mul	r26, r4, r26
    b8a4:	147ac803 	cmpu	r3, r26, r25
    b8a8:	bea30020 	bgeid	r3, 32		// b8c8
    b8ac:	13399800 	addk	r25, r25, r19
    b8b0:	1673c803 	cmpu	r19, r19, r25
    b8b4:	be5308ec 	bltid	r19, 2284		// c1a0
    b8b8:	3064ffff 	addik	r3, r4, -1
    b8bc:	175ac803 	cmpu	r26, r26, r25
    b8c0:	beba08e0 	bgeid	r26, 2272		// c1a0
    b8c4:	3084fffe 	addik	r4, r4, -2
    b8c8:	b0000001 	imm	1
    b8cc:	60760000 	muli	r3, r22, 0
    b8d0:	80641800 	or	r3, r4, r3
    b8d4:	b810028c 	brid	652		// bb60
    b8d8:	10800000 	addk	r4, r0, r0
    b8dc:	14683003 	cmpu	r3, r8, r6
    b8e0:	be43027c 	bltid	r3, 636		// bb5c
    b8e4:	10800000 	addk	r4, r0, r0
    b8e8:	b0000000 	imm	0
    b8ec:	3060ffff 	addik	r3, r0, -1
    b8f0:	14681803 	cmpu	r3, r8, r3
    b8f4:	bea302a0 	bgeid	r3, 672		// bb94
    b8f8:	306000ff 	addik	r3, r0, 255
    b8fc:	b00000ff 	imm	255
    b900:	3060ffff 	addik	r3, r0, -1
    b904:	14681803 	cmpu	r3, r8, r3
    b908:	be4308a0 	bltid	r3, 2208		// c1a8
    b90c:	30600018 	addik	r3, r0, 24
    b910:	30600010 	addik	r3, r0, 16	// 10 <_vector_interrupt>
    b914:	10830000 	addk	r4, r3, r0
    b918:	a643001f 	andi	r18, r3, 31
    b91c:	10a04000 	addk	r5, r0, r8
    b920:	be120014 	beqid	r18, 20		// b934
    b924:	10a50000 	addk	r5, r5, r0
    b928:	3252ffff 	addik	r18, r18, -1
    b92c:	be32fffc 	bneid	r18, -4		// b928
    b930:	90a50041 	srl	r5, r5
    b934:	b0000000 	imm	0
    b938:	e065e250 	lbui	r3, r5, -7600
    b93c:	10632000 	addk	r3, r3, r4
    b940:	30800020 	addik	r4, r0, 32	// 20 <_vector_hw_exception>
    b944:	16632000 	rsubk	r19, r3, r4
    b948:	bc330288 	bnei	r19, 648		// bbd0
    b94c:	14e7b803 	cmpu	r7, r7, r23
    b950:	bc4708c8 	blti	r7, 2248		// c218
    b954:	10800000 	addk	r4, r0, r0
    b958:	b8100208 	brid	520		// bb60
    b95c:	30600001 	addik	r3, r0, 1
    b960:	be270018 	bneid	r7, 24		// b978
    b964:	10c70000 	addk	r6, r7, r0
    b968:	b0000000 	imm	0
    b96c:	b9f41768 	brlid	r15, 5992	// d0d4 <__udivsi3>
    b970:	30a00001 	addik	r5, r0, 1
    b974:	12630000 	addk	r19, r3, r0
    b978:	b0000000 	imm	0
    b97c:	3060ffff 	addik	r3, r0, -1
    b980:	14731803 	cmpu	r3, r19, r3
    b984:	bea30238 	bgeid	r3, 568		// bbbc
    b988:	306000ff 	addik	r3, r0, 255
    b98c:	b00000ff 	imm	255
    b990:	3060ffff 	addik	r3, r0, -1
    b994:	14731803 	cmpu	r3, r19, r3
    b998:	be430830 	bltid	r3, 2096		// c1c8
    b99c:	30600018 	addik	r3, r0, 24
    b9a0:	30600010 	addik	r3, r0, 16	// 10 <_vector_interrupt>
    b9a4:	10830000 	addk	r4, r3, r0
    b9a8:	a643001f 	andi	r18, r3, 31
    b9ac:	10a09800 	addk	r5, r0, r19
    b9b0:	be120014 	beqid	r18, 20		// b9c4
    b9b4:	10a50000 	addk	r5, r5, r0
    b9b8:	3252ffff 	addik	r18, r18, -1
    b9bc:	be32fffc 	bneid	r18, -4		// b9b8
    b9c0:	90a50041 	srl	r5, r5
    b9c4:	b0000000 	imm	0
    b9c8:	e065e250 	lbui	r3, r5, -7600
    b9cc:	30a00020 	addik	r5, r0, 32	// 20 <_vector_hw_exception>
    b9d0:	10832000 	addk	r4, r3, r4
    b9d4:	14642800 	rsubk	r3, r4, r5
    b9d8:	bc2305a4 	bnei	r3, 1444		// bf7c
    b9dc:	16d3b000 	rsubk	r22, r19, r22
    b9e0:	b0000000 	imm	0
    b9e4:	a6f3ffff 	andi	r23, r19, -1
    b9e8:	30800001 	addik	r4, r0, 1
    b9ec:	13009800 	addk	r24, r0, r19
    b9f0:	93130041 	srl	r24, r19
    b9f4:	93180041 	srl	r24, r24
    b9f8:	93180041 	srl	r24, r24
    b9fc:	93180041 	srl	r24, r24
    ba00:	93180041 	srl	r24, r24
    ba04:	93180041 	srl	r24, r24
    ba08:	93180041 	srl	r24, r24
    ba0c:	93180041 	srl	r24, r24
    ba10:	93180041 	srl	r24, r24
    ba14:	93180041 	srl	r24, r24
    ba18:	93180041 	srl	r24, r24
    ba1c:	93180041 	srl	r24, r24
    ba20:	93180041 	srl	r24, r24
    ba24:	93180041 	srl	r24, r24
    ba28:	93180041 	srl	r24, r24
    ba2c:	93180041 	srl	r24, r24
    ba30:	10b60000 	addk	r5, r22, r0
    ba34:	10d80000 	addk	r6, r24, r0
    ba38:	b0000000 	imm	0
    ba3c:	b9f41740 	brlid	r15, 5952	// d17c <__umodsi3>
    ba40:	f881001c 	swi	r4, r1, 28
    ba44:	10b60000 	addk	r5, r22, r0
    ba48:	10d80000 	addk	r6, r24, r0
    ba4c:	b0000000 	imm	0
    ba50:	b9f41684 	brlid	r15, 5764	// d0d4 <__udivsi3>
    ba54:	13430000 	addk	r26, r3, r0
    ba58:	40c3b800 	mul	r6, r3, r23
    ba5c:	b0000001 	imm	1
    ba60:	60ba0000 	muli	r5, r26, 0
    ba64:	10e0c800 	addk	r7, r0, r25
    ba68:	90f90041 	srl	r7, r25
    ba6c:	90e70041 	srl	r7, r7
    ba70:	90e70041 	srl	r7, r7
    ba74:	90e70041 	srl	r7, r7
    ba78:	90e70041 	srl	r7, r7
    ba7c:	90e70041 	srl	r7, r7
    ba80:	90e70041 	srl	r7, r7
    ba84:	90e70041 	srl	r7, r7
    ba88:	90e70041 	srl	r7, r7
    ba8c:	90e70041 	srl	r7, r7
    ba90:	90e70041 	srl	r7, r7
    ba94:	90e70041 	srl	r7, r7
    ba98:	90e70041 	srl	r7, r7
    ba9c:	90e70041 	srl	r7, r7
    baa0:	90e70041 	srl	r7, r7
    baa4:	90e70041 	srl	r7, r7
    baa8:	80a53800 	or	r5, r5, r7
    baac:	12c30000 	addk	r22, r3, r0
    bab0:	14662803 	cmpu	r3, r6, r5
    bab4:	bea30028 	bgeid	r3, 40		// badc
    bab8:	e881001c 	lwi	r4, r1, 28
    babc:	10a59800 	addk	r5, r5, r19
    bac0:	14732803 	cmpu	r3, r19, r5
    bac4:	be430014 	bltid	r3, 20		// bad8
    bac8:	30f6ffff 	addik	r7, r22, -1
    bacc:	14662803 	cmpu	r3, r6, r5
    bad0:	be430740 	bltid	r3, 1856		// c210
    bad4:	32d6fffe 	addik	r22, r22, -2
    bad8:	12c70000 	addk	r22, r7, r0
    badc:	17462800 	rsubk	r26, r6, r5
    bae0:	10ba0000 	addk	r5, r26, r0
    bae4:	10d80000 	addk	r6, r24, r0
    bae8:	b0000000 	imm	0
    baec:	a739ffff 	andi	r25, r25, -1
    baf0:	b0000000 	imm	0
    baf4:	b9f41688 	brlid	r15, 5768	// d17c <__umodsi3>
    baf8:	f881001c 	swi	r4, r1, 28
    bafc:	10ba0000 	addk	r5, r26, r0
    bb00:	10d80000 	addk	r6, r24, r0
    bb04:	b0000000 	imm	0
    bb08:	b9f415cc 	brlid	r15, 5580	// d0d4 <__udivsi3>
    bb0c:	13630000 	addk	r27, r3, r0
    bb10:	10a30000 	addk	r5, r3, r0
    bb14:	b0000001 	imm	1
    bb18:	607b0000 	muli	r3, r27, 0
    bb1c:	8323c800 	or	r25, r3, r25
    bb20:	42e5b800 	mul	r23, r5, r23
    bb24:	1477c803 	cmpu	r3, r23, r25
    bb28:	bea30024 	bgeid	r3, 36		// bb4c
    bb2c:	e881001c 	lwi	r4, r1, 28
    bb30:	13399800 	addk	r25, r25, r19
    bb34:	1673c803 	cmpu	r19, r19, r25
    bb38:	be530660 	bltid	r19, 1632		// c198
    bb3c:	3065ffff 	addik	r3, r5, -1
    bb40:	16f7c803 	cmpu	r23, r23, r25
    bb44:	beb70654 	bgeid	r23, 1620		// c198
    bb48:	30a5fffe 	addik	r5, r5, -2
    bb4c:	b0000001 	imm	1
    bb50:	60760000 	muli	r3, r22, 0
    bb54:	b810000c 	brid	12		// bb60
    bb58:	80651800 	or	r3, r5, r3
    bb5c:	10640000 	addk	r3, r4, r0
    bb60:	e9e10000 	lwi	r15, r1, 0
    bb64:	ea610024 	lwi	r19, r1, 36
    bb68:	eac10028 	lwi	r22, r1, 40
    bb6c:	eae1002c 	lwi	r23, r1, 44
    bb70:	eb010030 	lwi	r24, r1, 48
    bb74:	eb210034 	lwi	r25, r1, 52
    bb78:	eb410038 	lwi	r26, r1, 56
    bb7c:	eb61003c 	lwi	r27, r1, 60
    bb80:	eb810040 	lwi	r28, r1, 64
    bb84:	eba10044 	lwi	r29, r1, 68
    bb88:	ebc10048 	lwi	r30, r1, 72
    bb8c:	b60f0008 	rtsd	r15, 8
    bb90:	3021004c 	addik	r1, r1, 76
    bb94:	14681803 	cmpu	r3, r8, r3
    bb98:	bc430618 	blti	r3, 1560		// c1b0
    bb9c:	10600000 	addk	r3, r0, r0
    bba0:	b810fd78 	brid	-648		// b918
    bba4:	10830000 	addk	r4, r3, r0
    bba8:	14671803 	cmpu	r3, r7, r3
    bbac:	bca305d8 	bgei	r3, 1496		// c184
    bbb0:	31000008 	addik	r8, r0, 8	// 8 <_vector_sw_exception>
    bbb4:	b810fb14 	brid	-1260		// b6c8
    bbb8:	10680000 	addk	r3, r8, r0
    bbbc:	14731803 	cmpu	r3, r19, r3
    bbc0:	bc4305fc 	blti	r3, 1532		// c1bc
    bbc4:	10600000 	addk	r3, r0, r0
    bbc8:	b810fde0 	brid	-544		// b9a8
    bbcc:	10830000 	addk	r4, r3, r0
    bbd0:	a643001f 	andi	r18, r3, 31
    bbd4:	10803800 	addk	r4, r0, r7
    bbd8:	be120014 	beqid	r18, 20		// bbec
    bbdc:	10840000 	addk	r4, r4, r0
    bbe0:	3252ffff 	addik	r18, r18, -1
    bbe4:	be32fffc 	bneid	r18, -4		// bbe0
    bbe8:	90840041 	srl	r4, r4
    bbec:	a653001f 	andi	r18, r19, 31
    bbf0:	13004000 	addk	r24, r0, r8
    bbf4:	be120014 	beqid	r18, 20		// bc08
    bbf8:	13180000 	addk	r24, r24, r0
    bbfc:	3252ffff 	addik	r18, r18, -1
    bc00:	be32fffc 	bneid	r18, -4		// bbfc
    bc04:	1318c000 	addk	r24, r24, r24
    bc08:	83182000 	or	r24, r24, r4
    bc0c:	a643001f 	andi	r18, r3, 31
    bc10:	1360b000 	addk	r27, r0, r22
    bc14:	be120014 	beqid	r18, 20		// bc28
    bc18:	137b0000 	addk	r27, r27, r0
    bc1c:	3252ffff 	addik	r18, r18, -1
    bc20:	be32fffc 	bneid	r18, -4		// bc1c
    bc24:	937b0041 	srl	r27, r27
    bc28:	1320c000 	addk	r25, r0, r24
    bc2c:	93380041 	srl	r25, r24
    bc30:	93390041 	srl	r25, r25
    bc34:	93390041 	srl	r25, r25
    bc38:	93390041 	srl	r25, r25
    bc3c:	93390041 	srl	r25, r25
    bc40:	93390041 	srl	r25, r25
    bc44:	93390041 	srl	r25, r25
    bc48:	93390041 	srl	r25, r25
    bc4c:	93390041 	srl	r25, r25
    bc50:	93390041 	srl	r25, r25
    bc54:	93390041 	srl	r25, r25
    bc58:	93390041 	srl	r25, r25
    bc5c:	93390041 	srl	r25, r25
    bc60:	93390041 	srl	r25, r25
    bc64:	93390041 	srl	r25, r25
    bc68:	93390041 	srl	r25, r25
    bc6c:	10bb0000 	addk	r5, r27, r0
    bc70:	10d90000 	addk	r6, r25, r0
    bc74:	a643001f 	andi	r18, r3, 31
    bc78:	1080b800 	addk	r4, r0, r23
    bc7c:	be120014 	beqid	r18, 20		// bc90
    bc80:	10840000 	addk	r4, r4, r0
    bc84:	3252ffff 	addik	r18, r18, -1
    bc88:	be32fffc 	bneid	r18, -4		// bc84
    bc8c:	90840041 	srl	r4, r4
    bc90:	a653001f 	andi	r18, r19, 31
    bc94:	13403800 	addk	r26, r0, r7
    bc98:	be120014 	beqid	r18, 20		// bcac
    bc9c:	135a0000 	addk	r26, r26, r0
    bca0:	3252ffff 	addik	r18, r18, -1
    bca4:	be32fffc 	bneid	r18, -4		// bca0
    bca8:	135ad000 	addk	r26, r26, r26
    bcac:	a653001f 	andi	r18, r19, 31
    bcb0:	1380b000 	addk	r28, r0, r22
    bcb4:	be120014 	beqid	r18, 20		// bcc8
    bcb8:	139c0000 	addk	r28, r28, r0
    bcbc:	3252ffff 	addik	r18, r18, -1
    bcc0:	be32fffc 	bneid	r18, -4		// bcbc
    bcc4:	139ce000 	addk	r28, r28, r28
    bcc8:	b0000000 	imm	0
    bccc:	b9f414b0 	brlid	r15, 5296	// d17c <__umodsi3>
    bcd0:	839c2000 	or	r28, r28, r4
    bcd4:	10bb0000 	addk	r5, r27, r0
    bcd8:	10d90000 	addk	r6, r25, r0
    bcdc:	b0000000 	imm	0
    bce0:	a778ffff 	andi	r27, r24, -1
    bce4:	b0000000 	imm	0
    bce8:	b9f413ec 	brlid	r15, 5100	// d0d4 <__udivsi3>
    bcec:	13a30000 	addk	r29, r3, r0
    bcf0:	4083d800 	mul	r4, r3, r27
    bcf4:	b0000001 	imm	1
    bcf8:	60fd0000 	muli	r7, r29, 0
    bcfc:	10a0e000 	addk	r5, r0, r28
    bd00:	90bc0041 	srl	r5, r28
    bd04:	90a50041 	srl	r5, r5
    bd08:	90a50041 	srl	r5, r5
    bd0c:	90a50041 	srl	r5, r5
    bd10:	90a50041 	srl	r5, r5
    bd14:	90a50041 	srl	r5, r5
    bd18:	90a50041 	srl	r5, r5
    bd1c:	90a50041 	srl	r5, r5
    bd20:	90a50041 	srl	r5, r5
    bd24:	90a50041 	srl	r5, r5
    bd28:	90a50041 	srl	r5, r5
    bd2c:	90a50041 	srl	r5, r5
    bd30:	90a50041 	srl	r5, r5
    bd34:	90a50041 	srl	r5, r5
    bd38:	90a50041 	srl	r5, r5
    bd3c:	90a50041 	srl	r5, r5
    bd40:	80e72800 	or	r7, r7, r5
    bd44:	12c30000 	addk	r22, r3, r0
    bd48:	14643803 	cmpu	r3, r4, r7
    bd4c:	bea30020 	bgeid	r3, 32		// bd6c
    bd50:	17a43800 	rsubk	r29, r4, r7
    bd54:	10e7c000 	addk	r7, r7, r24
    bd58:	14783803 	cmpu	r3, r24, r7
    bd5c:	bea30488 	bgeid	r3, 1160		// c1e4
    bd60:	30b6ffff 	addik	r5, r22, -1
    bd64:	12c50000 	addk	r22, r5, r0
    bd68:	17a43800 	rsubk	r29, r4, r7
    bd6c:	10bd0000 	addk	r5, r29, r0
    bd70:	b0000000 	imm	0
    bd74:	a79cffff 	andi	r28, r28, -1
    bd78:	b0000000 	imm	0
    bd7c:	b9f41400 	brlid	r15, 5120	// d17c <__umodsi3>
    bd80:	10d90000 	addk	r6, r25, r0
    bd84:	10bd0000 	addk	r5, r29, r0
    bd88:	10d90000 	addk	r6, r25, r0
    bd8c:	b0000000 	imm	0
    bd90:	b9f41344 	brlid	r15, 4932	// d0d4 <__udivsi3>
    bd94:	13c30000 	addk	r30, r3, r0
    bd98:	40c3d800 	mul	r6, r3, r27
    bd9c:	b0000001 	imm	1
    bda0:	60be0000 	muli	r5, r30, 0
    bda4:	80a5e000 	or	r5, r5, r28
    bda8:	10830000 	addk	r4, r3, r0
    bdac:	14662803 	cmpu	r3, r6, r5
    bdb0:	bca30018 	bgei	r3, 24		// bdc8
    bdb4:	10a5c000 	addk	r5, r5, r24
    bdb8:	14782803 	cmpu	r3, r24, r5
    bdbc:	bea30414 	bgeid	r3, 1044		// c1d0
    bdc0:	30e4ffff 	addik	r7, r4, -1
    bdc4:	10870000 	addk	r4, r7, r0
    bdc8:	b0000001 	imm	1
    bdcc:	60760000 	muli	r3, r22, 0
    bdd0:	80641800 	or	r3, r4, r3
    bdd4:	b0000000 	imm	0
    bdd8:	a563ffff 	andi	r11, r3, -1
    bddc:	b0000000 	imm	0
    bde0:	a55affff 	andi	r10, r26, -1
    bde4:	10e01800 	addk	r7, r0, r3
    bde8:	90e30041 	srl	r7, r3
    bdec:	90e70041 	srl	r7, r7
    bdf0:	90e70041 	srl	r7, r7
    bdf4:	90e70041 	srl	r7, r7
    bdf8:	90e70041 	srl	r7, r7
    bdfc:	90e70041 	srl	r7, r7
    be00:	90e70041 	srl	r7, r7
    be04:	90e70041 	srl	r7, r7
    be08:	90e70041 	srl	r7, r7
    be0c:	90e70041 	srl	r7, r7
    be10:	90e70041 	srl	r7, r7
    be14:	90e70041 	srl	r7, r7
    be18:	90e70041 	srl	r7, r7
    be1c:	90e70041 	srl	r7, r7
    be20:	90e70041 	srl	r7, r7
    be24:	90e70041 	srl	r7, r7
    be28:	1120d000 	addk	r9, r0, r26
    be2c:	913a0041 	srl	r9, r26
    be30:	91290041 	srl	r9, r9
    be34:	91290041 	srl	r9, r9
    be38:	91290041 	srl	r9, r9
    be3c:	91290041 	srl	r9, r9
    be40:	91290041 	srl	r9, r9
    be44:	91290041 	srl	r9, r9
    be48:	91290041 	srl	r9, r9
    be4c:	91290041 	srl	r9, r9
    be50:	91290041 	srl	r9, r9
    be54:	91290041 	srl	r9, r9
    be58:	91290041 	srl	r9, r9
    be5c:	91290041 	srl	r9, r9
    be60:	91290041 	srl	r9, r9
    be64:	91290041 	srl	r9, r9
    be68:	91290041 	srl	r9, r9
    be6c:	41075000 	mul	r8, r7, r10
    be70:	14a62800 	rsubk	r5, r6, r5
    be74:	408b4800 	mul	r4, r11, r9
    be78:	414b5000 	mul	r10, r11, r10
    be7c:	10882000 	addk	r4, r8, r4
    be80:	10c05000 	addk	r6, r0, r10
    be84:	90ca0041 	srl	r6, r10
    be88:	90c60041 	srl	r6, r6
    be8c:	90c60041 	srl	r6, r6
    be90:	90c60041 	srl	r6, r6
    be94:	90c60041 	srl	r6, r6
    be98:	90c60041 	srl	r6, r6
    be9c:	90c60041 	srl	r6, r6
    bea0:	90c60041 	srl	r6, r6
    bea4:	90c60041 	srl	r6, r6
    bea8:	90c60041 	srl	r6, r6
    beac:	90c60041 	srl	r6, r6
    beb0:	90c60041 	srl	r6, r6
    beb4:	90c60041 	srl	r6, r6
    beb8:	90c60041 	srl	r6, r6
    bebc:	90c60041 	srl	r6, r6
    bec0:	90c60041 	srl	r6, r6
    bec4:	10843000 	addk	r4, r4, r6
    bec8:	15082003 	cmpu	r8, r8, r4
    becc:	bea80010 	bgeid	r8, 16		// bedc
    bed0:	40e74800 	mul	r7, r7, r9
    bed4:	b0000001 	imm	1
    bed8:	30e70000 	addik	r7, r7, 0
    bedc:	10c02000 	addk	r6, r0, r4
    bee0:	90c40041 	srl	r6, r4
    bee4:	90c60041 	srl	r6, r6
    bee8:	90c60041 	srl	r6, r6
    beec:	90c60041 	srl	r6, r6
    bef0:	90c60041 	srl	r6, r6
    bef4:	90c60041 	srl	r6, r6
    bef8:	90c60041 	srl	r6, r6
    befc:	90c60041 	srl	r6, r6
    bf00:	90c60041 	srl	r6, r6
    bf04:	90c60041 	srl	r6, r6
    bf08:	90c60041 	srl	r6, r6
    bf0c:	90c60041 	srl	r6, r6
    bf10:	90c60041 	srl	r6, r6
    bf14:	90c60041 	srl	r6, r6
    bf18:	90c60041 	srl	r6, r6
    bf1c:	90c60041 	srl	r6, r6
    bf20:	10e73000 	addk	r7, r7, r6
    bf24:	14c72803 	cmpu	r6, r7, r5
    bf28:	be460264 	bltid	r6, 612		// c18c
    bf2c:	88e53800 	xor	r7, r5, r7
    bf30:	14a70000 	rsubk	r5, r7, r0
    bf34:	80e53800 	or	r7, r5, r7
    bf38:	bc47003c 	blti	r7, 60		// bf74
    bf3c:	b0000001 	imm	1
    bf40:	60840000 	muli	r4, r4, 0
    bf44:	b0000000 	imm	0
    bf48:	a54affff 	andi	r10, r10, -1
    bf4c:	10845000 	addk	r4, r4, r10
    bf50:	a653001f 	andi	r18, r19, 31
    bf54:	10a0b800 	addk	r5, r0, r23
    bf58:	be120014 	beqid	r18, 20		// bf6c
    bf5c:	10a50000 	addk	r5, r5, r0
    bf60:	3252ffff 	addik	r18, r18, -1
    bf64:	be32fffc 	bneid	r18, -4		// bf60
    bf68:	10a52800 	addk	r5, r5, r5
    bf6c:	14842803 	cmpu	r4, r4, r5
    bf70:	bc44021c 	blti	r4, 540		// c18c
    bf74:	b810fbec 	brid	-1044		// bb60
    bf78:	10800000 	addk	r4, r0, r0
    bf7c:	a643001f 	andi	r18, r3, 31
    bf80:	10a09800 	addk	r5, r0, r19
    bf84:	be120014 	beqid	r18, 20		// bf98
    bf88:	10a50000 	addk	r5, r5, r0
    bf8c:	3252ffff 	addik	r18, r18, -1
    bf90:	be32fffc 	bneid	r18, -4		// bf8c
    bf94:	10a52800 	addk	r5, r5, r5
    bf98:	a644001f 	andi	r18, r4, 31
    bf9c:	1340b000 	addk	r26, r0, r22
    bfa0:	be120014 	beqid	r18, 20		// bfb4
    bfa4:	135a0000 	addk	r26, r26, r0
    bfa8:	3252ffff 	addik	r18, r18, -1
    bfac:	be32fffc 	bneid	r18, -4		// bfa8
    bfb0:	935a0041 	srl	r26, r26
    bfb4:	13002800 	addk	r24, r0, r5
    bfb8:	93050041 	srl	r24, r5
    bfbc:	93180041 	srl	r24, r24
    bfc0:	93180041 	srl	r24, r24
    bfc4:	93180041 	srl	r24, r24
    bfc8:	93180041 	srl	r24, r24
    bfcc:	93180041 	srl	r24, r24
    bfd0:	93180041 	srl	r24, r24
    bfd4:	93180041 	srl	r24, r24
    bfd8:	93180041 	srl	r24, r24
    bfdc:	93180041 	srl	r24, r24
    bfe0:	93180041 	srl	r24, r24
    bfe4:	93180041 	srl	r24, r24
    bfe8:	93180041 	srl	r24, r24
    bfec:	93180041 	srl	r24, r24
    bff0:	93180041 	srl	r24, r24
    bff4:	93180041 	srl	r24, r24
    bff8:	f8a10020 	swi	r5, r1, 32
    bffc:	12650000 	addk	r19, r5, r0
    c000:	10d80000 	addk	r6, r24, r0
    c004:	10ba0000 	addk	r5, r26, r0
    c008:	a644001f 	andi	r18, r4, 31
    c00c:	10e0b800 	addk	r7, r0, r23
    c010:	be120014 	beqid	r18, 20		// c024
    c014:	10e70000 	addk	r7, r7, r0
    c018:	3252ffff 	addik	r18, r18, -1
    c01c:	be32fffc 	bneid	r18, -4		// c018
    c020:	90e70041 	srl	r7, r7
    c024:	a643001f 	andi	r18, r3, 31
    c028:	1360b000 	addk	r27, r0, r22
    c02c:	be120014 	beqid	r18, 20		// c040
    c030:	137b0000 	addk	r27, r27, r0
    c034:	3252ffff 	addik	r18, r18, -1
    c038:	be32fffc 	bneid	r18, -4		// c034
    c03c:	137bd800 	addk	r27, r27, r27
    c040:	a643001f 	andi	r18, r3, 31
    c044:	1320b800 	addk	r25, r0, r23
    c048:	be120014 	beqid	r18, 20		// c05c
    c04c:	13390000 	addk	r25, r25, r0
    c050:	3252ffff 	addik	r18, r18, -1
    c054:	be32fffc 	bneid	r18, -4		// c050
    c058:	1339c800 	addk	r25, r25, r25
    c05c:	b0000000 	imm	0
    c060:	b9f4111c 	brlid	r15, 4380	// d17c <__umodsi3>
    c064:	837b3800 	or	r27, r27, r7
    c068:	10ba0000 	addk	r5, r26, r0
    c06c:	10d80000 	addk	r6, r24, r0
    c070:	b0000000 	imm	0
    c074:	a6f3ffff 	andi	r23, r19, -1
    c078:	b0000000 	imm	0
    c07c:	b9f41058 	brlid	r15, 4184	// d0d4 <__udivsi3>
    c080:	12c30000 	addk	r22, r3, r0
    c084:	4083b800 	mul	r4, r3, r23
    c088:	b0000001 	imm	1
    c08c:	60d60000 	muli	r6, r22, 0
    c090:	10a0d800 	addk	r5, r0, r27
    c094:	90bb0041 	srl	r5, r27
    c098:	90a50041 	srl	r5, r5
    c09c:	90a50041 	srl	r5, r5
    c0a0:	90a50041 	srl	r5, r5
    c0a4:	90a50041 	srl	r5, r5
    c0a8:	90a50041 	srl	r5, r5
    c0ac:	90a50041 	srl	r5, r5
    c0b0:	90a50041 	srl	r5, r5
    c0b4:	90a50041 	srl	r5, r5
    c0b8:	90a50041 	srl	r5, r5
    c0bc:	90a50041 	srl	r5, r5
    c0c0:	90a50041 	srl	r5, r5
    c0c4:	90a50041 	srl	r5, r5
    c0c8:	90a50041 	srl	r5, r5
    c0cc:	90a50041 	srl	r5, r5
    c0d0:	90a50041 	srl	r5, r5
    c0d4:	80c62800 	or	r6, r6, r5
    c0d8:	13430000 	addk	r26, r3, r0
    c0dc:	14643003 	cmpu	r3, r4, r6
    c0e0:	bca30024 	bgei	r3, 36		// c104
    c0e4:	10c69800 	addk	r6, r6, r19
    c0e8:	14733003 	cmpu	r3, r19, r6
    c0ec:	be430114 	bltid	r3, 276		// c200
    c0f0:	30baffff 	addik	r5, r26, -1
    c0f4:	14643003 	cmpu	r3, r4, r6
    c0f8:	bca30108 	bgei	r3, 264		// c200
    c0fc:	335afffe 	addik	r26, r26, -2
    c100:	10c69800 	addk	r6, r6, r19
    c104:	16c43000 	rsubk	r22, r4, r6
    c108:	10b60000 	addk	r5, r22, r0
    c10c:	b0000000 	imm	0
    c110:	a77bffff 	andi	r27, r27, -1
    c114:	b0000000 	imm	0
    c118:	b9f41064 	brlid	r15, 4196	// d17c <__umodsi3>
    c11c:	10d80000 	addk	r6, r24, r0
    c120:	10b60000 	addk	r5, r22, r0
    c124:	10d80000 	addk	r6, r24, r0
    c128:	b0000000 	imm	0
    c12c:	b9f40fa8 	brlid	r15, 4008	// d0d4 <__udivsi3>
    c130:	13830000 	addk	r28, r3, r0
    c134:	42c3b800 	mul	r22, r3, r23
    c138:	b0000001 	imm	1
    c13c:	60bc0000 	muli	r5, r28, 0
    c140:	80a5d800 	or	r5, r5, r27
    c144:	10c30000 	addk	r6, r3, r0
    c148:	14762803 	cmpu	r3, r22, r5
    c14c:	bca30024 	bgei	r3, 36		// c170
    c150:	10a59800 	addk	r5, r5, r19
    c154:	14732803 	cmpu	r3, r19, r5
    c158:	be4300a0 	bltid	r3, 160		// c1f8
    c15c:	3086ffff 	addik	r4, r6, -1
    c160:	14762803 	cmpu	r3, r22, r5
    c164:	bca30094 	bgei	r3, 148		// c1f8
    c168:	30c6fffe 	addik	r6, r6, -2
    c16c:	10a59800 	addk	r5, r5, r19
    c170:	b0000001 	imm	1
    c174:	609a0000 	muli	r4, r26, 0
    c178:	16d62800 	rsubk	r22, r22, r5
    c17c:	b810f8b4 	brid	-1868		// ba30
    c180:	80862000 	or	r4, r6, r4
    c184:	b810f544 	brid	-2748		// b6c8
    c188:	10680000 	addk	r3, r8, r0
    c18c:	3063ffff 	addik	r3, r3, -1
    c190:	b810f9d0 	brid	-1584		// bb60
    c194:	10800000 	addk	r4, r0, r0
    c198:	b810f9b4 	brid	-1612		// bb4c
    c19c:	10a30000 	addk	r5, r3, r0
    c1a0:	b810f728 	brid	-2264		// b8c8
    c1a4:	10830000 	addk	r4, r3, r0
    c1a8:	b810f770 	brid	-2192		// b918
    c1ac:	10830000 	addk	r4, r3, r0
    c1b0:	30600008 	addik	r3, r0, 8	// 8 <_vector_sw_exception>
    c1b4:	b810f764 	brid	-2204		// b918
    c1b8:	10830000 	addk	r4, r3, r0
    c1bc:	30600008 	addik	r3, r0, 8	// 8 <_vector_sw_exception>
    c1c0:	b810f7e8 	brid	-2072		// b9a8
    c1c4:	10830000 	addk	r4, r3, r0
    c1c8:	b810f7e0 	brid	-2080		// b9a8
    c1cc:	10830000 	addk	r4, r3, r0
    c1d0:	14662803 	cmpu	r3, r6, r5
    c1d4:	bea3fbf0 	bgeid	r3, -1040		// bdc4
    c1d8:	3084fffe 	addik	r4, r4, -2
    c1dc:	b810fbec 	brid	-1044		// bdc8
    c1e0:	10a5c000 	addk	r5, r5, r24
    c1e4:	14643803 	cmpu	r3, r4, r7
    c1e8:	bea3fb7c 	bgeid	r3, -1156		// bd64
    c1ec:	32d6fffe 	addik	r22, r22, -2
    c1f0:	b810fb78 	brid	-1160		// bd68
    c1f4:	10e7c000 	addk	r7, r7, r24
    c1f8:	b810ff78 	brid	-136		// c170
    c1fc:	10c40000 	addk	r6, r4, r0
    c200:	b810ff04 	brid	-252		// c104
    c204:	13450000 	addk	r26, r5, r0
    c208:	b810f658 	brid	-2472		// b860
    c20c:	10849800 	addk	r4, r4, r19
    c210:	b810f8cc 	brid	-1844		// badc
    c214:	10a59800 	addk	r5, r5, r19
    c218:	15164003 	cmpu	r8, r22, r8
    c21c:	bc48f738 	blti	r8, -2248		// b954
    c220:	10930000 	addk	r4, r19, r0
    c224:	b810f93c 	brid	-1732		// bb60
    c228:	10730000 	addk	r3, r19, r0

0000c22c <__umoddi3>:
    c22c:	3021ffb4 	addik	r1, r1, -76
    c230:	fa610020 	swi	r19, r1, 32
    c234:	fac10024 	swi	r22, r1, 36
    c238:	fae10028 	swi	r23, r1, 40
    c23c:	fb01002c 	swi	r24, r1, 44
    c240:	fb410034 	swi	r26, r1, 52
    c244:	f9e10000 	swi	r15, r1, 0
    c248:	fb210030 	swi	r25, r1, 48
    c24c:	fb610038 	swi	r27, r1, 56
    c250:	fb81003c 	swi	r28, r1, 60
    c254:	fba10040 	swi	r29, r1, 64
    c258:	fbc10044 	swi	r30, r1, 68
    c25c:	fbe10048 	swi	r31, r1, 72
    c260:	12e50000 	addk	r23, r5, r0
    c264:	12c60000 	addk	r22, r6, r0
    c268:	13050000 	addk	r24, r5, r0
    c26c:	12670000 	addk	r19, r7, r0
    c270:	be280224 	bneid	r8, 548		// c494
    c274:	13460000 	addk	r26, r6, r0
    c278:	14673003 	cmpu	r3, r7, r6
    c27c:	bca30330 	bgei	r3, 816		// c5ac
    c280:	b0000000 	imm	0
    c284:	3060ffff 	addik	r3, r0, -1
    c288:	14671803 	cmpu	r3, r7, r3
    c28c:	bea30560 	bgeid	r3, 1376		// c7ec
    c290:	306000ff 	addik	r3, r0, 255
    c294:	b00000ff 	imm	255
    c298:	3060ffff 	addik	r3, r0, -1
    c29c:	14671803 	cmpu	r3, r7, r3
    c2a0:	be43091c 	bltid	r3, 2332		// cbbc
    c2a4:	31000018 	addik	r8, r0, 24
    c2a8:	31000010 	addik	r8, r0, 16	// 10 <_vector_interrupt>
    c2ac:	10680000 	addk	r3, r8, r0
    c2b0:	a648001f 	andi	r18, r8, 31
    c2b4:	10803800 	addk	r4, r0, r7
    c2b8:	be120014 	beqid	r18, 20		// c2cc
    c2bc:	10840000 	addk	r4, r4, r0
    c2c0:	3252ffff 	addik	r18, r18, -1
    c2c4:	be32fffc 	bneid	r18, -4		// c2c0
    c2c8:	90840041 	srl	r4, r4
    c2cc:	b0000000 	imm	0
    c2d0:	e084e250 	lbui	r4, r4, -7600
    c2d4:	10641800 	addk	r3, r4, r3
    c2d8:	30800020 	addik	r4, r0, 32	// 20 <_vector_hw_exception>
    c2dc:	17232000 	rsubk	r25, r3, r4
    c2e0:	bc190078 	beqi	r25, 120		// c358
    c2e4:	a659001f 	andi	r18, r25, 31
    c2e8:	1340b000 	addk	r26, r0, r22
    c2ec:	be120014 	beqid	r18, 20		// c300
    c2f0:	135a0000 	addk	r26, r26, r0
    c2f4:	3252ffff 	addik	r18, r18, -1
    c2f8:	be32fffc 	bneid	r18, -4		// c2f4
    c2fc:	135ad000 	addk	r26, r26, r26
    c300:	a643001f 	andi	r18, r3, 31
    c304:	1080b800 	addk	r4, r0, r23
    c308:	be120014 	beqid	r18, 20		// c31c
    c30c:	10840000 	addk	r4, r4, r0
    c310:	3252ffff 	addik	r18, r18, -1
    c314:	be32fffc 	bneid	r18, -4		// c310
    c318:	90840041 	srl	r4, r4
    c31c:	835a2000 	or	r26, r26, r4
    c320:	a659001f 	andi	r18, r25, 31
    c324:	12603800 	addk	r19, r0, r7
    c328:	be120014 	beqid	r18, 20		// c33c
    c32c:	12730000 	addk	r19, r19, r0
    c330:	3252ffff 	addik	r18, r18, -1
    c334:	be32fffc 	bneid	r18, -4		// c330
    c338:	12739800 	addk	r19, r19, r19
    c33c:	a659001f 	andi	r18, r25, 31
    c340:	1300b800 	addk	r24, r0, r23
    c344:	be120014 	beqid	r18, 20		// c358
    c348:	13180000 	addk	r24, r24, r0
    c34c:	3252ffff 	addik	r18, r18, -1
    c350:	be32fffc 	bneid	r18, -4		// c34c
    c354:	1318c000 	addk	r24, r24, r24
    c358:	12c09800 	addk	r22, r0, r19
    c35c:	92d30041 	srl	r22, r19
    c360:	92d60041 	srl	r22, r22
    c364:	92d60041 	srl	r22, r22
    c368:	92d60041 	srl	r22, r22
    c36c:	92d60041 	srl	r22, r22
    c370:	92d60041 	srl	r22, r22
    c374:	92d60041 	srl	r22, r22
    c378:	92d60041 	srl	r22, r22
    c37c:	92d60041 	srl	r22, r22
    c380:	92d60041 	srl	r22, r22
    c384:	92d60041 	srl	r22, r22
    c388:	92d60041 	srl	r22, r22
    c38c:	92d60041 	srl	r22, r22
    c390:	92d60041 	srl	r22, r22
    c394:	92d60041 	srl	r22, r22
    c398:	92d60041 	srl	r22, r22
    c39c:	10ba0000 	addk	r5, r26, r0
    c3a0:	b0000000 	imm	0
    c3a4:	a773ffff 	andi	r27, r19, -1
    c3a8:	b0000000 	imm	0
    c3ac:	b9f40dd0 	brlid	r15, 3536	// d17c <__umodsi3>
    c3b0:	10d60000 	addk	r6, r22, r0
    c3b4:	10ba0000 	addk	r5, r26, r0
    c3b8:	10d60000 	addk	r6, r22, r0
    c3bc:	b0000000 	imm	0
    c3c0:	b9f40d14 	brlid	r15, 3348	// d0d4 <__udivsi3>
    c3c4:	12e30000 	addk	r23, r3, r0
    c3c8:	40a3d800 	mul	r5, r3, r27
    c3cc:	b0000001 	imm	1
    c3d0:	60970000 	muli	r4, r23, 0
    c3d4:	10c0c000 	addk	r6, r0, r24
    c3d8:	90d80041 	srl	r6, r24
    c3dc:	90c60041 	srl	r6, r6
    c3e0:	90c60041 	srl	r6, r6
    c3e4:	90c60041 	srl	r6, r6
    c3e8:	90c60041 	srl	r6, r6
    c3ec:	90c60041 	srl	r6, r6
    c3f0:	90c60041 	srl	r6, r6
    c3f4:	90c60041 	srl	r6, r6
    c3f8:	90c60041 	srl	r6, r6
    c3fc:	90c60041 	srl	r6, r6
    c400:	90c60041 	srl	r6, r6
    c404:	90c60041 	srl	r6, r6
    c408:	90c60041 	srl	r6, r6
    c40c:	90c60041 	srl	r6, r6
    c410:	90c60041 	srl	r6, r6
    c414:	90c60041 	srl	r6, r6
    c418:	80843000 	or	r4, r4, r6
    c41c:	14652003 	cmpu	r3, r5, r4
    c420:	bea30028 	bgeid	r3, 40		// c448
    c424:	16e52000 	rsubk	r23, r5, r4
    c428:	10849800 	addk	r4, r4, r19
    c42c:	14732003 	cmpu	r3, r19, r4
    c430:	be430018 	bltid	r3, 24		// c448
    c434:	16e52000 	rsubk	r23, r5, r4
    c438:	14652003 	cmpu	r3, r5, r4
    c43c:	bea3000c 	bgeid	r3, 12		// c448
    c440:	10849800 	addk	r4, r4, r19
    c444:	16e52000 	rsubk	r23, r5, r4
    c448:	10b70000 	addk	r5, r23, r0
    c44c:	b0000000 	imm	0
    c450:	a718ffff 	andi	r24, r24, -1
    c454:	b0000000 	imm	0
    c458:	b9f40d24 	brlid	r15, 3364	// d17c <__umodsi3>
    c45c:	10d60000 	addk	r6, r22, r0
    c460:	10b70000 	addk	r5, r23, r0
    c464:	10d60000 	addk	r6, r22, r0
    c468:	b0000000 	imm	0
    c46c:	b9f40c68 	brlid	r15, 3176	// d0d4 <__udivsi3>
    c470:	13430000 	addk	r26, r3, r0
    c474:	4363d800 	mul	r27, r3, r27
    c478:	b0000001 	imm	1
    c47c:	607a0000 	muli	r3, r26, 0
    c480:	8303c000 	or	r24, r3, r24
    c484:	147bc003 	cmpu	r3, r27, r24
    c488:	bca302ec 	bgei	r3, 748		// c774
    c48c:	b81002d4 	brid	724		// c760
    c490:	13189800 	addk	r24, r24, r19
    c494:	14683003 	cmpu	r3, r8, r6
    c498:	be430304 	bltid	r3, 772		// c79c
    c49c:	10650000 	addk	r3, r5, r0
    c4a0:	b0000000 	imm	0
    c4a4:	3060ffff 	addik	r3, r0, -1
    c4a8:	14681803 	cmpu	r3, r8, r3
    c4ac:	bea3032c 	bgeid	r3, 812		// c7d8
    c4b0:	306000ff 	addik	r3, r0, 255
    c4b4:	b00000ff 	imm	255
    c4b8:	3060ffff 	addik	r3, r0, -1
    c4bc:	14681803 	cmpu	r3, r8, r3
    c4c0:	be430a7c 	bltid	r3, 2684		// cf3c
    c4c4:	30600018 	addik	r3, r0, 24
    c4c8:	30600010 	addik	r3, r0, 16	// 10 <_vector_interrupt>
    c4cc:	10830000 	addk	r4, r3, r0
    c4d0:	a643001f 	andi	r18, r3, 31
    c4d4:	10a04000 	addk	r5, r0, r8
    c4d8:	be120014 	beqid	r18, 20		// c4ec
    c4dc:	10a50000 	addk	r5, r5, r0
    c4e0:	3252ffff 	addik	r18, r18, -1
    c4e4:	be32fffc 	bneid	r18, -4		// c4e0
    c4e8:	90a50041 	srl	r5, r5
    c4ec:	b0000000 	imm	0
    c4f0:	e325e250 	lbui	r25, r5, -7600
    c4f4:	30600020 	addik	r3, r0, 32	// 20 <_vector_hw_exception>
    c4f8:	13392000 	addk	r25, r25, r4
    c4fc:	16791800 	rsubk	r19, r25, r3
    c500:	be330314 	bneid	r19, 788		// c814
    c504:	1467b803 	cmpu	r3, r7, r23
    c508:	bc430a80 	blti	r3, 2688		// cf88
    c50c:	14e7b800 	rsubk	r7, r7, r23
    c510:	13070000 	addk	r24, r7, r0
    c514:	16c8b000 	rsubk	r22, r8, r22
    c518:	14e7b803 	cmpu	r7, r7, r23
    c51c:	10603800 	addk	r3, r0, r7
    c520:	90670041 	srl	r3, r7
    c524:	90630041 	srl	r3, r3
    c528:	90630041 	srl	r3, r3
    c52c:	90630041 	srl	r3, r3
    c530:	90630041 	srl	r3, r3
    c534:	90630041 	srl	r3, r3
    c538:	90630041 	srl	r3, r3
    c53c:	90630041 	srl	r3, r3
    c540:	90630041 	srl	r3, r3
    c544:	90630041 	srl	r3, r3
    c548:	90630041 	srl	r3, r3
    c54c:	90630041 	srl	r3, r3
    c550:	90630041 	srl	r3, r3
    c554:	90630041 	srl	r3, r3
    c558:	90630041 	srl	r3, r3
    c55c:	90630041 	srl	r3, r3
    c560:	90630041 	srl	r3, r3
    c564:	90630041 	srl	r3, r3
    c568:	90630041 	srl	r3, r3
    c56c:	90630041 	srl	r3, r3
    c570:	90630041 	srl	r3, r3
    c574:	90630041 	srl	r3, r3
    c578:	90630041 	srl	r3, r3
    c57c:	90630041 	srl	r3, r3
    c580:	90630041 	srl	r3, r3
    c584:	90630041 	srl	r3, r3
    c588:	90630041 	srl	r3, r3
    c58c:	90630041 	srl	r3, r3
    c590:	90630041 	srl	r3, r3
    c594:	90630041 	srl	r3, r3
    c598:	90630041 	srl	r3, r3
    c59c:	1743b000 	rsubk	r26, r3, r22
    c5a0:	10780000 	addk	r3, r24, r0
    c5a4:	b81001fc 	brid	508		// c7a0
    c5a8:	109a0000 	addk	r4, r26, r0
    c5ac:	be270018 	bneid	r7, 24		// c5c4
    c5b0:	10c70000 	addk	r6, r7, r0
    c5b4:	b0000000 	imm	0
    c5b8:	b9f40b1c 	brlid	r15, 2844	// d0d4 <__udivsi3>
    c5bc:	30a00001 	addik	r5, r0, 1
    c5c0:	12630000 	addk	r19, r3, r0
    c5c4:	b0000000 	imm	0
    c5c8:	3060ffff 	addik	r3, r0, -1
    c5cc:	14731803 	cmpu	r3, r19, r3
    c5d0:	bea30230 	bgeid	r3, 560		// c800
    c5d4:	306000ff 	addik	r3, r0, 255
    c5d8:	b00000ff 	imm	255
    c5dc:	3060ffff 	addik	r3, r0, -1
    c5e0:	14731803 	cmpu	r3, r19, r3
    c5e4:	be430960 	bltid	r3, 2400		// cf44
    c5e8:	30600018 	addik	r3, r0, 24
    c5ec:	30600010 	addik	r3, r0, 16	// 10 <_vector_interrupt>
    c5f0:	10830000 	addk	r4, r3, r0
    c5f4:	a643001f 	andi	r18, r3, 31
    c5f8:	10a09800 	addk	r5, r0, r19
    c5fc:	be120014 	beqid	r18, 20		// c610
    c600:	10a50000 	addk	r5, r5, r0
    c604:	3252ffff 	addik	r18, r18, -1
    c608:	be32fffc 	bneid	r18, -4		// c604
    c60c:	90a50041 	srl	r5, r5
    c610:	b0000000 	imm	0
    c614:	e065e250 	lbui	r3, r5, -7600
    c618:	10632000 	addk	r3, r3, r4
    c61c:	30800020 	addik	r4, r0, 32	// 20 <_vector_hw_exception>
    c620:	17232000 	rsubk	r25, r3, r4
    c624:	bc3905a0 	bnei	r25, 1440		// cbc4
    c628:	16d3b000 	rsubk	r22, r19, r22
    c62c:	b0000000 	imm	0
    c630:	a773ffff 	andi	r27, r19, -1
    c634:	13409800 	addk	r26, r0, r19
    c638:	93530041 	srl	r26, r19
    c63c:	935a0041 	srl	r26, r26
    c640:	935a0041 	srl	r26, r26
    c644:	935a0041 	srl	r26, r26
    c648:	935a0041 	srl	r26, r26
    c64c:	935a0041 	srl	r26, r26
    c650:	935a0041 	srl	r26, r26
    c654:	935a0041 	srl	r26, r26
    c658:	935a0041 	srl	r26, r26
    c65c:	935a0041 	srl	r26, r26
    c660:	935a0041 	srl	r26, r26
    c664:	935a0041 	srl	r26, r26
    c668:	935a0041 	srl	r26, r26
    c66c:	935a0041 	srl	r26, r26
    c670:	935a0041 	srl	r26, r26
    c674:	935a0041 	srl	r26, r26
    c678:	10b60000 	addk	r5, r22, r0
    c67c:	b0000000 	imm	0
    c680:	b9f40afc 	brlid	r15, 2812	// d17c <__umodsi3>
    c684:	10da0000 	addk	r6, r26, r0
    c688:	10b60000 	addk	r5, r22, r0
    c68c:	10da0000 	addk	r6, r26, r0
    c690:	b0000000 	imm	0
    c694:	b9f40a40 	brlid	r15, 2624	// d0d4 <__udivsi3>
    c698:	12e30000 	addk	r23, r3, r0
    c69c:	40a3d800 	mul	r5, r3, r27
    c6a0:	b0000001 	imm	1
    c6a4:	60970000 	muli	r4, r23, 0
    c6a8:	10c0c000 	addk	r6, r0, r24
    c6ac:	90d80041 	srl	r6, r24
    c6b0:	90c60041 	srl	r6, r6
    c6b4:	90c60041 	srl	r6, r6
    c6b8:	90c60041 	srl	r6, r6
    c6bc:	90c60041 	srl	r6, r6
    c6c0:	90c60041 	srl	r6, r6
    c6c4:	90c60041 	srl	r6, r6
    c6c8:	90c60041 	srl	r6, r6
    c6cc:	90c60041 	srl	r6, r6
    c6d0:	90c60041 	srl	r6, r6
    c6d4:	90c60041 	srl	r6, r6
    c6d8:	90c60041 	srl	r6, r6
    c6dc:	90c60041 	srl	r6, r6
    c6e0:	90c60041 	srl	r6, r6
    c6e4:	90c60041 	srl	r6, r6
    c6e8:	90c60041 	srl	r6, r6
    c6ec:	80843000 	or	r4, r4, r6
    c6f0:	14652003 	cmpu	r3, r5, r4
    c6f4:	bea30024 	bgeid	r3, 36		// c718
    c6f8:	16c52000 	rsubk	r22, r5, r4
    c6fc:	10849800 	addk	r4, r4, r19
    c700:	14732003 	cmpu	r3, r19, r4
    c704:	be430014 	bltid	r3, 20		// c718
    c708:	16c52000 	rsubk	r22, r5, r4
    c70c:	14652003 	cmpu	r3, r5, r4
    c710:	bc430870 	blti	r3, 2160		// cf80
    c714:	16c52000 	rsubk	r22, r5, r4
    c718:	10b60000 	addk	r5, r22, r0
    c71c:	b0000000 	imm	0
    c720:	a718ffff 	andi	r24, r24, -1
    c724:	b0000000 	imm	0
    c728:	b9f40a54 	brlid	r15, 2644	// d17c <__umodsi3>
    c72c:	10da0000 	addk	r6, r26, r0
    c730:	10b60000 	addk	r5, r22, r0
    c734:	10da0000 	addk	r6, r26, r0
    c738:	b0000000 	imm	0
    c73c:	b9f40998 	brlid	r15, 2456	// d0d4 <__udivsi3>
    c740:	12e30000 	addk	r23, r3, r0
    c744:	4363d800 	mul	r27, r3, r27
    c748:	b0000001 	imm	1
    c74c:	60770000 	muli	r3, r23, 0
    c750:	8303c000 	or	r24, r3, r24
    c754:	147bc003 	cmpu	r3, r27, r24
    c758:	bca3001c 	bgei	r3, 28		// c774
    c75c:	13189800 	addk	r24, r24, r19
    c760:	1473c003 	cmpu	r3, r19, r24
    c764:	bc430010 	blti	r3, 16		// c774
    c768:	147bc003 	cmpu	r3, r27, r24
    c76c:	bca30008 	bgei	r3, 8		// c774
    c770:	13189800 	addk	r24, r24, r19
    c774:	171bc000 	rsubk	r24, r27, r24
    c778:	a659001f 	andi	r18, r25, 31
    c77c:	1060c000 	addk	r3, r0, r24
    c780:	be120014 	beqid	r18, 20		// c794
    c784:	10630000 	addk	r3, r3, r0
    c788:	3252ffff 	addik	r18, r18, -1
    c78c:	be32fffc 	bneid	r18, -4		// c788
    c790:	90630041 	srl	r3, r3
    c794:	b810000c 	brid	12		// c7a0
    c798:	10800000 	addk	r4, r0, r0
    c79c:	10860000 	addk	r4, r6, r0
    c7a0:	e9e10000 	lwi	r15, r1, 0
    c7a4:	ea610020 	lwi	r19, r1, 32
    c7a8:	eac10024 	lwi	r22, r1, 36
    c7ac:	eae10028 	lwi	r23, r1, 40
    c7b0:	eb01002c 	lwi	r24, r1, 44
    c7b4:	eb210030 	lwi	r25, r1, 48
    c7b8:	eb410034 	lwi	r26, r1, 52
    c7bc:	eb610038 	lwi	r27, r1, 56
    c7c0:	eb81003c 	lwi	r28, r1, 60
    c7c4:	eba10040 	lwi	r29, r1, 64
    c7c8:	ebc10044 	lwi	r30, r1, 68
    c7cc:	ebe10048 	lwi	r31, r1, 72
    c7d0:	b60f0008 	rtsd	r15, 8
    c7d4:	3021004c 	addik	r1, r1, 76
    c7d8:	14681803 	cmpu	r3, r8, r3
    c7dc:	bc430754 	blti	r3, 1876		// cf30
    c7e0:	10600000 	addk	r3, r0, r0
    c7e4:	b810fcec 	brid	-788		// c4d0
    c7e8:	10830000 	addk	r4, r3, r0
    c7ec:	14671803 	cmpu	r3, r7, r3
    c7f0:	bca303cc 	bgei	r3, 972		// cbbc
    c7f4:	31000008 	addik	r8, r0, 8	// 8 <_vector_sw_exception>
    c7f8:	b810fab8 	brid	-1352		// c2b0
    c7fc:	10680000 	addk	r3, r8, r0
    c800:	14731803 	cmpu	r3, r19, r3
    c804:	bc430748 	blti	r3, 1864		// cf4c
    c808:	10600000 	addk	r3, r0, r0
    c80c:	b810fde8 	brid	-536		// c5f4
    c810:	10830000 	addk	r4, r3, r0
    c814:	a659001f 	andi	r18, r25, 31
    c818:	10603800 	addk	r3, r0, r7
    c81c:	be120014 	beqid	r18, 20		// c830
    c820:	10630000 	addk	r3, r3, r0
    c824:	3252ffff 	addik	r18, r18, -1
    c828:	be32fffc 	bneid	r18, -4		// c824
    c82c:	90630041 	srl	r3, r3
    c830:	a653001f 	andi	r18, r19, 31
    c834:	13004000 	addk	r24, r0, r8
    c838:	be120014 	beqid	r18, 20		// c84c
    c83c:	13180000 	addk	r24, r24, r0
    c840:	3252ffff 	addik	r18, r18, -1
    c844:	be32fffc 	bneid	r18, -4		// c840
    c848:	1318c000 	addk	r24, r24, r24
    c84c:	83181800 	or	r24, r24, r3
    c850:	a659001f 	andi	r18, r25, 31
    c854:	1380b000 	addk	r28, r0, r22
    c858:	be120014 	beqid	r18, 20		// c86c
    c85c:	139c0000 	addk	r28, r28, r0
    c860:	3252ffff 	addik	r18, r18, -1
    c864:	be32fffc 	bneid	r18, -4		// c860
    c868:	939c0041 	srl	r28, r28
    c86c:	1340c000 	addk	r26, r0, r24
    c870:	93580041 	srl	r26, r24
    c874:	935a0041 	srl	r26, r26
    c878:	935a0041 	srl	r26, r26
    c87c:	935a0041 	srl	r26, r26
    c880:	935a0041 	srl	r26, r26
    c884:	935a0041 	srl	r26, r26
    c888:	935a0041 	srl	r26, r26
    c88c:	935a0041 	srl	r26, r26
    c890:	935a0041 	srl	r26, r26
    c894:	935a0041 	srl	r26, r26
    c898:	935a0041 	srl	r26, r26
    c89c:	935a0041 	srl	r26, r26
    c8a0:	935a0041 	srl	r26, r26
    c8a4:	935a0041 	srl	r26, r26
    c8a8:	935a0041 	srl	r26, r26
    c8ac:	935a0041 	srl	r26, r26
    c8b0:	10bc0000 	addk	r5, r28, r0
    c8b4:	10da0000 	addk	r6, r26, r0
    c8b8:	a659001f 	andi	r18, r25, 31
    c8bc:	1060b800 	addk	r3, r0, r23
    c8c0:	be120014 	beqid	r18, 20		// c8d4
    c8c4:	10630000 	addk	r3, r3, r0
    c8c8:	3252ffff 	addik	r18, r18, -1
    c8cc:	be32fffc 	bneid	r18, -4		// c8c8
    c8d0:	90630041 	srl	r3, r3
    c8d4:	a653001f 	andi	r18, r19, 31
    c8d8:	13603800 	addk	r27, r0, r7
    c8dc:	be120014 	beqid	r18, 20		// c8f0
    c8e0:	137b0000 	addk	r27, r27, r0
    c8e4:	3252ffff 	addik	r18, r18, -1
    c8e8:	be32fffc 	bneid	r18, -4		// c8e4
    c8ec:	137bd800 	addk	r27, r27, r27
    c8f0:	a653001f 	andi	r18, r19, 31
    c8f4:	13c0b000 	addk	r30, r0, r22
    c8f8:	be120014 	beqid	r18, 20		// c90c
    c8fc:	13de0000 	addk	r30, r30, r0
    c900:	3252ffff 	addik	r18, r18, -1
    c904:	be32fffc 	bneid	r18, -4		// c900
    c908:	13def000 	addk	r30, r30, r30
    c90c:	b0000000 	imm	0
    c910:	b9f4086c 	brlid	r15, 2156	// d17c <__umodsi3>
    c914:	83de1800 	or	r30, r30, r3
    c918:	10bc0000 	addk	r5, r28, r0
    c91c:	10da0000 	addk	r6, r26, r0
    c920:	b0000000 	imm	0
    c924:	a7b8ffff 	andi	r29, r24, -1
    c928:	b0000000 	imm	0
    c92c:	b9f407a8 	brlid	r15, 1960	// d0d4 <__udivsi3>
    c930:	13e30000 	addk	r31, r3, r0
    c934:	4083e800 	mul	r4, r3, r29
    c938:	b0000001 	imm	1
    c93c:	60ff0000 	muli	r7, r31, 0
    c940:	10a0f000 	addk	r5, r0, r30
    c944:	90be0041 	srl	r5, r30
    c948:	90a50041 	srl	r5, r5
    c94c:	90a50041 	srl	r5, r5
    c950:	90a50041 	srl	r5, r5
    c954:	90a50041 	srl	r5, r5
    c958:	90a50041 	srl	r5, r5
    c95c:	90a50041 	srl	r5, r5
    c960:	90a50041 	srl	r5, r5
    c964:	90a50041 	srl	r5, r5
    c968:	90a50041 	srl	r5, r5
    c96c:	90a50041 	srl	r5, r5
    c970:	90a50041 	srl	r5, r5
    c974:	90a50041 	srl	r5, r5
    c978:	90a50041 	srl	r5, r5
    c97c:	90a50041 	srl	r5, r5
    c980:	90a50041 	srl	r5, r5
    c984:	80e72800 	or	r7, r7, r5
    c988:	12c30000 	addk	r22, r3, r0
    c98c:	14643803 	cmpu	r3, r4, r7
    c990:	a653001f 	andi	r18, r19, 31
    c994:	1380b800 	addk	r28, r0, r23
    c998:	be120014 	beqid	r18, 20		// c9ac
    c99c:	139c0000 	addk	r28, r28, r0
    c9a0:	3252ffff 	addik	r18, r18, -1
    c9a4:	be32fffc 	bneid	r18, -4		// c9a0
    c9a8:	139ce000 	addk	r28, r28, r28
    c9ac:	bea30020 	bgeid	r3, 32		// c9cc
    c9b0:	16e43800 	rsubk	r23, r4, r7
    c9b4:	10e7c000 	addk	r7, r7, r24
    c9b8:	14783803 	cmpu	r3, r24, r7
    c9bc:	bea305b0 	bgeid	r3, 1456		// cf6c
    c9c0:	30b6ffff 	addik	r5, r22, -1
    c9c4:	12c50000 	addk	r22, r5, r0
    c9c8:	16e43800 	rsubk	r23, r4, r7
    c9cc:	10b70000 	addk	r5, r23, r0
    c9d0:	b0000000 	imm	0
    c9d4:	a7deffff 	andi	r30, r30, -1
    c9d8:	b0000000 	imm	0
    c9dc:	b9f407a0 	brlid	r15, 1952	// d17c <__umodsi3>
    c9e0:	10da0000 	addk	r6, r26, r0
    c9e4:	10b70000 	addk	r5, r23, r0
    c9e8:	10da0000 	addk	r6, r26, r0
    c9ec:	b0000000 	imm	0
    c9f0:	b9f406e4 	brlid	r15, 1764	// d0d4 <__udivsi3>
    c9f4:	13e30000 	addk	r31, r3, r0
    c9f8:	40c3e800 	mul	r6, r3, r29
    c9fc:	b0000001 	imm	1
    ca00:	60bf0000 	muli	r5, r31, 0
    ca04:	80a5f000 	or	r5, r5, r30
    ca08:	10830000 	addk	r4, r3, r0
    ca0c:	14662803 	cmpu	r3, r6, r5
    ca10:	bca30018 	bgei	r3, 24		// ca28
    ca14:	10a5c000 	addk	r5, r5, r24
    ca18:	14782803 	cmpu	r3, r24, r5
    ca1c:	bea3053c 	bgeid	r3, 1340		// cf58
    ca20:	30e4ffff 	addik	r7, r4, -1
    ca24:	10870000 	addk	r4, r7, r0
    ca28:	b0000001 	imm	1
    ca2c:	62d60000 	muli	r22, r22, 0
    ca30:	8084b000 	or	r4, r4, r22
    ca34:	b0000000 	imm	0
    ca38:	a544ffff 	andi	r10, r4, -1
    ca3c:	b0000000 	imm	0
    ca40:	a53bffff 	andi	r9, r27, -1
    ca44:	11002000 	addk	r8, r0, r4
    ca48:	91040041 	srl	r8, r4
    ca4c:	91080041 	srl	r8, r8
    ca50:	91080041 	srl	r8, r8
    ca54:	91080041 	srl	r8, r8
    ca58:	91080041 	srl	r8, r8
    ca5c:	91080041 	srl	r8, r8
    ca60:	91080041 	srl	r8, r8
    ca64:	91080041 	srl	r8, r8
    ca68:	91080041 	srl	r8, r8
    ca6c:	91080041 	srl	r8, r8
    ca70:	91080041 	srl	r8, r8
    ca74:	91080041 	srl	r8, r8
    ca78:	91080041 	srl	r8, r8
    ca7c:	91080041 	srl	r8, r8
    ca80:	91080041 	srl	r8, r8
    ca84:	91080041 	srl	r8, r8
    ca88:	1060d800 	addk	r3, r0, r27
    ca8c:	907b0041 	srl	r3, r27
    ca90:	90630041 	srl	r3, r3
    ca94:	90630041 	srl	r3, r3
    ca98:	90630041 	srl	r3, r3
    ca9c:	90630041 	srl	r3, r3
    caa0:	90630041 	srl	r3, r3
    caa4:	90630041 	srl	r3, r3
    caa8:	90630041 	srl	r3, r3
    caac:	90630041 	srl	r3, r3
    cab0:	90630041 	srl	r3, r3
    cab4:	90630041 	srl	r3, r3
    cab8:	90630041 	srl	r3, r3
    cabc:	90630041 	srl	r3, r3
    cac0:	90630041 	srl	r3, r3
    cac4:	90630041 	srl	r3, r3
    cac8:	90630041 	srl	r3, r3
    cacc:	40e84800 	mul	r7, r8, r9
    cad0:	14a62800 	rsubk	r5, r6, r5
    cad4:	408a1800 	mul	r4, r10, r3
    cad8:	40ca4800 	mul	r6, r10, r9
    cadc:	10872000 	addk	r4, r7, r4
    cae0:	40681800 	mul	r3, r8, r3
    cae4:	11003000 	addk	r8, r0, r6
    cae8:	91060041 	srl	r8, r6
    caec:	91080041 	srl	r8, r8
    caf0:	91080041 	srl	r8, r8
    caf4:	91080041 	srl	r8, r8
    caf8:	91080041 	srl	r8, r8
    cafc:	91080041 	srl	r8, r8
    cb00:	91080041 	srl	r8, r8
    cb04:	91080041 	srl	r8, r8
    cb08:	91080041 	srl	r8, r8
    cb0c:	91080041 	srl	r8, r8
    cb10:	91080041 	srl	r8, r8
    cb14:	91080041 	srl	r8, r8
    cb18:	91080041 	srl	r8, r8
    cb1c:	91080041 	srl	r8, r8
    cb20:	91080041 	srl	r8, r8
    cb24:	91080041 	srl	r8, r8
    cb28:	10844000 	addk	r4, r4, r8
    cb2c:	14e72003 	cmpu	r7, r7, r4
    cb30:	bca7000c 	bgei	r7, 12		// cb3c
    cb34:	b0000001 	imm	1
    cb38:	30630000 	addik	r3, r3, 0
    cb3c:	10e02000 	addk	r7, r0, r4
    cb40:	90e40041 	srl	r7, r4
    cb44:	90e70041 	srl	r7, r7
    cb48:	90e70041 	srl	r7, r7
    cb4c:	90e70041 	srl	r7, r7
    cb50:	90e70041 	srl	r7, r7
    cb54:	90e70041 	srl	r7, r7
    cb58:	90e70041 	srl	r7, r7
    cb5c:	90e70041 	srl	r7, r7
    cb60:	90e70041 	srl	r7, r7
    cb64:	90e70041 	srl	r7, r7
    cb68:	90e70041 	srl	r7, r7
    cb6c:	90e70041 	srl	r7, r7
    cb70:	90e70041 	srl	r7, r7
    cb74:	90e70041 	srl	r7, r7
    cb78:	90e70041 	srl	r7, r7
    cb7c:	90e70041 	srl	r7, r7
    cb80:	10633800 	addk	r3, r3, r7
    cb84:	b0000001 	imm	1
    cb88:	60840000 	muli	r4, r4, 0
    cb8c:	b0000000 	imm	0
    cb90:	a4c6ffff 	andi	r6, r6, -1
    cb94:	14e32803 	cmpu	r7, r3, r5
    cb98:	be47021c 	bltid	r7, 540		// cdb4
    cb9c:	10843000 	addk	r4, r4, r6
    cba0:	88c51800 	xor	r6, r5, r3
    cba4:	14e60000 	rsubk	r7, r6, r0
    cba8:	80c73000 	or	r6, r7, r6
    cbac:	bea60204 	bgeid	r6, 516		// cdb0
    cbb0:	14c4e003 	cmpu	r6, r4, r28
    cbb4:	b8100290 	brid	656		// ce44
    cbb8:	13640000 	addk	r27, r4, r0
    cbbc:	b810f6f4 	brid	-2316		// c2b0
    cbc0:	10680000 	addk	r3, r8, r0
    cbc4:	a643001f 	andi	r18, r3, 31
    cbc8:	1300b000 	addk	r24, r0, r22
    cbcc:	be120014 	beqid	r18, 20		// cbe0
    cbd0:	13180000 	addk	r24, r24, r0
    cbd4:	3252ffff 	addik	r18, r18, -1
    cbd8:	be32fffc 	bneid	r18, -4		// cbd4
    cbdc:	93180041 	srl	r24, r24
    cbe0:	a659001f 	andi	r18, r25, 31
    cbe4:	10809800 	addk	r4, r0, r19
    cbe8:	be120014 	beqid	r18, 20		// cbfc
    cbec:	10840000 	addk	r4, r4, r0
    cbf0:	3252ffff 	addik	r18, r18, -1
    cbf4:	be32fffc 	bneid	r18, -4		// cbf0
    cbf8:	10842000 	addk	r4, r4, r4
    cbfc:	10b80000 	addk	r5, r24, r0
    cc00:	13402000 	addk	r26, r0, r4
    cc04:	93440041 	srl	r26, r4
    cc08:	935a0041 	srl	r26, r26
    cc0c:	935a0041 	srl	r26, r26
    cc10:	935a0041 	srl	r26, r26
    cc14:	935a0041 	srl	r26, r26
    cc18:	935a0041 	srl	r26, r26
    cc1c:	935a0041 	srl	r26, r26
    cc20:	935a0041 	srl	r26, r26
    cc24:	935a0041 	srl	r26, r26
    cc28:	935a0041 	srl	r26, r26
    cc2c:	935a0041 	srl	r26, r26
    cc30:	935a0041 	srl	r26, r26
    cc34:	935a0041 	srl	r26, r26
    cc38:	935a0041 	srl	r26, r26
    cc3c:	935a0041 	srl	r26, r26
    cc40:	935a0041 	srl	r26, r26
    cc44:	10da0000 	addk	r6, r26, r0
    cc48:	f881001c 	swi	r4, r1, 28
    cc4c:	12640000 	addk	r19, r4, r0
    cc50:	a643001f 	andi	r18, r3, 31
    cc54:	1080b800 	addk	r4, r0, r23
    cc58:	be120014 	beqid	r18, 20		// cc6c
    cc5c:	10840000 	addk	r4, r4, r0
    cc60:	3252ffff 	addik	r18, r18, -1
    cc64:	be32fffc 	bneid	r18, -4		// cc60
    cc68:	90840041 	srl	r4, r4
    cc6c:	a659001f 	andi	r18, r25, 31
    cc70:	1380b000 	addk	r28, r0, r22
    cc74:	be120014 	beqid	r18, 20		// cc88
    cc78:	139c0000 	addk	r28, r28, r0
    cc7c:	3252ffff 	addik	r18, r18, -1
    cc80:	be32fffc 	bneid	r18, -4		// cc7c
    cc84:	139ce000 	addk	r28, r28, r28
    cc88:	b0000000 	imm	0
    cc8c:	b9f404f0 	brlid	r15, 1264	// d17c <__umodsi3>
    cc90:	839c2000 	or	r28, r28, r4
    cc94:	10b80000 	addk	r5, r24, r0
    cc98:	10da0000 	addk	r6, r26, r0
    cc9c:	b0000000 	imm	0
    cca0:	a773ffff 	andi	r27, r19, -1
    cca4:	b0000000 	imm	0
    cca8:	b9f4042c 	brlid	r15, 1068	// d0d4 <__udivsi3>
    ccac:	12c30000 	addk	r22, r3, r0
    ccb0:	40c3d800 	mul	r6, r3, r27
    ccb4:	b0000001 	imm	1
    ccb8:	60b60000 	muli	r5, r22, 0
    ccbc:	1080e000 	addk	r4, r0, r28
    ccc0:	909c0041 	srl	r4, r28
    ccc4:	90840041 	srl	r4, r4
    ccc8:	90840041 	srl	r4, r4
    cccc:	90840041 	srl	r4, r4
    ccd0:	90840041 	srl	r4, r4
    ccd4:	90840041 	srl	r4, r4
    ccd8:	90840041 	srl	r4, r4
    ccdc:	90840041 	srl	r4, r4
    cce0:	90840041 	srl	r4, r4
    cce4:	90840041 	srl	r4, r4
    cce8:	90840041 	srl	r4, r4
    ccec:	90840041 	srl	r4, r4
    ccf0:	90840041 	srl	r4, r4
    ccf4:	90840041 	srl	r4, r4
    ccf8:	90840041 	srl	r4, r4
    ccfc:	90840041 	srl	r4, r4
    cd00:	80a52000 	or	r5, r5, r4
    cd04:	14662803 	cmpu	r3, r6, r5
    cd08:	a659001f 	andi	r18, r25, 31
    cd0c:	1300b800 	addk	r24, r0, r23
    cd10:	be120014 	beqid	r18, 20		// cd24
    cd14:	13180000 	addk	r24, r24, r0
    cd18:	3252ffff 	addik	r18, r18, -1
    cd1c:	be32fffc 	bneid	r18, -4		// cd18
    cd20:	1318c000 	addk	r24, r24, r24
    cd24:	bea30028 	bgeid	r3, 40		// cd4c
    cd28:	16c62800 	rsubk	r22, r6, r5
    cd2c:	10a59800 	addk	r5, r5, r19
    cd30:	14732803 	cmpu	r3, r19, r5
    cd34:	be430018 	bltid	r3, 24		// cd4c
    cd38:	16c62800 	rsubk	r22, r6, r5
    cd3c:	14662803 	cmpu	r3, r6, r5
    cd40:	bea3000c 	bgeid	r3, 12		// cd4c
    cd44:	10a59800 	addk	r5, r5, r19
    cd48:	16c62800 	rsubk	r22, r6, r5
    cd4c:	10b60000 	addk	r5, r22, r0
    cd50:	b0000000 	imm	0
    cd54:	a79cffff 	andi	r28, r28, -1
    cd58:	b0000000 	imm	0
    cd5c:	b9f40420 	brlid	r15, 1056	// d17c <__umodsi3>
    cd60:	10da0000 	addk	r6, r26, r0
    cd64:	10b60000 	addk	r5, r22, r0
    cd68:	10da0000 	addk	r6, r26, r0
    cd6c:	b0000000 	imm	0
    cd70:	b9f40364 	brlid	r15, 868	// d0d4 <__udivsi3>
    cd74:	12e30000 	addk	r23, r3, r0
    cd78:	42c3d800 	mul	r22, r3, r27
    cd7c:	b0000001 	imm	1
    cd80:	60970000 	muli	r4, r23, 0
    cd84:	8084e000 	or	r4, r4, r28
    cd88:	14762003 	cmpu	r3, r22, r4
    cd8c:	bca3001c 	bgei	r3, 28		// cda8
    cd90:	10849800 	addk	r4, r4, r19
    cd94:	14732003 	cmpu	r3, r19, r4
    cd98:	be430010 	bltid	r3, 16		// cda8
    cd9c:	14762003 	cmpu	r3, r22, r4
    cda0:	bca30008 	bgei	r3, 8		// cda8
    cda4:	10849800 	addk	r4, r4, r19
    cda8:	b810f8d0 	brid	-1840		// c678
    cdac:	16d62000 	rsubk	r22, r22, r4
    cdb0:	bca6fe04 	bgei	r6, -508		// cbb4
    cdb4:	177b2000 	rsubk	r27, r27, r4
    cdb8:	14781800 	rsubk	r3, r24, r3
    cdbc:	149b2003 	cmpu	r4, r27, r4
    cdc0:	10c02000 	addk	r6, r0, r4
    cdc4:	90c40041 	srl	r6, r4
    cdc8:	90c60041 	srl	r6, r6
    cdcc:	90c60041 	srl	r6, r6
    cdd0:	90c60041 	srl	r6, r6
    cdd4:	90c60041 	srl	r6, r6
    cdd8:	90c60041 	srl	r6, r6
    cddc:	90c60041 	srl	r6, r6
    cde0:	90c60041 	srl	r6, r6
    cde4:	90c60041 	srl	r6, r6
    cde8:	90c60041 	srl	r6, r6
    cdec:	90c60041 	srl	r6, r6
    cdf0:	90c60041 	srl	r6, r6
    cdf4:	90c60041 	srl	r6, r6
    cdf8:	90c60041 	srl	r6, r6
    cdfc:	90c60041 	srl	r6, r6
    ce00:	90c60041 	srl	r6, r6
    ce04:	90c60041 	srl	r6, r6
    ce08:	90c60041 	srl	r6, r6
    ce0c:	90c60041 	srl	r6, r6
    ce10:	90c60041 	srl	r6, r6
    ce14:	90c60041 	srl	r6, r6
    ce18:	90c60041 	srl	r6, r6
    ce1c:	90c60041 	srl	r6, r6
    ce20:	90c60041 	srl	r6, r6
    ce24:	90c60041 	srl	r6, r6
    ce28:	90c60041 	srl	r6, r6
    ce2c:	90c60041 	srl	r6, r6
    ce30:	90c60041 	srl	r6, r6
    ce34:	90c60041 	srl	r6, r6
    ce38:	90c60041 	srl	r6, r6
    ce3c:	90c60041 	srl	r6, r6
    ce40:	14661800 	rsubk	r3, r6, r3
    ce44:	177be000 	rsubk	r27, r27, r28
    ce48:	14a32800 	rsubk	r5, r3, r5
    ce4c:	179be003 	cmpu	r28, r27, r28
    ce50:	1080e000 	addk	r4, r0, r28
    ce54:	909c0041 	srl	r4, r28
    ce58:	90840041 	srl	r4, r4
    ce5c:	90840041 	srl	r4, r4
    ce60:	90840041 	srl	r4, r4
    ce64:	90840041 	srl	r4, r4
    ce68:	90840041 	srl	r4, r4
    ce6c:	90840041 	srl	r4, r4
    ce70:	90840041 	srl	r4, r4
    ce74:	90840041 	srl	r4, r4
    ce78:	90840041 	srl	r4, r4
    ce7c:	90840041 	srl	r4, r4
    ce80:	90840041 	srl	r4, r4
    ce84:	90840041 	srl	r4, r4
    ce88:	90840041 	srl	r4, r4
    ce8c:	90840041 	srl	r4, r4
    ce90:	90840041 	srl	r4, r4
    ce94:	90840041 	srl	r4, r4
    ce98:	90840041 	srl	r4, r4
    ce9c:	90840041 	srl	r4, r4
    cea0:	90840041 	srl	r4, r4
    cea4:	90840041 	srl	r4, r4
    cea8:	90840041 	srl	r4, r4
    ceac:	90840041 	srl	r4, r4
    ceb0:	90840041 	srl	r4, r4
    ceb4:	90840041 	srl	r4, r4
    ceb8:	90840041 	srl	r4, r4
    cebc:	90840041 	srl	r4, r4
    cec0:	90840041 	srl	r4, r4
    cec4:	90840041 	srl	r4, r4
    cec8:	90840041 	srl	r4, r4
    cecc:	90840041 	srl	r4, r4
    ced0:	14a42800 	rsubk	r5, r4, r5
    ced4:	a659001f 	andi	r18, r25, 31
    ced8:	12e02800 	addk	r23, r0, r5
    cedc:	be120014 	beqid	r18, 20		// cef0
    cee0:	12f70000 	addk	r23, r23, r0
    cee4:	3252ffff 	addik	r18, r18, -1
    cee8:	be32fffc 	bneid	r18, -4		// cee4
    ceec:	12f7b800 	addk	r23, r23, r23
    cef0:	a653001f 	andi	r18, r19, 31
    cef4:	1060d800 	addk	r3, r0, r27
    cef8:	be120014 	beqid	r18, 20		// cf0c
    cefc:	10630000 	addk	r3, r3, r0
    cf00:	3252ffff 	addik	r18, r18, -1
    cf04:	be32fffc 	bneid	r18, -4		// cf00
    cf08:	90630041 	srl	r3, r3
    cf0c:	a653001f 	andi	r18, r19, 31
    cf10:	10802800 	addk	r4, r0, r5
    cf14:	be120014 	beqid	r18, 20		// cf28
    cf18:	10840000 	addk	r4, r4, r0
    cf1c:	3252ffff 	addik	r18, r18, -1
    cf20:	be32fffc 	bneid	r18, -4		// cf1c
    cf24:	90840041 	srl	r4, r4
    cf28:	b810f878 	brid	-1928		// c7a0
    cf2c:	80771800 	or	r3, r23, r3
    cf30:	30600008 	addik	r3, r0, 8	// 8 <_vector_sw_exception>
    cf34:	b810f59c 	brid	-2660		// c4d0
    cf38:	10830000 	addk	r4, r3, r0
    cf3c:	b810f594 	brid	-2668		// c4d0
    cf40:	10830000 	addk	r4, r3, r0
    cf44:	b810f6b0 	brid	-2384		// c5f4
    cf48:	10830000 	addk	r4, r3, r0
    cf4c:	30600008 	addik	r3, r0, 8	// 8 <_vector_sw_exception>
    cf50:	b810f6a4 	brid	-2396		// c5f4
    cf54:	10830000 	addk	r4, r3, r0
    cf58:	14662803 	cmpu	r3, r6, r5
    cf5c:	bea3fac8 	bgeid	r3, -1336		// ca24
    cf60:	3084fffe 	addik	r4, r4, -2
    cf64:	b810fac4 	brid	-1340		// ca28
    cf68:	10a5c000 	addk	r5, r5, r24
    cf6c:	14643803 	cmpu	r3, r4, r7
    cf70:	bea3fa54 	bgeid	r3, -1452		// c9c4
    cf74:	32d6fffe 	addik	r22, r22, -2
    cf78:	b810fa50 	brid	-1456		// c9c8
    cf7c:	10e7c000 	addk	r7, r7, r24
    cf80:	b810f794 	brid	-2156		// c714
    cf84:	10849800 	addk	r4, r4, r19
    cf88:	14764003 	cmpu	r3, r22, r8
    cf8c:	bea3f614 	bgeid	r3, -2540		// c5a0
    cf90:	14e7b800 	rsubk	r7, r7, r23
    cf94:	b810f580 	brid	-2688		// c514
    cf98:	13070000 	addk	r24, r7, r0

0000cf9c <__divsi3>:
    cf9c:	3021fff0 	addik	r1, r1, -16
    cfa0:	fb810000 	swi	r28, r1, 0
    cfa4:	fba10004 	swi	r29, r1, 4
    cfa8:	fbc10008 	swi	r30, r1, 8
    cfac:	fbe1000c 	swi	r31, r1, 12
    cfb0:	bc06006c 	beqi	r6, 108		// d01c
    cfb4:	bc050068 	beqi	r5, 104		// d01c
    cfb8:	bea5000c 	bgeid	r5, 12		// cfc4
    cfbc:	8b853000 	xor	r28, r5, r6
    cfc0:	24a50000 	rsubi	r5, r5, 0
    cfc4:	bca60008 	bgei	r6, 8		// cfcc
    cfc8:	24c60000 	rsubi	r6, r6, 0
    cfcc:	33c00000 	addik	r30, r0, 0
    cfd0:	30600000 	addik	r3, r0, 0
    cfd4:	33a00020 	addik	r29, r0, 32	// 20 <_vector_hw_exception>
    cfd8:	bc450010 	blti	r5, 16		// cfe8
    cfdc:	00a52800 	add	r5, r5, r5
    cfe0:	be85fffc 	bgtid	r5, -4		// cfdc
    cfe4:	33bdffff 	addik	r29, r29, -1
    cfe8:	00a52800 	add	r5, r5, r5
    cfec:	0bdef000 	addc	r30, r30, r30
    cff0:	07e6f000 	rsub	r31, r6, r30
    cff4:	bc5f000c 	blti	r31, 12		// d000
    cff8:	83c0f800 	or	r30, r0, r31
    cffc:	30630001 	addik	r3, r3, 1
    d000:	33bdffff 	addik	r29, r29, -1
    d004:	bc1d000c 	beqi	r29, 12		// d010
    d008:	00631800 	add	r3, r3, r3
    d00c:	b800ffdc 	bri	-36		// cfe8
    d010:	bcbc0010 	bgei	r28, 16		// d020
    d014:	b810000c 	brid	12		// d020
    d018:	24630000 	rsubi	r3, r3, 0
    d01c:	80600000 	or	r3, r0, r0
    d020:	eb810000 	lwi	r28, r1, 0
    d024:	eba10004 	lwi	r29, r1, 4
    d028:	ebc10008 	lwi	r30, r1, 8
    d02c:	ebe1000c 	lwi	r31, r1, 12
    d030:	b60f0008 	rtsd	r15, 8
    d034:	30210010 	addik	r1, r1, 16

0000d038 <__modsi3>:
    d038:	3021fff0 	addik	r1, r1, -16
    d03c:	fb810000 	swi	r28, r1, 0
    d040:	fba10004 	swi	r29, r1, 4
    d044:	fbc10008 	swi	r30, r1, 8
    d048:	fbe1000c 	swi	r31, r1, 12
    d04c:	bc06006c 	beqi	r6, 108		// d0b8
    d050:	bc050068 	beqi	r5, 104		// d0b8
    d054:	bea5000c 	bgeid	r5, 12		// d060
    d058:	03850000 	add	r28, r5, r0
    d05c:	24a50000 	rsubi	r5, r5, 0
    d060:	bca60008 	bgei	r6, 8		// d068
    d064:	24c60000 	rsubi	r6, r6, 0
    d068:	30600000 	addik	r3, r0, 0
    d06c:	33c00000 	addik	r30, r0, 0
    d070:	be450014 	bltid	r5, 20		// d084
    d074:	33a00020 	addik	r29, r0, 32	// 20 <_vector_hw_exception>
    d078:	00a52800 	add	r5, r5, r5
    d07c:	bea5fffc 	bgeid	r5, -4		// d078
    d080:	33bdffff 	addik	r29, r29, -1
    d084:	00a52800 	add	r5, r5, r5
    d088:	08631800 	addc	r3, r3, r3
    d08c:	07e61800 	rsub	r31, r6, r3
    d090:	bc5f000c 	blti	r31, 12		// d09c
    d094:	8060f800 	or	r3, r0, r31
    d098:	33de0001 	addik	r30, r30, 1
    d09c:	33bdffff 	addik	r29, r29, -1
    d0a0:	bc1d000c 	beqi	r29, 12		// d0ac
    d0a4:	03def000 	add	r30, r30, r30
    d0a8:	b800ffdc 	bri	-36		// d084
    d0ac:	bcbc0010 	bgei	r28, 16		// d0bc
    d0b0:	b810000c 	brid	12		// d0bc
    d0b4:	24630000 	rsubi	r3, r3, 0
    d0b8:	80600000 	or	r3, r0, r0
    d0bc:	eb810000 	lwi	r28, r1, 0
    d0c0:	eba10004 	lwi	r29, r1, 4
    d0c4:	ebc10008 	lwi	r30, r1, 8
    d0c8:	ebe1000c 	lwi	r31, r1, 12
    d0cc:	b60f0008 	rtsd	r15, 8
    d0d0:	30210010 	addik	r1, r1, 16

0000d0d4 <__udivsi3>:
    d0d4:	3021fff4 	addik	r1, r1, -12
    d0d8:	fba10000 	swi	r29, r1, 0
    d0dc:	fbc10004 	swi	r30, r1, 4
    d0e0:	fbe10008 	swi	r31, r1, 8
    d0e4:	bc060080 	beqi	r6, 128		// d164
    d0e8:	be05007c 	beqid	r5, 124		// d164
    d0ec:	33c00000 	addik	r30, r0, 0
    d0f0:	33a00020 	addik	r29, r0, 32	// 20 <_vector_hw_exception>
    d0f4:	06453000 	rsub	r18, r5, r6
    d0f8:	be120070 	beqid	r18, 112		// d168
    d0fc:	30600001 	addik	r3, r0, 1
    d100:	8a453000 	xor	r18, r5, r6
    d104:	beb20010 	bgeid	r18, 16		// d114
    d108:	00600000 	add	r3, r0, r0
    d10c:	bc46005c 	blti	r6, 92		// d168
    d110:	b800000c 	bri	12		// d11c
    d114:	06462800 	rsub	r18, r6, r5
    d118:	bc520050 	blti	r18, 80		// d168
    d11c:	bc86000c 	bgti	r6, 12		// d128
    d120:	b8100048 	brid	72		// d168
    d124:	30600001 	addik	r3, r0, 1
    d128:	bc450010 	blti	r5, 16		// d138
    d12c:	00a52800 	add	r5, r5, r5
    d130:	be85fffc 	bgtid	r5, -4		// d12c
    d134:	33bdffff 	addik	r29, r29, -1
    d138:	00a52800 	add	r5, r5, r5
    d13c:	0bdef000 	addc	r30, r30, r30
    d140:	07e6f000 	rsub	r31, r6, r30
    d144:	bc5f000c 	blti	r31, 12		// d150
    d148:	83c0f800 	or	r30, r0, r31
    d14c:	30630001 	addik	r3, r3, 1
    d150:	33bdffff 	addik	r29, r29, -1
    d154:	bc1d000c 	beqi	r29, 12		// d160
    d158:	00631800 	add	r3, r3, r3
    d15c:	b800ffdc 	bri	-36		// d138
    d160:	b8000008 	bri	8		// d168
    d164:	80600000 	or	r3, r0, r0
    d168:	eba10000 	lwi	r29, r1, 0
    d16c:	ebc10004 	lwi	r30, r1, 4
    d170:	ebe10008 	lwi	r31, r1, 8
    d174:	b60f0008 	rtsd	r15, 8
    d178:	3021000c 	addik	r1, r1, 12

0000d17c <__umodsi3>:
    d17c:	3021fff4 	addik	r1, r1, -12
    d180:	fba10000 	swi	r29, r1, 0
    d184:	fbc10004 	swi	r30, r1, 4
    d188:	fbe10008 	swi	r31, r1, 8
    d18c:	bc060094 	beqi	r6, 148		// d220
    d190:	be050090 	beqid	r5, 144		// d220
    d194:	30600000 	addik	r3, r0, 0
    d198:	33c00000 	addik	r30, r0, 0
    d19c:	33a00020 	addik	r29, r0, 32	// 20 <_vector_hw_exception>
    d1a0:	06453000 	rsub	r18, r5, r6
    d1a4:	bc120080 	beqi	r18, 128		// d224
    d1a8:	8a453000 	xor	r18, r5, r6
    d1ac:	beb20010 	bgeid	r18, 16		// d1bc
    d1b0:	30650000 	addik	r3, r5, 0
    d1b4:	bc460070 	blti	r6, 112		// d224
    d1b8:	b800000c 	bri	12		// d1c4
    d1bc:	06453000 	rsub	r18, r5, r6
    d1c0:	bc920064 	bgti	r18, 100		// d224
    d1c4:	be860020 	bgtid	r6, 32		// d1e4
    d1c8:	30600000 	addik	r3, r0, 0
    d1cc:	b0007fff 	imm	32767
    d1d0:	3240ffff 	addik	r18, r0, -1
    d1d4:	84a59000 	and	r5, r5, r18
    d1d8:	84c69000 	and	r6, r6, r18
    d1dc:	b8100048 	brid	72		// d224
    d1e0:	04662800 	rsub	r3, r6, r5
    d1e4:	bc450010 	blti	r5, 16		// d1f4
    d1e8:	00a52800 	add	r5, r5, r5
    d1ec:	bea5fffc 	bgeid	r5, -4		// d1e8
    d1f0:	33bdffff 	addik	r29, r29, -1
    d1f4:	00a52800 	add	r5, r5, r5
    d1f8:	08631800 	addc	r3, r3, r3
    d1fc:	07e61800 	rsub	r31, r6, r3
    d200:	bc5f000c 	blti	r31, 12		// d20c
    d204:	8060f800 	or	r3, r0, r31
    d208:	33de0001 	addik	r30, r30, 1
    d20c:	33bdffff 	addik	r29, r29, -1
    d210:	bc1d000c 	beqi	r29, 12		// d21c
    d214:	03def000 	add	r30, r30, r30
    d218:	b800ffdc 	bri	-36		// d1f4
    d21c:	b8000008 	bri	8		// d224
    d220:	80600000 	or	r3, r0, r0
    d224:	eba10000 	lwi	r29, r1, 0
    d228:	ebc10004 	lwi	r30, r1, 4
    d22c:	ebe10008 	lwi	r31, r1, 8
    d230:	b60f0008 	rtsd	r15, 8
    d234:	3021000c 	addik	r1, r1, 12

0000d238 <__do_global_ctors_aux>:
    d238:	b0000000 	imm	0
    d23c:	e860d5a8 	lwi	r3, r0, -10840	// d5a8 <__CTOR_LIST__>
    d240:	3021ffe0 	addik	r1, r1, -32
    d244:	f9e10000 	swi	r15, r1, 0
    d248:	a883ffff 	xori	r4, r3, -1
    d24c:	be040028 	beqid	r4, 40		// d274
    d250:	fa61001c 	swi	r19, r1, 28
    d254:	b0000000 	imm	0
    d258:	3260d5a8 	addik	r19, r0, -10840	// d5a8 <__CTOR_LIST__>
    d25c:	99fc1800 	brald	r15, r3
    d260:	80000000 	or	r0, r0, r0
    d264:	e873fffc 	lwi	r3, r19, -4
    d268:	a883ffff 	xori	r4, r3, -1
    d26c:	be24fff0 	bneid	r4, -16		// d25c
    d270:	3273fffc 	addik	r19, r19, -4
    d274:	e9e10000 	lwi	r15, r1, 0
    d278:	ea61001c 	lwi	r19, r1, 28
    d27c:	b60f0008 	rtsd	r15, 8
    d280:	30210020 	addik	r1, r1, 32

0000d284 <main>:
  cbuffer_push_back(rx_buffer, rx_tmp_buffer);
  XUartLite_Recv(&UartLite, (u8*)&rx_tmp_buffer, sizeof(uint32_t));
  LOG_DEBUG("recv %x\n", EventData);
}

int main(void) {
    d284:	3021ffc4 	addik	r1, r1, -60
    d288:	f9e10000 	swi	r15, r1, 0

  init_platform();
    d28c:	b000ffff 	imm	-1
    d290:	b9f443ac 	brlid	r15, 17324	// 163c <init_platform>
    d294:	fa610038 	swi	r19, r1, 56

  tx_buffer = cbuffer_new();
    d298:	b000ffff 	imm	-1
    d29c:	b9f44bc4 	brlid	r15, 19396	// 1e60 <cbuffer_new>
    d2a0:	80000000 	or	r0, r0, r0
    d2a4:	b0000000 	imm	0
    d2a8:	f860eaa0 	swi	r3, r0, -5472	// eaa0 <tx_buffer>
  rx_buffer = cbuffer_new();
    d2ac:	b000ffff 	imm	-1
    d2b0:	b9f44bb0 	brlid	r15, 19376	// 1e60 <cbuffer_new>
    d2b4:	80000000 	or	r0, r0, r0
    d2b8:	b0000000 	imm	0
    d2bc:	f860eae4 	swi	r3, r0, -5404	// eae4 <rx_buffer>

  int Status;
  u16 DeviceId = UARTLITE_DEVICE_ID;     

  LOG_INFO("UART CTP SPI server\n");
    d2c0:	b000ffff 	imm	-1
    d2c4:	b9f443b0 	brlid	r15, 17328	// 1674 <timenow>
    d2c8:	80000000 	or	r0, r0, r0
    d2cc:	b0000000 	imm	0
    d2d0:	30a0d64c 	addik	r5, r0, -10676
    d2d4:	b0000000 	imm	0
    d2d8:	30e0d670 	addik	r7, r0, -10640
    d2dc:	b000ffff 	imm	-1
    d2e0:	b9f465d4 	brlid	r15, 26068	// 38b4 <xil_printf>
    d2e4:	10c30000 	addk	r6, r3, r0

  /*
   * Initialize the UartLite driver so that it's ready to use.
   */
  Status = XUartLite_Initialize(&UartLite, DeviceId);
    d2e8:	b0000000 	imm	0
    d2ec:	30a0ec5c 	addik	r5, r0, -5028	// ec5c <UartLite>
    d2f0:	b000ffff 	imm	-1
    d2f4:	b9f476dc 	brlid	r15, 30428	// 49d0 <XUartLite_Initialize>
    d2f8:	10c00000 	addk	r6, r0, r0
  if (Status != XST_SUCCESS) {
    d2fc:	bc230220 	bnei	r3, 544		// d51c


  /*
   * Perform a self-test to ensure that the hardware was built correctly.
   */
  Status = XUartLite_SelfTest(&UartLite);
    d300:	b0000000 	imm	0
    d304:	30a0ec5c 	addik	r5, r0, -5028	// ec5c <UartLite>
    d308:	b000ffff 	imm	-1
    d30c:	b9f475bc 	brlid	r15, 30140	// 48c8 <XUartLite_SelfTest>
    d310:	80000000 	or	r0, r0, r0
  if (Status != XST_SUCCESS) {
    d314:	bc2301d8 	bnei	r3, 472		// d4ec

  /*
   * Connect the UartLite to the interrupt subsystem such that interrupts can
   * occur. This function is application specific.
   */
  Status = SetupInterruptSystem(&UartLite);
    d318:	b0000000 	imm	0
    d31c:	30a0ec5c 	addik	r5, r0, -5028	// ec5c <UartLite>
    d320:	b000ffff 	imm	-1
    d324:	b9f44578 	brlid	r15, 17784	// 189c <SetupInterruptSystem>
    d328:	80000000 	or	r0, r0, r0
  if (Status != XST_SUCCESS) {
    d32c:	be230184 	bneid	r3, 388		// d4b0
    d330:	12630000 	addk	r19, r3, r0
   * Setup the handlers for the UartLite that will be called from the
   * interrupt context when data has been sent and received, specify a
   * pointer to the UartLite driver instance as the callback reference so
   * that the handlers are able to access the instance data.
   */
  XUartLite_SetSendHandler(&UartLite, SendHandler, &UartLite);
    d334:	b0000000 	imm	0
    d338:	30a0ec5c 	addik	r5, r0, -5028	// ec5c <UartLite>
    d33c:	b0000000 	imm	0
    d340:	30c01778 	addik	r6, r0, 6008	// 1778 <SendHandler>
    d344:	b000ffff 	imm	-1
    d348:	b9f46c94 	brlid	r15, 27796	// 3fdc <XUartLite_SetSendHandler>
    d34c:	10e50000 	addk	r7, r5, r0
  XUartLite_SetRecvHandler(&UartLite, RecvHandler, &UartLite);
    d350:	b0000000 	imm	0
    d354:	30a0ec5c 	addik	r5, r0, -5028	// ec5c <UartLite>
    d358:	b0000000 	imm	0
    d35c:	30c016c8 	addik	r6, r0, 5832	// 16c8 <RecvHandler>
    d360:	b000ffff 	imm	-1
    d364:	b9f46bc0 	brlid	r15, 27584	// 3f24 <XUartLite_SetRecvHandler>
    d368:	10e50000 	addk	r7, r5, r0

  XUartLite_ResetFifos(&UartLite);
    d36c:	b0000000 	imm	0
    d370:	30a0ec5c 	addik	r5, r0, -5028	// ec5c <UartLite>
    d374:	b000ffff 	imm	-1
    d378:	b9f47038 	brlid	r15, 28728	// 43b0 <XUartLite_ResetFifos>
    d37c:	80000000 	or	r0, r0, r0

  /*
   * Enable the interrupt of the UartLite so that interrupts will occur.
   */
  XUartLite_EnableInterrupt(&UartLite);
    d380:	b0000000 	imm	0
    d384:	30a0ec5c 	addik	r5, r0, -5028	// ec5c <UartLite>
    d388:	b000ffff 	imm	-1
    d38c:	b9f46e8c 	brlid	r15, 28300	// 4218 <XUartLite_EnableInterrupt>
    d390:	80000000 	or	r0, r0, r0

  // bootstrap the READ
  XUartLite_Recv(&UartLite, (u8*)&rx_tmp_buffer, sizeof(uint32_t));
    d394:	b0000000 	imm	0
    d398:	30a0ec5c 	addik	r5, r0, -5028	// ec5c <UartLite>
    d39c:	b0000000 	imm	0
    d3a0:	30c0ea9c 	addik	r6, r0, -5476	// ea9c <rx_tmp_buffer>
    d3a4:	b000ffff 	imm	-1
    d3a8:	b9f473d4 	brlid	r15, 29652	// 477c <XUartLite_Recv>
    d3ac:	30e00004 	addik	r7, r0, 4

  /* serve forever */
  // There can be only one client - the forwarding server demux-es connections.
  Client client;
  client.outputstream = tx_buffer;
    d3b0:	b0000000 	imm	0
    d3b4:	e860eaa0 	lwi	r3, r0, -5472	// eaa0 <tx_buffer>
  client.inputstream = rx_buffer;
  client.swapbytes = 0;
    d3b8:	fa610034 	swi	r19, r1, 52
  XUartLite_Recv(&UartLite, (u8*)&rx_tmp_buffer, sizeof(uint32_t));

  /* serve forever */
  // There can be only one client - the forwarding server demux-es connections.
  Client client;
  client.outputstream = tx_buffer;
    d3bc:	f8610020 	swi	r3, r1, 32
  client.inputstream = rx_buffer;
    d3c0:	b0000000 	imm	0
    d3c4:	e860eae4 	lwi	r3, r0, -5404	// eae4 <rx_buffer>
  client.swapbytes = 0;

  LOG_INFO ("Serving memory.\n");
    d3c8:	b000ffff 	imm	-1
    d3cc:	b9f442a8 	brlid	r15, 17064	// 1674 <timenow>
    d3d0:	f861001c 	swi	r3, r1, 28
    d3d4:	b0000000 	imm	0
    d3d8:	30e0d670 	addik	r7, r0, -10640
    d3dc:	b0000000 	imm	0
    d3e0:	30a0d700 	addik	r5, r0, -10496
    d3e4:	b000ffff 	imm	-1
    d3e8:	b9f464cc 	brlid	r15, 25804	// 38b4 <xil_printf>
    d3ec:	10c30000 	addk	r6, r3, r0

  LOG_INFO ("Start size: %"PRIx32"\n", cbuffer_size(rx_buffer));
    d3f0:	b000ffff 	imm	-1
    d3f4:	b9f44280 	brlid	r15, 17024	// 1674 <timenow>
    d3f8:	80000000 	or	r0, r0, r0
    d3fc:	b0000000 	imm	0
    d400:	e8a0eae4 	lwi	r5, r0, -5404	// eae4 <rx_buffer>
    d404:	b000ffff 	imm	-1
    d408:	b9f44b10 	brlid	r15, 19216	// 1f18 <cbuffer_size>
    d40c:	12630000 	addk	r19, r3, r0
    d410:	b0000000 	imm	0
    d414:	30a0d720 	addik	r5, r0, -10464
    d418:	10d30000 	addk	r6, r19, r0
    d41c:	b0000000 	imm	0
    d420:	30e0d670 	addik	r7, r0, -10640
    d424:	b000ffff 	imm	-1
    d428:	b9f4648c 	brlid	r15, 25740	// 38b4 <xil_printf>
    d42c:	11030000 	addk	r8, r3, r0

  while (1) {
    ipbus_process_input_stream(&client);
    d430:	b000ffff 	imm	-1
    d434:	b9f45c40 	brlid	r15, 23616	// 3074 <ipbus_process_input_stream>
    d438:	30a1001c 	addik	r5, r1, 28
    // if we have data to send and the TX is currently idle, start sending it.
    if (!currently_sending && cbuffer_size(tx_buffer)) {
    d43c:	b0000000 	imm	0
    d440:	e860ea98 	lwi	r3, r0, -5480	// ea98 <currently_sending>
    d444:	bc23ffec 	bnei	r3, -20		// d430
    d448:	b0000000 	imm	0
    d44c:	e8a0eaa0 	lwi	r5, r0, -5472	// eaa0 <tx_buffer>
    d450:	b000ffff 	imm	-1
    d454:	b9f44ac4 	brlid	r15, 19140	// 1f18 <cbuffer_size>
    d458:	80000000 	or	r0, r0, r0
    d45c:	be03ffd4 	beqid	r3, -44		// d430
    d460:	30600001 	addik	r3, r0, 1
      currently_sending = 1;
      unsigned int to_send = cbuffer_contiguous_data_size(tx_buffer) * sizeof(uint32_t);
    d464:	b0000000 	imm	0
    d468:	e8a0eaa0 	lwi	r5, r0, -5472	// eaa0 <tx_buffer>

  while (1) {
    ipbus_process_input_stream(&client);
    // if we have data to send and the TX is currently idle, start sending it.
    if (!currently_sending && cbuffer_size(tx_buffer)) {
      currently_sending = 1;
    d46c:	b0000000 	imm	0
    d470:	f860ea98 	swi	r3, r0, -5480	// ea98 <currently_sending>
      unsigned int to_send = cbuffer_contiguous_data_size(tx_buffer) * sizeof(uint32_t);
    d474:	b000ffff 	imm	-1
    d478:	b9f44ac4 	brlid	r15, 19140	// 1f3c <cbuffer_contiguous_data_size>
    d47c:	80000000 	or	r0, r0, r0
      XUartLite_Send(&UartLite, (u8*)&(tx_buffer->data[tx_buffer->pos]), to_send);
    d480:	b0000000 	imm	0
    d484:	e880eaa0 	lwi	r4, r0, -5472	// eaa0 <tx_buffer>
    d488:	60e30004 	muli	r7, r3, 4
    d48c:	b0000000 	imm	0
    d490:	30a0ec5c 	addik	r5, r0, -5028	// ec5c <UartLite>
    d494:	e8640008 	lwi	r3, r4, 8
    d498:	e8c40000 	lwi	r6, r4, 0
    d49c:	60630004 	muli	r3, r3, 4
    d4a0:	b000ffff 	imm	-1
    d4a4:	b9f470c0 	brlid	r15, 28864	// 4564 <XUartLite_Send>
    d4a8:	10c61800 	addk	r6, r6, r3
    d4ac:	b800ff84 	bri	-124		// d430
   * Connect the UartLite to the interrupt subsystem such that interrupts can
   * occur. This function is application specific.
   */
  Status = SetupInterruptSystem(&UartLite);
  if (Status != XST_SUCCESS) {
    LOG_ERROR("Error: could not setup interrupts\n");
    d4b0:	b000ffff 	imm	-1
    d4b4:	b9f441c0 	brlid	r15, 16832	// 1674 <timenow>
    d4b8:	80000000 	or	r0, r0, r0
    d4bc:	b0000000 	imm	0
    d4c0:	30a0d6d0 	addik	r5, r0, -10544
    d4c4:	b0000000 	imm	0
    d4c8:	30e0d610 	addik	r7, r0, -10736
    d4cc:	b000ffff 	imm	-1
    d4d0:	b9f463e4 	brlid	r15, 25572	// 38b4 <xil_printf>
    d4d4:	10c30000 	addk	r6, r3, r0
      unsigned int to_send = cbuffer_contiguous_data_size(tx_buffer) * sizeof(uint32_t);
      XUartLite_Send(&UartLite, (u8*)&(tx_buffer->data[tx_buffer->pos]), to_send);
    }
  }

}
    d4d8:	e9e10000 	lwi	r15, r1, 0
    d4dc:	ea610038 	lwi	r19, r1, 56
    d4e0:	30600001 	addik	r3, r0, 1
    d4e4:	b60f0008 	rtsd	r15, 8
    d4e8:	3021003c 	addik	r1, r1, 60
  /*
   * Perform a self-test to ensure that the hardware was built correctly.
   */
  Status = XUartLite_SelfTest(&UartLite);
  if (Status != XST_SUCCESS) {
    LOG_ERROR("Error: self test failed\n");
    d4ec:	b000ffff 	imm	-1
    d4f0:	b9f44184 	brlid	r15, 16772	// 1674 <timenow>
    d4f4:	80000000 	or	r0, r0, r0
    d4f8:	b0000000 	imm	0
    d4fc:	30a0d6a8 	addik	r5, r0, -10584
    d500:	b0000000 	imm	0
    d504:	30e0d610 	addik	r7, r0, -10736
    d508:	b000ffff 	imm	-1
    d50c:	b9f463a8 	brlid	r15, 25512	// 38b4 <xil_printf>
    d510:	10c30000 	addk	r6, r3, r0
      return XST_FAILURE;
    d514:	b810ffc8 	brid	-56		// d4dc
    d518:	e9e10000 	lwi	r15, r1, 0
  /*
   * Initialize the UartLite driver so that it's ready to use.
   */
  Status = XUartLite_Initialize(&UartLite, DeviceId);
  if (Status != XST_SUCCESS) {
    LOG_ERROR("Error: could not initialize UART\n");
    d51c:	b000ffff 	imm	-1
    d520:	b9f44154 	brlid	r15, 16724	// 1674 <timenow>
    d524:	80000000 	or	r0, r0, r0
    d528:	b0000000 	imm	0
    d52c:	30a0d678 	addik	r5, r0, -10632
    d530:	b0000000 	imm	0
    d534:	30e0d610 	addik	r7, r0, -10736
    d538:	b000ffff 	imm	-1
    d53c:	b9f46378 	brlid	r15, 25464	// 38b4 <xil_printf>
    d540:	10c30000 	addk	r6, r3, r0
      return XST_FAILURE;
    d544:	b810ff98 	brid	-104		// d4dc
    d548:	e9e10000 	lwi	r15, r1, 0

Disassembly of section .init:

0000d54c <__init>:
    d54c:	3021fff8 	addik	r1, r1, -8
    d550:	d9e00800 	sw	r15, r0, r1
    d554:	3160ffff 	addik	r11, r0, -1
    d558:	940bc802 	mts	rshr, r11
    d55c:	31600000 	addik	r11, r0, 0
    d560:	940bc800 	mts	rslr, r11
    d564:	b000ffff 	imm	-1
    d568:	b9f42bd8 	brlid	r15, 11224	// 140 <frame_dummy>
    d56c:	80000000 	or	r0, r0, r0
    d570:	b000ffff 	imm	-1
    d574:	b9f4fcc4 	brlid	r15, -828	// d238 <__do_global_ctors_aux>
    d578:	80000000 	or	r0, r0, r0
    d57c:	c9e00800 	lw	r15, r0, r1
    d580:	b60f0008 	rtsd	r15, 8
    d584:	30210008 	addik	r1, r1, 8

Disassembly of section .fini:

0000d588 <__fini>:
    d588:	3021fff8 	addik	r1, r1, -8
    d58c:	d9e00800 	sw	r15, r0, r1
    d590:	b000ffff 	imm	-1
    d594:	b9f42af0 	brlid	r15, 10992	// 84 <__do_global_dtors_aux>
    d598:	80000000 	or	r0, r0, r0
    d59c:	c9e00800 	lw	r15, r0, r1
    d5a0:	b60f0008 	rtsd	r15, 8
    d5a4:	30210008 	addik	r1, r1, 8
